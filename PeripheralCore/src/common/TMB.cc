//-----------------------------------------------------------------------
// $Id: TMB.cc,v 3.103 2013/02/04 21:07:45 liu Exp $
// $Log: TMB.cc,v $
// Revision 3.103  2013/02/04 21:07:45  liu
// add delay in ADCvoltages() otherwise read back errors on fast Intel Gbit card
//
// Revision 3.102  2012/09/30 21:19:42  liu
// update for ME11 new electronics
//
// Revision 3.101  2012/07/06 01:42:53  liu
// add function used by STEP
//
// Revision 3.100  2012/05/09 20:59:00  liu
// fix missing standard header files
//
// Revision 3.99  2011/10/14 17:42:12  liu
// fix warnings for GCC4
//
// Revision 3.98  2010/08/25 19:45:41  liu
// read TMB voltages in VME jumbo packet
//
// Revision 3.97  2010/08/04 12:09:02  rakness
// clean up ADC voltage readings
//
// Revision 3.96  2010/07/29 11:23:24  rakness
// clean up getting TMB ADC voltages
//
// Revision 3.95  2010/07/16 12:28:58  rakness
// software for TMB firmware version 2010 July 7
//
// Revision 3.94  2010/05/13 15:37:02  rakness
// decode sync error register
//
// Revision 3.93  2010/05/05 11:46:58  liu
// make some stdout prints optional
//
// Revision 3.92  2010/02/21 23:52:39  liu
// add CFEB BadBits into TMB counters
//
// Revision 3.91  2010/02/03 12:19:02  rakness
// add CFEB badbits blocking (for TMB firmware 14 Jan 2010)
//
// Revision 3.90  2009/11/17 10:04:10  rakness
// include CFEB to TMB integer delays to align CLCT-ALCT matching
//
// Revision 3.89  2009/10/27 11:07:26  rakness
// 15 Oct 2009 TMB firmware update
//
// Revision 3.88  2009/08/11 12:57:03  liu
// update checkvme_fail function
//
// Revision 3.87  2009/08/11 10:07:14  liu
// to skip monitoring if vme access failed
//
// Revision 3.86  2009/05/28 16:36:10  rakness
// update for May 2009 TMB and ALCT firmware versions
//
// Revision 3.85  2009/04/14 13:40:01  rakness
// add alct_posneg bit to enhance alct communications
//
// Revision 3.84  2009/04/04 10:44:51  rakness
// Update for TMB firmware 2009 March 16
//
// Revision 3.83  2009/03/25 10:19:41  liu
// move header files to include/emu/pc
//
// Revision 3.82  2009/03/23 11:10:45  liu
// remove compiler warnings
//
// Revision 3.81  2009/03/19 13:29:42  rakness
// clean up functionality in writing to userPROMs for TMB and ALCT.  This is to fix bug introduced in TMB v3.80 by using tmb_vme_new
//
// Revision 3.80  2009/03/06 16:45:28  rakness
// add methods for ALCT-TMB loopback
//
// Revision 3.79  2008/11/28 09:49:28  rakness
// include ME1/1 TMB firmware compilation specification into xml file
//
// Revision 3.78  2008/11/24 17:50:40  rakness
// update for TMB version 18 Nov 2008
//
// Revision 3.77  2008/11/18 16:57:41  rakness
// make unjam TMB more simple and robust
//
// Revision 3.76  2008/11/17 08:26:59  rakness
// add unjam TMB
//
// Revision 3.75  2008/09/30 14:27:07  liu
// read ALCT temperature in monitoring
//
// Revision 3.74  2008/08/13 11:30:54  geurts
// introduce emu::pc:: namespaces
// remove any occurences of "using namespace" and make std:: references explicit
//
// Revision 3.73  2008/08/08 14:12:21  liu
// fix Get/Set functions for database
//
// Revision 3.72  2008/08/08 11:01:24  rakness
// centralize logging
//
// Revision 3.71  2008/08/06 17:24:50  rakness
// add known_problem parameter to xml file; add time stamp + number of reads to config check output file
//
// Revision 3.70  2008/08/06 12:06:19  liu
// fix TMB/RAT firmware Hex vs Dec problem
//
// Revision 3.69  2008/08/05 11:41:48  rakness
// new configuration check page + clean up output
//
// Revision 3.68  2008/08/05 08:40:37  rakness
// add minimum number of times to read when checking configuration
//
// Revision 3.67  2008/07/31 13:33:43  liu
// bug fix in TMB counters
//
// Revision 3.66  2008/07/16 17:28:37  rakness
// (backwards incompatible!) updates for 3 June 2008 TMB firmware and v3 r10 DMB firmware
//
// Revision 3.65  2008/07/04 13:22:14  rakness
// add getter for distrip hot channel mask
//
// Revision 3.64  2008/06/12 21:08:55  rakness
// add firmware tags for DMB, CFEB, MPC, CCB into xml file; add check firmware button
//
// Revision 3.63  2008/05/29 11:36:06  liu
// add time-since-last-hard_reset in TMB counters
//
// Revision 3.62  2008/05/26 08:24:43  rakness
// for AFEB calibrations:  argument for TMB and ALCT::configure(2) to not write userPROMs; correctly respond to configuration written to broadcast slot
//
// Revision 3.61  2008/05/20 11:30:20  liu
// TMB counters in jumbo packet
//
// Revision 3.60  2008/05/12 10:23:16  rakness
// return control to VME bus after checking TMB PROM/FPGA IDs
//
// Revision 3.59  2008/04/19 14:56:55  rakness
// ALCT database check before loading ALCT firmware
//
// Revision 3.58  2008/02/28 18:36:36  rakness
// make TMB firmware loading robust against all failure modes except power cuts...
//
// Revision 3.57  2008/02/23 15:25:54  liu
// TMB online counters
//
// Revision 3.56  2008/01/18 15:42:15  rakness
// get methods for TMB/RAT on-board voltages and currents
//
// Revision 3.55  2008/01/07 15:08:55  rakness
// add xml parameters:  clct_stagger, clct_blanking, clct_pattern_id_thresh, aff_thresh, min_clct_separation.  Remove xml parameter:  clct_distrip_pretrig_thresh
//
// Revision 3.54  2007/12/06 15:12:41  rakness
// make scan parameters for synchronization configurable from hyperDAQ
//
// Revision 3.53  2007/11/07 08:54:57  rakness
// make the csc_id which is injected into the MPC injector RAM always be the correct one for this TMB
//
// Revision 3.52  2007/10/25 17:36:12  rakness
// Add option to enable/disable write to USER JTAG register to allow selective masking of broadcast JTAG commands.  Also enable/disable clocks with explicit write rather than read,write
//
// Revision 3.51  2007/10/24 13:21:31  rakness
// try to clean up and document TMB to MPC methods
//
// Revision 3.50  2007/10/08 15:04:36  rakness
// add ALCT and TMB raw hits button in hyperDAQ
//
// Revision 3.49  2007/08/27 11:28:34  geurts
// explicitly set an integer constant to long long int by suffixing it with LL
//
// Revision 3.48  2007/08/22 13:39:11  rakness
// add distrip hotchannel mask to xml file
//
// Revision 3.47  2007/08/16 11:40:23  rakness
// add Raw Hits Write Buffer Reset Counter
//
// Revision 3.46  2007/08/15 12:40:56  rakness
// determine sync parameters w/1 button, clean up output, control level of cout with debug_
//
// Revision 3.45  2007/08/06 14:20:08  rakness
// pulse teststrips and measure ALCT in CLCT match window
//
// Revision 3.44  2007/08/03 14:35:40  rakness
// begin commenting for doxygen, add hot-channel mask write, add writeregister together with fillregister
//
// Revision 3.43  2007/08/01 11:40:38  rakness
// reorder sleep in TMB raw hits to maximize chances of good data readout
//
// Revision 3.42  2007/07/26 13:09:32  rakness
// update CFEB rx scan for CLCT key layer 3 -> 2 change
//
// Revision 3.41  2007/07/24 11:15:35  rakness
// more bits checked in TMB-MPC test. Sorting algorithm based only on data which is passed
//
// Revision 3.40  2007/07/20 15:13:00  rakness
// improve emulation of MPC and TMB in TMB-MPC crate test
//
// Revision 3.39  2007/06/26 14:39:14  rakness
// fix cfeb_enable_expected bug
//
// Revision 3.38  2007/06/22 12:28:11  rakness
// fix checking of register 0x68 based on which registers are enabled
//
// Revision 3.37  2007/06/21 16:14:03  rakness
// online measurement of ALCT in CLCT matching window
//
// Revision 3.36  2007/06/14 14:47:55  rakness
// clean up MPC injection
//
// Revision 3.35  2007/06/12 09:56:57  rakness
// clean TMB Raw Hits
//
// Revision 3.34  2007/06/07 12:57:28  rakness
// update TMB counters
//
// Revision 3.33  2007/05/17 12:52:50  rakness
// ignore_ccb_startstop added to TMB configuration + write configuration to userPROM default
//
// Revision 3.32  2007/04/10 13:31:01  rakness
// add mpc_output_enable, remove rpc2/3
//
// Revision 3.30  2007/03/21 12:56:51  rakness
// update labels of TMB counters
//
// Revision 3.29  2007/03/14 08:59:03  rakness
// make parser dumb
//
// Revision 3.28  2007/03/08 03:14:20  liu
// include math.h
//
// Revision 3.27  2007/01/31 16:50:06  rakness
// complete set of TMB/ALCT/RAT xml parameters
//
// Revision 3.26  2006/11/15 16:01:36  mey
// Cleaning up code
//
// Revision 3.25  2006/11/10 12:43:07  rakness
// include TMB/ALCT configuration and state machine prints+checks to hyperDAQ
//
// Revision 3.24  2006/11/09 08:47:51  rakness
// add rpc0_raw_delay to xml file
//
// Revision 3.23  2006/10/21 17:40:58  mey
// Got rid of last commit
//
// Revision 3.21  2006/10/14 10:09:08  mey
// UPdate
//
// Revision 3.20  2006/10/13 15:34:39  rakness
// add mpc_phase
//
// Revision 3.19  2006/10/12 15:56:02  rakness
// cleaned up configuration checking for ALCT/TMB
//
// Revision 3.18  2006/10/10 15:34:58  rakness
// check TMB/ALCT configuration vs xml
//
// Revision 3.17  2006/10/06 12:15:40  rakness
// expand xml file
//
// Revision 3.16  2006/09/28 12:52:35  mey
// Update
//
// Revision 3.15  2006/09/24 13:34:39  rakness
// decode configuration registers
//
// Revision 3.14  2006/09/15 07:50:41  rakness
// dump config registers
//
// Revision 3.13  2006/09/14 11:47:57  mey
// update
//
// Revision 3.12  2006/09/13 14:13:32  mey
// Update
//
// Revision 3.11  2006/09/08 00:06:32  mey
// UPdate
//
// Revision 3.10  2006/09/07 15:23:05  rakness
// pull programming back into EMUjtag
//
// Revision 3.9  2006/09/06 12:38:11  rakness
// correct time stamp/copy vectors for user prom
//
// Revision 3.8  2006/09/05 10:13:17  rakness
// ALCT configure from prom
//
// Revision 3.7  2006/08/11 16:23:33  rakness
// able to write TMB user prom from configure()
//
// Revision 3.6  2006/08/10 15:46:30  mey
// UPdate
//
// Revision 3.5  2006/08/09 11:57:04  mey
// Got rid of version
//
// Revision 3.4  2006/08/09 09:39:47  mey
// Moved TMB_trgmode to TMB.cc
//
// Revision 3.3  2006/08/08 19:40:00  mey
// Fixed bug
//
// Revision 3.2  2006/08/08 19:23:08  mey
// Included Jtag sources
//
// Revision 3.1  2006/08/03 18:50:49  mey
// Replaced sleep with ::sleep
//
// Revision 3.0  2006/07/20 21:15:48  geurts
// *** empty log message ***
//
// Revision 2.75  2006/07/18 15:23:14  mey
// UPdate
//
// Revision 2.74  2006/07/18 14:12:47  mey
// Update
//
// Revision 2.73  2006/07/13 15:46:37  mey
// New Parser strurture
//
// Revision 2.72  2006/07/12 12:07:11  mey
// ALCT connectivity
//
// Revision 2.71  2006/07/11 13:23:15  mey
// Update
//
// Revision 2.70  2006/07/11 13:02:42  mey
// fixed bug
//
// Revision 2.69  2006/07/04 15:06:19  mey
// Fixed JTAG
//
// Revision 2.68  2006/06/22 13:06:14  mey
// Update
//
// Revision 2.67  2006/06/20 13:18:17  mey
// Update
//
// Revision 2.66  2006/06/16 13:05:24  mey
// Got rid of Compiler switches
//
// Revision 2.65  2006/06/12 12:47:17  mey
// Update
//
// Revision 2.64  2006/05/24 09:55:03  mey
// Added crate counters
//
// Revision 2.63  2006/05/19 12:46:48  mey
// Update
//
// Revision 2.62  2006/05/10 10:24:32  mey
// Update
//
// Revision 2.61  2006/04/27 18:46:04  mey
// UPdate
//
// Revision 2.60  2006/04/25 13:25:19  mey
// Update
//
// Revision 2.59  2006/04/11 15:27:42  mey
// Update
//
// Revision 2.58  2006/04/06 22:23:08  mey
// Update
//
// Revision 2.57  2006/03/28 10:44:21  mey
// Update
//
// Revision 2.56  2006/03/24 16:40:36  mey
// Update
//
// Revision 2.55  2006/03/22 14:36:52  mey
// UPdate
//
// Revision 2.54  2006/03/21 12:27:02  mey
// Update
//
// Revision 2.53  2006/03/20 13:34:40  mey
// Update
//
// Revision 2.52  2006/03/20 09:10:43  mey
// Update
//
// Revision 2.51  2006/03/17 15:51:04  mey
// New routines
//
// Revision 2.50  2006/03/10 13:13:13  mey
// Jinghua's changes
//
// Revision 2.49  2006/03/09 22:30:16  mey
// Jinghua's updates
//
// Revision 2.48  2006/03/08 22:53:12  mey
// Update
//
// Revision 2.47  2006/03/05 18:45:08  mey
// Update
//
// Revision 2.46  2006/03/03 07:59:20  mey
// Update
//
// Revision 2.45  2006/02/06 14:09:07  mey
// Fixed bug
//
// Revision 2.44  2006/02/06 14:06:55  mey
// Fixed stream
//
// Revision 2.43  2006/02/02 14:27:32  mey
// Update
//
// Revision 2.42  2006/02/01 18:31:50  mey
// Update
//
// Revision 2.41  2006/02/01 13:30:55  mey
// Fixed ADC readout
//
// Revision 2.40  2006/01/31 14:42:14  mey
// Update
//
// Revision 2.39  2006/01/31 08:52:13  mey
// Update
//
// Revision 2.38  2006/01/23 15:00:10  mey
// Update
//
// Revision 2.37  2006/01/23 13:56:53  mey
// Update using Greg's new code
//
// Revision 2.36  2006/01/20 09:34:30  mey
// Got rid of LATER
//
// Revision 2.35  2006/01/18 12:45:44  mey
// Cleaned up old code
//
// Revision 2.34  2006/01/14 22:25:08  mey
// UPdate
//
// Revision 2.33  2006/01/12 23:44:47  mey
// Update
//
// Revision 2.32  2006/01/12 22:36:09  mey
// UPdate
//
// Revision 2.31  2006/01/12 12:28:29  mey
// UPdate
//
// Revision 2.30  2006/01/12 12:14:53  mey
// Update
//
// Revision 2.29  2006/01/12 11:48:12  mey
// Update
//
// Revision 2.28  2006/01/12 11:32:30  mey
// Update
//
// Revision 2.27  2006/01/11 16:58:17  mey
// Update
//
// Revision 2.26  2006/01/11 13:47:51  mey
// Update
//
// Revision 2.25  2006/01/09 07:17:37  mey
// Update
//
// Revision 2.24  2005/12/15 14:25:09  mey
// Update
//
// Revision 2.23  2005/12/05 18:11:17  mey
// UPdate
//
// Revision 2.22  2005/11/30 16:26:07  mey
// Redirect output
//
// Revision 2.21  2005/11/25 14:45:07  mey
// UPdate
//
// Revision 2.20  2005/11/21 18:08:38  mey
// UPdate
//
// Revision 2.19  2005/11/21 17:38:34  mey
// Update
//
// Revision 2.18  2005/11/07 10:12:05  mey
// Byte swap
//
// Revision 2.17  2005/10/06 14:48:32  mey
// Added tmb trigger test
//
// Revision 2.16  2005/10/05 14:24:19  mey
// Added tests
//
// Revision 2.15  2005/10/04 16:01:17  mey
// Update
//
// Revision 2.14  2005/09/28 16:52:40  mey
// Include Output streamer
//
// Revision 2.13  2005/09/15 08:13:48  mey
// CSC id update
//
// Revision 2.12  2005/09/06 12:11:32  mey
// Added accessors
//
// Revision 2.11  2005/08/31 15:12:58  mey
// Bug fixes, updates and new routine for timing in DMB
//
// Revision 2.10  2005/08/23 15:49:54  mey
// Update MPC injector for random LCT patterns
//
// Revision 2.9  2005/08/22 16:58:32  mey
// Fixed bug in TMB-MPC injector
//
// Revision 2.8  2005/08/22 16:38:27  mey
// Added TMB-MPC injector
//
// Revision 2.7  2005/08/22 07:55:45  mey
// New TMB MPC injector routines and improved ALCTTiming
//
// Revision 2.6  2005/08/17 12:27:22  mey
// Updated FindWinner routine. Using FIFOs now
//
// Revision 2.5  2005/08/15 15:37:57  mey
// Include alct_hotchannel_file
//
// Revision 2.4  2005/08/12 14:16:03  mey
// Added pulsing vor TMB-MPC delay
//
// Revision 2.2  2005/07/08 10:33:32  geurts
// allow arbitrary scope trigger channel in TMB::scope()
//
// Revision 2.1  2005/06/06 15:17:18  geurts
// TMB/ALCT timing updates (Martin vd Mey)
//
// Revision 2.0  2005/04/12 08:07:05  geurts
// *** empty log message ***
//
//-----------------------------------------------------------------------
#include <unistd.h>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <sstream>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "emu/pc/ALCTController.h"
#include "emu/pc/Chamber.h"
#include "emu/pc/JTAG_constants.h"
#include "emu/pc/RAT.h"
#include "emu/pc/TMB_constants.h"
#include "emu/pc/TMB.h"
#include "emu/pc/VMEController.h"

//------------------------------------------------------------------------------
//  Trigger Test Includes
//------------------------------------------------------------------------------
#include "emu/pc/service.h"
#include "emu/pc/trigger_test.h"
//------------------------------------------------------------------------------

// the VME addresses here are defined in
// http://www-collider.physics.ucla.edu/cms/trigger/tmb2001/tmb2001_spec.pdf

namespace emu {
    namespace pc {
        TMB::TMB(Crate * theCrate, Chamber * theChamber, int slot) :
            VMEModule(theCrate, slot),
            EMUjtag(this),
            EmuLogger(),
            alctController_(0),
            rat_(0),
            csc_(theChamber)
        {
            hardware_version_=0;
            //
            debug_ = false;
            //
            ucla_ldev = 1;
            //
            theChamber->SetTMB(this);
            //
#ifdef debugV
            std::cout << "Inside TMB" << std::endl;
#endif
            //
            (*MyOutput_) << "TMB: crate=" << this->crate() << " slot=" << this->slot() << std::endl;
            //
            //
            SetTMBRegisterDefaults();
            DefineTMBConfigurationRegisters_();
            //
            alct_sent_to_tmb_counter_index_                      = ALCT_SENT_TO_TMB_COUNTER_INDEX                     ;
            ecc_trigger_path_one_error_counter_index_            = ECC_TRIGGER_PATH_ONE_ERROR_COUNTER_INDEX           ;
            ecc_trigger_path_two_errors_counter_index_           = ECC_TRIGGER_PATH_TWO_ERRORS_COUNTER_INDEX          ;
            ecc_trigger_path_more_than_two_errors_counter_index_ = ECC_TRIGGER_PATH_MORE_THAN_TWO_ERRORS_COUNTER_INDEX;
            alct_raw_hits_readout_counter_index_                 = ALCT_RAW_HITS_READOUT_COUNTER_INDEX                ;
            clct_pretrigger_counter_index_                       = CLCT_PRETRIGGER_COUNTER_INDEX                      ;
            lct_sent_to_mpc_counter_index_                       = LCT_SENT_TO_MPC_COUNTER_INDEX                      ; 
            lct_accepted_by_mpc_counter_index_                   = LCT_ACCEPTED_BY_MPC_COUNTER_INDEX                  ;
            l1a_in_tmb_window_counter_index_                     = L1A_IN_TMB_WINDOW_COUNTER_INDEX                    ; 
            //
            //
            tmb_configuration_status_  = -1;
            vme_state_machine_status_  = -1;
            jtag_state_machine_status_ = -1;
            ddd_state_machine_status_  = -1;
            raw_hits_header_status_    = -1;
        } 


        TMB::~TMB() {
            (*MyOutput_) << "destructing ALCTController" << std::endl; 
            delete alctController_; 
            delete rat_;
            (*MyOutput_) << "destructing TMB" << std::endl;
        }
        //
        Crate * TMB::getCrate() {
            //
            return theCrate_;
        }
        //
        Chamber * TMB::getChamber() {
            //
            return csc_;
        }
        //
        int TMB::MPC0Accept(){
            //
            tmb_vme(VME_READ,tmb_trig_adr,sndbuf,rcvbuf,NOW);
            //
            return (rcvbuf[0]&0x2)>>1; 
            //
        }
        //
        int TMB::MPC1Accept(){
            //
            tmb_vme(VME_READ,tmb_trig_adr,sndbuf,rcvbuf,NOW);
            //
            return (rcvbuf[0]&0x4)>>2; 
            //
        }
        //
        void TMB::DumpRegister(int reg){
            //
            int value = ReadRegister(reg);
            //
            (*MyOutput_) << " TMB.reg=" 
                << std::hex << reg << " " 
                << (rcvbuf[0]&0xff) << " " 
                << (rcvbuf[1]&0xff) << " " 
                << (value&0xffff) << std::endl ;
            //
        }
        //
        int TMB::ReadRegister(int reg){
            //
            //  tmb_vme(VME_READ,reg,sndbuf,rcvbuf,NOW);
            //  int value = ((rcvbuf[0]&0xff)<<8)|(rcvbuf[1]&0xff);
            //
            unsigned value_to_write = (sndbuf[1]&0xff) | (sndbuf[0]&0xff)<<8;
            tmb_vme_new(VME_READ,reg,value_to_write,rcvbuf,NOW);
            //
            int value = ((rcvbuf[1]&0xff)<<8)|(rcvbuf[0]&0xff);
            //
            DecodeTMBRegister_(reg,value);
            //
            return value;
            //
        }
        //
        void TMB::ReadTmbIdCodes() {
            //Get ID codes for the following devices:
            //tmb_idcode_[0] = TMB Mezz FPGA IDCode
            //           [1] = TMB Mezz PROM 0 IDCode
            //           [2] = TMB Mezz PROM 1 IDCode
            //           [3] = TMB Mezz PROM 2 IDCode
            //           [4] = TMB Mezz PROM 3 IDCode
            //           [5] = TMB User PROM 0 IDCode
            //           [6] = TMB User PROM 1 IDCode
            //
            int device;
            for (device=0; device<7; device++) 
                tmb_idcode_[device] = 0;
            //
            device = 0;
            //
            setup_jtag(ChainTmbMezz);
            //
            int chip_location;
            if(hardware_version_<=1)
            {
                ShfIR_ShfDR(ChipLocationTmbMezzFpga,
                        FPGAidCode,
                        RegSizeTmbMezzFpga_FPGAidCode);
                tmb_idcode_[device++] = bits_to_int(GetDRtdo(),GetRegLength(),0);
                //
                for (chip_location=1; chip_location<=4; chip_location++){
                    ShfIR_ShfDR(chip_location,
                            PROMidCode,
                            RegSizeTmbMezzProm_PROMidCode);
                    //
                    tmb_idcode_[device++] = bits_to_int(GetDRtdo(),GetRegLength(),0);
                }
            }
            else if(hardware_version_==2)
            {
                unsigned short comd=VTX6_IDCODE;
                unsigned temp=0, data=0;
                scan(0, (char *)&comd, 10, rcvbuf, 0);
                scan(1, (char *)&temp, 32, (char *)&data, 1);
                tmb_idcode_[device]=data;
                device += 5;
            }
            //
            short unsigned int BootReg;
            tmb_get_boot_reg(&BootReg);
            BootReg &= 0xff7f;                    // Give JTAG chain to the FPGA to configure ALCT on hard reset
            BootReg &= 0xf7ff;                    // Allow FPGA access to the VME register
            tmb_set_boot_reg(BootReg);
            //
            //
            setup_jtag(ChainTmbUser);
            //
            for (chip_location=0; chip_location<=1; chip_location++){
                ShfIR_ShfDR(chip_location,
                        PROMidCode,
                        RegSizeTmbUserProm_PROMidCode);
                tmb_idcode_[device++] = bits_to_int(GetDRtdo(),GetRegLength(),0);
            }
            //
            return;
        }
        //
        int TMB::ConvertToHexAscii(int value_to_convert) { 
            //
            // convert the argument to its "hex-ascii" value:  i.e.  2007 -> 0x2007
            //
            //  std::cout << "value_to_convert = " << std::dec << value_to_convert << std::endl;
            //
            int hex_ascii_value = 0;
            int reduced_value = value_to_convert;
            int number_of_bits_to_shift = 0;
            //
            while (reduced_value) {
                //    std::cout << "reduced_value = " << std::dec << reduced_value << std::endl;
                // here is the 1's digit:
                int ones_digit = reduced_value % 10;
                //
                //    std::cout << "ones_digit = " << std::dec << ones_digit << std::endl;
                //
                // insert ones_digit into the next most significant hex digit:
                hex_ascii_value |= (ones_digit & 0xf) << number_of_bits_to_shift;
                //    std::cout << "hex_ascii_value = " << std::hex << hex_ascii_value << std::endl;
                number_of_bits_to_shift += 4;
                //
                // remove the ones digit:
                reduced_value /= 10;
            }
            //
            //  std::cout << "hex_ascii_value to return = " << std::hex << hex_ascii_value << std::endl;
            //
            return hex_ascii_value;
        }
        //
        int TMB::FirmwareDate(){
            //
            int data = ReadRegister(vme_idreg1_adr);
            //
            read_tmb_firmware_day_   = data & 0xff;
            read_tmb_firmware_month_ = ((data >> 8) & 0xff);
            //
            // convert to real decimal
            read_tmb_firmware_day_ = (read_tmb_firmware_day_ >> 4)*10 + (read_tmb_firmware_day_ & 0xF);
            read_tmb_firmware_month_ = (read_tmb_firmware_month_ >> 4)*10 + (read_tmb_firmware_month_ & 0xF);
            //
            return data;
            //
        }

        int TMB::FirmwareYear(){
            //
            tmb_vme(VME_READ,vme_idreg2_adr,sndbuf,rcvbuf,NOW);
            //
            int data = (((rcvbuf[0]&0xff)<<8) | (rcvbuf[1]&0xff)) ;
            //
            // convert to real decimal
            data = ((data >> 12)&0xF)*1000 + ((data >> 8)&0xF)*1000+ ((data >> 4)&0xF)*10 +(data&0xF);
            read_tmb_firmware_year_ = data;
            //
            return data;
            //
        }
        bool TMB::CheckFirmwareDate() {
            //
            // read the registers:
            FirmwareDate();
            FirmwareYear();
            ReadRegister(non_trig_readout_adr);
            //
            //
            bool date_ok = true;
            //
            // check the values
            date_ok &= ( GetReadTmbFirmwareDay()   == GetExpectedTmbFirmwareDay()   );
            date_ok &= ( GetReadTmbFirmwareMonth() == GetExpectedTmbFirmwareMonth() );
            date_ok &= ( GetReadTmbFirmwareYear()  == GetExpectedTmbFirmwareYear()  );
            date_ok &= ( read_tmb_firmware_compile_type_ == expected_tmb_firmware_compile_type_ );
            //
            return date_ok;
        }
        //
        int TMB::FirmwareVersion(){
            //
            tmb_vme(VME_READ,vme_idreg0_adr,sndbuf,rcvbuf,NOW);
            //
            int data = (((rcvbuf[0]&0xff)<<8) | (rcvbuf[1]&0xff)) ;
            //
            read_tmb_firmware_type_    = data & 0xf;
            read_tmb_firmware_version_ = (data >> 4) & 0xf;
            //
            return data;
            //
        }

        int TMB::FirmwareRevCode(){
            //
            tmb_vme(VME_READ,vme_idreg3_adr,sndbuf,rcvbuf,NOW);
            //
            int data = (((rcvbuf[0]&0xff)<<8) | (rcvbuf[1]&0xff)) ;
            //
            read_tmb_firmware_revcode_ = (data>>12) & 0x000f ;
            //
            return data;
            //
        }
        //
        int TMB::PowerComparator(){
            //
            tmb_vme(VME_READ,vme_adc_adr,sndbuf,rcvbuf,NOW);
            //
            return (((rcvbuf[0]&0xff)<<8) | (rcvbuf[1]&0xff)) ;
            //
        }
        //
        int TMB::CCB_command_from_TTC(){
            //
            sndbuf[0] = 0x0;
            sndbuf[1] = 0x0;
            tmb_vme(VME_READ,ccb_stat_adr,sndbuf,rcvbuf,NOW);
            //
            return (rcvbuf[1]&0xff);
            //
        }
        //
        void TMB::WriteOutput(std::string output){
            //
            (*MyOutput_) << output << std::endl ;
            //
            //LOG4CPLUS_INFO(getApplicationLogger(), output);
            //
        }
        //
        void TMB::StartTTC(){
            //
            WriteOutput("TMB:  StartTriggers");
            //
            sndbuf[0] = 0x0;
            sndbuf[1] = 0x1;      // Disconnect CCB backplane
            tmb_vme(VME_WRITE,ccb_cmd_adr,sndbuf,rcvbuf,NOW);
            //
            sndbuf[0] = 0x6;      // TTC command to generate (Trig Start--needed if ignore_ccb_startstop=0 or
            //                       for old versions of TMB firmware)
            sndbuf[1] = 0x3;      // Disconnect CCB backplane + Assert internal CCB command Broadcast strobe
            tmb_vme(VME_WRITE,ccb_cmd_adr,sndbuf,rcvbuf,NOW);
            //
            sndbuf[0] = 0x0;
            sndbuf[1] = 0x1;      // Disconnect CCB backplane + Un-assert internal CCB cmd broadcast strobe
            tmb_vme(VME_WRITE,ccb_cmd_adr,sndbuf,rcvbuf,NOW);
            //
            tmb_vme(VME_READ,ccb_cmd_adr,sndbuf,rcvbuf,NOW);
            //
            sndbuf[0] = 0x3;      // TTC command to generate (Resync)
            sndbuf[1] = 0x3;      // Disconnect CCB backplane + Assert internal CCB command Broadcast strobe
            tmb_vme(VME_WRITE,ccb_cmd_adr,sndbuf,rcvbuf,NOW);
            //
            sndbuf[0] = 0x0;
            sndbuf[1] = 0x1;      // Disconnect CCB backplane + Un-assert internal CCB cmd broadcast strobe
            tmb_vme(VME_WRITE,ccb_cmd_adr,sndbuf,rcvbuf,NOW);
            //
            tmb_vme(VME_READ,ccb_cmd_adr,sndbuf,rcvbuf,NOW);
            //
            sndbuf[0] = 0x1;      // TTC command to generate (BC0)
            sndbuf[1] = 0x3;      // Disconnect CCB backplane + Assert internal CCB command Broadcast strobe
            tmb_vme(VME_WRITE,ccb_cmd_adr,sndbuf,rcvbuf,NOW);
            //
            sndbuf[0] = 0x0;
            sndbuf[1] = 0x1;      // Disconnect CCB backplane + Un-assert internal CCB command Broadcast strobe
            tmb_vme(VME_WRITE,ccb_cmd_adr,sndbuf,rcvbuf,NOW);
            //
            sndbuf[0] = 0x0;
            sndbuf[1] = 0x0;      // Connect CCB backplane
            tmb_vme(VME_WRITE,ccb_cmd_adr,sndbuf,rcvbuf,NOW);
            //
            tmb_vme(VME_READ,ccb_cmd_adr,sndbuf,rcvbuf,NOW);
            //
        }
        //
        void TMB::WriteRegister(int reg, int value){
            //
            sndbuf[0] = (value>>8)&0xff;
            sndbuf[1] = value&0xff;
            //
            //  std::cout << "write register " << std::hex << reg << " with " << value << "... " << std::endl;
            //  tmb_vme(VME_WRITE,reg,sndbuf,rcvbuf,NOW);
            tmb_vme_new(VME_WRITE,reg,value,rcvbuf,NOW);
            //
        }
        //
        void TMB::WriteRegister(int address) {
            //
            int data_to_write = FillTMBRegister(address);
            //
            if (data_to_write < 0x10000) {
                //
                WriteRegister(address,data_to_write);
                //
            } else {
                //
                (*MyOutput_) << "TMB: ERROR in WriteRegister, data word too big to write" << std::endl;
            }
            return;
        }

        
        bool TMB::SelfTest() {
            //
            return 0;
        }
        //
        void TMB::init() {
            //
            return;
        }
        //
        void TMB::configure() {
            //
            this->configure(0); //no argument means write configuration to user PROM
            //
            return;
        }
        //
        void TMB::configure(int c) {
            //
            // c = 2 = do not write configuration to userPROM
            //
            if (c == 2) { 
                SetTMBFillVmeWriteVecs(false);     //do not write configuration to user PROM
            } else {
                SetTMBFillVmeWriteVecs(true);     //write configuration to user PROM
            }
            //
            ClearTMBVmeWriteVecs();
            //
            std::ostringstream dump;
            std::ostringstream dump2;
            //
            dump  << "TMB : configuring in slot = ";
            dump2 << theSlot;
            (*MyOutput_) << dump.str()+dump2.str() << std::endl;
            SendOutput(dump.str()+dump2.str(),"INFO");
            //
            for (unsigned int index=0; index<TMBConfigurationRegister.size(); index++) {
                //
                unsigned long int address = TMBConfigurationRegister.at(index);
                //
                WriteRegister(address);
                //
            }
            //
            // When configuring with VME, the 3d3444 state machine needs to be 
            // started and stopped appropriately in order for the delay values 
            // to be set correctly:
            if ( !GetTMBFillVmeWriteVecs() ) {
                WriteRegister(vme_dddsm_adr,0x20);
                WriteRegister(vme_dddsm_adr,0x21);
                WriteRegister(vme_dddsm_adr,0x20);
            }
            //
            // The flag to fill the VME register vector is set => program the user PROM:
            if ( GetTMBFillVmeWriteVecs() )      
                CheckAndProgramProm(ChipLocationTmbUserPromTMB);
            //
            SetTMBFillVmeWriteVecs(false);    //give VME back to the user (default)
            //
            if (this->slot()<22)           //broadcast read will not work, so only check configuration if it is a normal VME slot
                CheckTMBConfiguration();  
            //
        }
        //
        void TMB::SetTrgmode_() {  
            //
            // To be deprecated.  Replaced by explicitly setting each pretrigger/trigger bit
            //
            // set the combinations of bits for 
            // register 0x68 = ADR_SEQ_TRIG_EN  and
            // register 0x86 = ADR_TMB_TRIG    
            // according to the setting of trgmode_
            //
            // clear the settings on the pattern trigger enable (0x68):
            clct_pat_trig_en_  = 0;
            alct_pat_trig_en_  = 0;
            match_pat_trig_en_ = 0;
            adb_ext_trig_en_   = 0;
            dmb_ext_trig_en_   = 0;
            clct_ext_trig_en_  = 0;
            alct_ext_trig_en_  = 0;
            vme_ext_trig_   = 0;
            //
            // clear the settings on 0x86:
            tmb_allow_clct_    = 0;
            tmb_allow_alct_    = 0;
            tmb_allow_match_   = 1;  //always set the TMB to allow matched 
            //
            if ( trgmode_ == CLCT_trigger ) { 
                //
                clct_pat_trig_en_ = 1;
                tmb_allow_clct_ = 1;
                //
            } else if ( trgmode_ == ALCT_trigger ) { 
                //
                alct_pat_trig_en_ = 1;
                tmb_allow_alct_ = 1;
                //
            } else if ( trgmode_ == Scintillator_trigger ) { 
                //
                clct_ext_trig_en_ = 1;
                //
            } else if ( trgmode_ == DMB_trigger ) { 
                //
                dmb_ext_trig_en_ = 1;
                //
            } else if ( trgmode_ == ALCT_CLCT_coincidence_trigger ) { 
                //
                match_pat_trig_en_ = 1;
                //
            } 
            //
            return;
        }
        void TMB::clear_i2c() {
            //
            (*MyOutput_) << "Done so unstart state machine" << std::endl ;
            sndbuf[0]=0x8c;
            sndbuf[1]=0x33;
            tmb_vme(VME_WRITE,0x14,sndbuf,rcvbuf,NOW);
            //
        }
        //
        void TMB::InjectMPCData(const int nEvents, const unsigned long lct0, const unsigned long lct1){
            //
            unsigned short frame1, frame2, ramAdd;
            //
            (*MyOutput_) << "TMB:  Inject " << nEvents << " events with 2 muons into MPC data to slot " << this->slot() << std::endl ;
            //
            for (int evtId(0); evtId<nEvents; ++evtId) {
                //
                ramAdd = (evtId<<8);
                //
                unsigned short vpf      = 1;         
                unsigned short sync_err = 0;
                unsigned short qual1    = 0;
                unsigned short qual2;
                unsigned short BC0 = 0;  //this value should be equal for the same event in all slots...
                ReadRegister(seq_id_adr);
                unsigned short csc_id  = (unsigned short) GetCscId();
                //
                if ( lct0 == 0 ) {  // random LCT
                    //
                    qual1 = 0;
                    while (qual1 < 1)                // ensure that one random muon has quality > 0
                        qual1= rand()%16;              
                    unsigned short clct   = rand()%16; 
                    unsigned short wire   = rand()%128;
                    unsigned short bxn0   = rand()%2;
                    unsigned short lr     = rand()%2;
                    unsigned short halfSt = rand()%256;
                    //
                    frame1 = 
                        ((vpf   &  0x1) << 15) + 
                        ((qual1 &  0xf) << 11) + 
                        ((clct  &  0xf) <<  7) + 
                        ((wire  & 0x7f) <<  0) ;
                    //
                    frame2 = 
                        ((csc_id   &  0xf) << 12) +
                        ((BC0      &  0x1) << 11) +
                        ((bxn0     &  0x1) << 10) +
                        ((sync_err &  0x1) <<  9) +
                        ((lr       &  0x1) <<  8) + 
                        ((halfSt   & 0xff) <<  0);    
                    //
                } else {
                    // insert the csc_id specific for this TMB (otherwise the user has to specify...)
                    frame2 = ( ((lct0>> 0) & 0x0fff) | (csc_id & 0xf) << 12 ) ;
                    frame1 = (lct0>>16) & 0xffff;
                }
                //
                lct0_ = ((frame1&0xffff)<<16) | (frame2&0xffff) ;
                //
                InjectedLct0.push_back(lct0_);
                //
                if (debug_) printf("TMB lct0 = %x %x %x\n",frame1,frame2,(unsigned int)lct0_);
                //
                sndbuf[0] = (frame1>>8)&0xff ;
                sndbuf[1] = (frame1)&0xff ;
                tmb_vme(VME_WRITE,mpc_ram_wdata_adr,sndbuf,rcvbuf,NOW);
                //
                sndbuf[0] = (ramAdd>>8)&0xff ;
                sndbuf[1] = (ramAdd)&0xff ;
                tmb_vme(VME_WRITE,mpc_ram_adr,sndbuf,rcvbuf,NOW);
                //
                sndbuf[0] = ((ramAdd+1)>>8)&0xff ; // Assert write enable
                sndbuf[1] = ((ramAdd+1))&0xff ;
                tmb_vme(VME_WRITE,mpc_ram_adr,sndbuf,rcvbuf,NOW );
                //
                sndbuf[0] = (ramAdd>>8)&0xff ;
                sndbuf[1] = (ramAdd)&0xff ;
                tmb_vme(VME_WRITE,mpc_ram_adr,sndbuf,rcvbuf,NOW);
                //
                sndbuf[0] = (frame2>>8)&0xff ;
                sndbuf[1] = (frame2)&0xff ;
                tmb_vme(VME_WRITE,mpc_ram_wdata_adr,sndbuf,rcvbuf,NOW);
                //
                sndbuf[0] = (ramAdd>>8)&0xff ;
                sndbuf[1] = (ramAdd)&0xff ;
                tmb_vme(VME_WRITE,mpc_ram_adr,sndbuf,rcvbuf,NOW);
                //
                sndbuf[0] = ((ramAdd+2)>>8)&0xff ;  // Assert write enable
                sndbuf[1] = (ramAdd+2)&0xff ;
                tmb_vme(VME_WRITE,mpc_ram_adr,sndbuf,rcvbuf,NOW );
                //
                sndbuf[0] = ((ramAdd)>>8)&0xff ;
                sndbuf[1] = (ramAdd)&0xff ;
                tmb_vme(VME_WRITE,mpc_ram_adr,sndbuf,rcvbuf,NOW);
                //
                if ( lct1 == 0 ) {    //random LCT
                    //
                    qual2 = 15;
                    while (qual2 >= qual1)           // ensure that quality for LCT1 is always less than quality for LCT0
                        qual2 = rand()%16;            
                    unsigned short clct   = rand()%16; 
                    unsigned short wire   = rand()%128;
                    unsigned short bxn0   = rand()%2;
                    unsigned short lr     = rand()%2;
                    unsigned short halfSt = rand()%256;
                    //
                    frame1 = 
                        ((vpf   &  0x1) << 15) + 
                        ((qual2 &  0xf) << 11) + 
                        ((clct  &  0xf) <<  7) + 
                        ((wire  & 0x7f) <<  0) ;
                    //
                    frame2 = 
                        ((csc_id   &  0xf) << 12) +
                        ((BC0      &  0x1) << 11) +
                        ((bxn0     &  0x1) << 10) +
                        ((sync_err &  0x1) <<  9) +
                        ((lr       &  0x1) <<  8) + 
                        ((halfSt   & 0xff) <<  0);    
                    //

                } else {
                    // insert the csc_id specific for this TMB (otherwise the user has to specify...)
                    frame2 = ( ((lct1>> 0) & 0x0fff) | (csc_id & 0xf) << 12 ) ;
                    frame1 = (lct1 >> 16) & 0xffff;
                }
                //
                lct1_ = ((frame1&0xffff)<<16) | (frame2&0xffff) ;
                //
                InjectedLct1.push_back(lct1_);
                //
                if (debug_) printf("TMB lct1 = %x %x %x\n",frame1,frame2,(unsigned int)lct1_);
                //
                sndbuf[0] = (frame1>>8)&0xff ;
                sndbuf[1] = (frame1)&0xff ;
                tmb_vme(VME_WRITE,mpc_ram_wdata_adr,sndbuf,rcvbuf,NOW);
                //
                sndbuf[0] = (ramAdd>>8)&0xff ;
                sndbuf[1] = (ramAdd)&0xff ;
                tmb_vme(VME_WRITE,mpc_ram_adr,sndbuf,rcvbuf,NOW);
                //
                sndbuf[0] = ((ramAdd+4)>>8)&0xff ;
                sndbuf[1] = ((ramAdd+4))&0xff ;
                tmb_vme(VME_WRITE,mpc_ram_adr,sndbuf,rcvbuf,NOW );        // Assert write enable
                //
                sndbuf[0] = (ramAdd>>8)&0xff ;
                sndbuf[1] = (ramAdd)&0xff ;
                tmb_vme(VME_WRITE,mpc_ram_adr,sndbuf,rcvbuf,NOW);
                //
                sndbuf[0] = (frame2>>8)&0xff ;
                sndbuf[1] = (frame2)&0xff ;
                tmb_vme(VME_WRITE,mpc_ram_wdata_adr,sndbuf,rcvbuf,NOW);
                //
                sndbuf[0] = (ramAdd>>8)&0xff ;
                sndbuf[1] = (ramAdd)&0xff ;
                tmb_vme(VME_WRITE,mpc_ram_adr,sndbuf,rcvbuf,NOW);
                //
                sndbuf[0] = ((ramAdd+8)>>8)&0xff ;
                sndbuf[1] = (ramAdd+8)&0xff ;
                tmb_vme(VME_WRITE,mpc_ram_adr,sndbuf,rcvbuf,NOW );      // Assert write enable
                //
                sndbuf[0] = ((ramAdd)>>8)&0xff ;
                sndbuf[1] = (ramAdd)&0xff ;
                tmb_vme(VME_WRITE,mpc_ram_adr,sndbuf,rcvbuf,NOW);
                //
            }
            //
            // Read back RAM address
            //
            //  usleep(100);
            //  ReadBackMpcRAM(nEvents);
            usleep(100);
            //
            // Now fire MPC injector
            //
            //FireMPCInjector(nEvents);
            //
        }
        //
        void TMB::ReadBackMpcRAM(int nEvents){
            //
            unsigned short ramAdd;
            //
            (*MyOutput_) << "TMB:  Read MPC injector RAM for " << std::dec << nEvents << " events" << std::endl ;
            //
            for (int evtId(0); evtId<nEvents; ++evtId) {
                //
                (*MyOutput_) << "Event " << std::dec << evtId << "..." << std::endl;
                //
                ramAdd = (evtId<<8);
                //
                sndbuf[0] = ((ramAdd)>>8)&0xff ;
                sndbuf[1] = (ramAdd)&0xff | (0x1<<4) ;
                tmb_vme(VME_WRITE,mpc_ram_adr,sndbuf,rcvbuf,NOW);
                //
                tmb_vme(VME_READ,mpc_ram_rdata_adr,sndbuf,rcvbuf,NOW);
                unsigned long int rlct01 = ((rcvbuf[0]&0xff)<<8) | (rcvbuf[1]&0xff) ;
                //
                sndbuf[0] = ((ramAdd)>>8)&0xff ;
                sndbuf[1] = (ramAdd)&0xff | (0x1<<5) ;
                tmb_vme(VME_WRITE,mpc_ram_adr,sndbuf,rcvbuf,NOW);
                //
                tmb_vme(VME_READ,mpc_ram_rdata_adr,sndbuf,rcvbuf,NOW);
                unsigned long int rlct02 = ((rcvbuf[0]&0xff)<<8) | (rcvbuf[1]&0xff) ;
                //
                unsigned long int rlct0 = ( ((rlct01 & 0xffff) << 16) | ((rlct02 & 0xffff) << 0) );
                (*MyOutput_) << "LCT0 = " << std::hex << rlct0 << std::endl;
                //
                //
                sndbuf[0] = ((ramAdd)>>8)&0xff ;
                sndbuf[1] = (ramAdd)&0xff | (0x1<<6) ;
                tmb_vme(VME_WRITE,mpc_ram_adr,sndbuf,rcvbuf,NOW);
                //
                tmb_vme(VME_READ,mpc_ram_rdata_adr,sndbuf,rcvbuf,NOW);
                unsigned long int rlct11 = ((rcvbuf[0]&0xff)<<8) | (rcvbuf[1]&0xff) ;
                //
                sndbuf[0] = ((ramAdd)>>8)&0xff ;
                sndbuf[1] = (ramAdd)&0xff | (0x1<<7) ;
                tmb_vme(VME_WRITE,mpc_ram_adr,sndbuf,rcvbuf,NOW);
                //
                tmb_vme(VME_READ,mpc_ram_rdata_adr,sndbuf,rcvbuf,NOW);
                unsigned long int rlct12 = ((rcvbuf[0]&0xff)<<8) | ((rcvbuf[1]&0xff)) ;
                //
                unsigned long int rlct1 = ( ((rlct11 & 0xffff) << 16) | ((rlct12 & 0xffff) << 0) );
                (*MyOutput_) << "LCT1 = " << std::hex << rlct1 << std::endl;
                //
            }
            //
        }
        //
        void TMB::FireMPCInjector(int nEvents){
            //
            tmb_vme(VME_READ,mpc_inj_adr,sndbuf,rcvbuf,NOW);
            //
            (*MyOutput_) << "TMB: Fire MPC injector" << std::endl;
            //
            sndbuf[0] = rcvbuf[0] & 0xfe ; // Unfire injector
            sndbuf[1] = nEvents & 0xff;
            tmb_vme(VME_WRITE,mpc_inj_adr,sndbuf,rcvbuf,NOW);
            //
            sndbuf[0] = rcvbuf[0] & 0xfe | 0x1 ; // Fire injector
            sndbuf[1] = nEvents & 0xff;
            tmb_vme(VME_WRITE,mpc_inj_adr,sndbuf,rcvbuf,NOW);
            //
            sndbuf[0] = rcvbuf[0] & 0xfe ; // UnFire injector
            sndbuf[1] = nEvents & 0xff;
            tmb_vme(VME_WRITE,mpc_inj_adr,sndbuf,rcvbuf,NOW);
            //
            return;
        }
        //
        void TMB::DataSendMPC(){
            //
            (*MyOutput_) << "TMB: data sent to MPC..." << std::endl;
            //
            int mpc0frame0 = ReadRegister(mpc0_frame0_adr);
            (*MyOutput_) << "LCT0 FRAME0 " << std::hex << mpc0frame0 << std::endl ; 
            //
            int mpc0frame1 = ReadRegister(mpc0_frame1_adr);
            (*MyOutput_) << "LCT0 FRAME1 " << std::hex << mpc0frame1 << std::endl ; 
            //
            int mpc1frame0 = ReadRegister(mpc1_frame0_adr);
            (*MyOutput_) << "LCT1 FRAME0 " << std::hex << mpc1frame0 << std::endl ; 
            //
            int mpc1frame1 = ReadRegister(mpc1_frame1_adr);
            (*MyOutput_) << "LCT1 FRAME1 " << std::hex << mpc1frame1 << std::endl ; 
            //
            return;
        }
        //
        void TMB::DecodeALCT(){
            //
            ALCT0_data_ = ReadRegister(alct_alct0_adr);
            ALCT1_data_ = ReadRegister(alct_alct1_adr);
            //
            //  PrintALCT();
            //
            return;
        }
        //
        void TMB::PrintALCT() {
            //
            (*MyOutput_) << "----------------------"                              << std::endl;
            (*MyOutput_) << " ALCT0.data  = 0x"     << std::hex << ALCT0_data_    << std::endl;
            (*MyOutput_) << "----------------------"                              << std::endl;
            (*MyOutput_) << " ALCT0.valid     = 0x" << std::hex << GetAlct0Valid()   << std::endl;
            (*MyOutput_) << " ALCT0.quality   = "   << std::dec << GetAlct0Quality() << std::endl;
            (*MyOutput_) << " ALCT0.amu       = 0x" << std::hex << GetAlct0Amu()     << std::endl;
            (*MyOutput_) << " ALCT0.key WG    = "   << std::dec << GetAlct0KeyWg()   << std::endl;
            (*MyOutput_) << " ALCT0.bxn       = 0x" << std::hex << GetAlct0Bxn()     << std::endl;
            //
            (*MyOutput_) << std::endl;
            //
            (*MyOutput_) << "----------------------"                              << std::endl;
            (*MyOutput_) << " ALCT1.data  = 0x"     << std::hex << ALCT1_data_    << std::endl;
            (*MyOutput_) << "----------------------"                              << std::endl;
            (*MyOutput_) << " ALCT1.valid     = 0x" << std::hex << GetAlct1Valid()   << std::endl;
            (*MyOutput_) << " ALCT1.quality   = "   << std::dec << GetAlct1Quality() << std::endl;
            (*MyOutput_) << " ALCT1.amu       = 0x" << std::hex << GetAlct1Amu()     << std::endl;
            (*MyOutput_) << " ALCT1.key WG    = "   << std::dec << GetAlct1KeyWg()   << std::endl;
            (*MyOutput_) << " ALCT1.bxn       = 0x" << std::hex << GetAlct1Bxn()     << std::endl;
            //
            return;
        }
        //
        void TMB::DecodeCLCT(){
            //
            int clct0_lsbs = ReadRegister(seq_clct0_adr);
            int clct1_lsbs = ReadRegister(seq_clct1_adr);
            int clct_msbs  = ReadRegister(seq_clctm_adr);
            //
            CLCT0_data_ = ( (clct_msbs & 0xf) << 16 ) | (clct0_lsbs & 0xffff);
            CLCT1_data_ = ( (clct_msbs & 0xf) << 16 ) | (clct1_lsbs & 0xffff);
            //
            //   PrintCLCT();
            //
            return;
        }
        //
        void TMB::PrintCLCT() {
            //
            std::cout << "CLCT0 data = 0x"       << std::hex << CLCT0_data_          << std::endl;
            std::cout << "CLCT1 data = 0x"       << std::hex << CLCT1_data_          << std::endl;
            //
            (*MyOutput_) << "----------------------"                                   << std::endl;
            (*MyOutput_) << "CLCT0 data = 0x"       << std::hex << CLCT0_data_         << std::endl;
            (*MyOutput_) << "----------------------"                                   << std::endl;
            (*MyOutput_) << "CLCT0.Valid      = 0x" << std::hex << read_CLCT0_valid_        << std::endl;
            (*MyOutput_) << "CLCT0.Nhits      = 0x" << std::hex << read_CLCT0_nhit_         << std::endl;
            (*MyOutput_) << "CLCT0.pattern    = 0x" << std::hex << read_CLCT0_pattern_      << std::endl;
            (*MyOutput_) << "CLCT0.Key HStrip = "   << std::dec << read_CLCT0_keyHalfStrip_ << std::endl;
            (*MyOutput_) << "CLCT0.BXN        = 0x" << std::hex << read_CLCT_BXN_           << std::endl;
            (*MyOutput_) << "CLCT0.sync err   = 0x" << std::hex << read_CLCT_sync_err_      << std::endl;
            //
            (*MyOutput_) << std::endl;
            //
            (*MyOutput_) << "----------------------"                                   << std::endl;
            (*MyOutput_) << "CLCT1 data = 0x"       << std::hex << CLCT1_data_         << std::endl;
            (*MyOutput_) << "----------------------"                                   << std::endl;
            (*MyOutput_) << "CLCT1.Valid      = 0x" << std::hex << read_CLCT1_valid_        << std::endl;
            (*MyOutput_) << "CLCT1.Nhits      = 0x" << std::hex << read_CLCT1_nhit_         << std::endl;
            (*MyOutput_) << "CLCT1.pattern    = 0x" << std::hex << read_CLCT1_pattern_      << std::endl;
            (*MyOutput_) << "CLCT1.Key HStrip = "   << std::dec << read_CLCT1_keyHalfStrip_ << std::endl;
            (*MyOutput_) << "CLCT1.BXN        = 0x" << std::hex << read_CLCT_BXN_           << std::endl;
            (*MyOutput_) << "CLCT1.sync err   = 0x" << std::hex << read_CLCT_sync_err_      << std::endl;
            //
            return;
        }
        //
        int TMB::FmState(){
            //
            tmb_vme(VME_READ,ccb_cmd_adr,sndbuf,rcvbuf,NOW);
            //
            int fm_state = (rcvbuf[1]&0xf0)>>4;
            //
            return fm_state;
            //
        }
        //
        void TMB::PrintCounters(int counter){
            //
            // if (counter < 0) { print all counters }
            //
            if (counter<0)                  (*MyOutput_) << "--------------------------------------------------------" << std::endl;
            if (counter<0)                  (*MyOutput_) << "---              Counters                             --" << std::endl;
            if (counter<0)                  (*MyOutput_) << "--------------------------------------------------------" << std::endl;
            if (counter<0) {
                for (int i=0; i < GetMaxCounter(); i++) 
                    (*MyOutput_) << std::dec << std::setw(4) << i << CounterName(i)  << FinalCounter[i] <<std::endl ;
            } else {
                (*MyOutput_) << std::dec << counter << CounterName(counter) << FinalCounter[counter] <<std::endl ;
            }
            //
        }
        //
        std::string TMB::CounterName(int counter){
            //
            // Note to TMB software developer:  When modifying the counters, do not forget to modify the 
            // index tags in TMB_constants.h...
            //
            int adjustcounter = 0;
            std::string name = "Not defined";
            //
            if( counter == 0 ) name = "ALCT: alct0 valid pattern flag received                 ";
            if( counter == 1 ) name = "ALCT: alct1 valid pattern flag received                 ";
            if( counter == 2 ) name = "ALCT: alct data structure error                         ";
            if( counter == 3 ) name = "ALCT: trigger path ECC; 1 bit error corrected           ";
            if( counter == 4 ) name = "ALCT: trigger path ECC; 2 bit error uncorrected         ";
            if( counter == 5 ) name = "ALCT: trigger path ECC; > 2 bit error uncorrected       ";
            if( counter == 6 ) name = "ALCT: trigger path ECC; > 2 bit error blanked           ";
            //
            if( counter == 7 ) name = "ALCT: alct replied ECC; 1 bit error corrected           ";
            if( counter == 8 ) name = "ALCT: alct replied ECC; 2 bit error uncorrected         ";
            if( counter == 9 ) name = "ALCT: alct replied ECC; > 2 bit error uncorrected       ";
            if( counter == 10) name = "ALCT: raw hits readout                                  ";
            if( counter == 11) name = "ALCT: raw hits readout - CRC error                      ";
            if( counter == 12) name = "                                                        ";
            //
            if( counter == 13) name = "CLCT: Pretrigger                                        ";
            if( counter == 14) name = "CLCT: Pretrigger on CFEB0                               ";
            if( counter == 15) name = "CLCT: Pretrigger on CFEB1                               ";
            if( counter == 16) name = "CLCT: Pretrigger on CFEB2                               ";
            if( counter == 17) name = "CLCT: Pretrigger on CFEB3                               ";
            if( counter == 18) name = "CLCT: Pretrigger on CFEB4                               ";
            //firmware check for new oTMB to determine the next counters
            if( GetHardwareVersion() == 2){ 
                adjustcounter  = 2;
                if( counter == 19) name = "CLCT: Pretrigger on CFEB5                               ";
                if( counter == 20) name = "CLCT: Pretrigger on CFEB6                               ";
            } else adjustcounter  = 0; 
            //
            if( counter == 19 + adjustcounter ) name = "CLCT: Pretrigger on ME1A CFEB 4 only                    ";
            if( counter == 20 + adjustcounter ) name = "CLCT: Pretrigger on ME1B CFEBs 0-3 only                 ";
            if( counter == 21 + adjustcounter ) name =  "CLCT: Discarded, no wrbuf available, buffer stalled     ";
            if( counter == 22 + adjustcounter ) name =  "CLCT: Discarded, no ALCT in window                      ";
            if( counter == 23 + adjustcounter ) name =  "CLCT: Discarded, CLCT0 invalid pattern after drift      ";
            if( counter == 24 + adjustcounter ) name =  "CLCT: CLCT0 pass hit thresh, fail pid_thresh_postdrift  ";
            if( counter == 25 + adjustcounter ) name =  "CLCT: CLCT1 pass hit thresh, fail pid_thresh_postdrift  ";
            if( counter == 26 + adjustcounter ) name =  "CLCT: BX pretrig waiting for triads to dissipate        ";
            //
            if( counter == 27 + adjustcounter ) name =  "CLCT: clct0 sent to TMB matching section                ";
            if( counter == 28 + adjustcounter ) name =  "CLCT: clct1 sent to TMB matching section                ";
            //
            if( counter == 29 + adjustcounter ) name =  "TMB:  TMB accepted alct*clct, alct-only, or clct-only   ";
            if( counter == 30 + adjustcounter ) name =  "TMB:  TMB clct*alct matched trigger                     ";
            if( counter == 31 + adjustcounter ) name =  "TMB:  TMB alct-only trigger                             ";
            if( counter == 32 + adjustcounter ) name =  "TMB:  TMB clct-only trigger                             ";
            //
            if( counter == 33 + adjustcounter ) name =  "TMB:  TMB match reject event                            ";
            if( counter == 34 + adjustcounter ) name =  "TMB:  TMB match reject event, queued for nontrig readout";
            if( counter == 35 + adjustcounter ) name =  "TMB:  TMB matching discarded an ALCT pair               ";
            if( counter == 36 + adjustcounter ) name =  "TMB:  TMB matching discarded a CLCT pair                ";
            if( counter == 37 + adjustcounter ) name =  "TMB:  TMB matching discarded CLCT0 from ME1A            ";
            if( counter == 38 + adjustcounter ) name =  "TMB:  TMB matching discarded CLCT1 from ME1A            ";
            //
            if( counter == 39 + adjustcounter ) name =  "TMB:  Matching found no ALCT                            ";
            if( counter == 40 + adjustcounter ) name =  "TMB:  Matching found no CLCT                            ";
            if( counter == 41 + adjustcounter ) name =  "TMB:  Matching found one ALCT                           ";
            if( counter == 42 + adjustcounter ) name =  "TMB:  Matching found one CLCT                           ";
            if( counter == 43 + adjustcounter ) name =  "TMB:  Matching found two ALCTs                          ";
            if( counter == 44 + adjustcounter ) name =  "TMB:  Matching found two CLCTs                          ";
            //
            if( counter == 45 + adjustcounter ) name =  "TMB:  ALCT0 copied into ALCT1 to make 2nd LCT           ";
            if( counter == 46 + adjustcounter ) name =  "TMB:  CLCT0 copied into CLCT1 to make 2nd LCT           ";
            if( counter == 47 + adjustcounter ) name =  "TMB:  LCT1 has higher quality than LCT0 (ranking error) ";
            //
            if( counter == 48 + adjustcounter ) name =  "TMB:  Transmitted LCT0 to MPC                           ";
            if( counter == 49 + adjustcounter ) name =  "TMB:  Transmitted LCT1 to MPC                           ";
            //
            if( counter == 50 + adjustcounter ) name =  "TMB:  MPC accepted LCT0                                 ";
            if( counter == 51 + adjustcounter ) name =  "TMB:  MPC accepted LCT1                                 ";
            if( counter == 52 + adjustcounter ) name =  "TMB:  MPC rejected both LCT0 and LCT1                   ";
            //
            if( counter == 53 + adjustcounter ) name =  "L1A:  L1A received                                      ";
            if( counter == 54 + adjustcounter ) name =  "L1A:  L1A received, TMB in L1A window                   ";
            if( counter == 55 + adjustcounter ) name =  "L1A:  L1A received, no TMB in window                    ";
            if( counter == 56 + adjustcounter ) name =  "L1A:  TMB triggered, no L1A in window                   ";
            if( counter == 57 + adjustcounter ) name =  "L1A:  TMB readouts completed                            ";
            if( counter == 58 + adjustcounter ) name =  "L1A:  TMB readouts lost by 1-event-per-L1A limit        ";
            //
            if( counter == 59 + adjustcounter ) name =  "STAT: CLCT Triads skipped                               ";
            if( counter == 60 + adjustcounter ) name =  "STAT: Raw hits buffer had to be reset                   ";
            if( counter == 61 + adjustcounter ) name =  "STAT: TTC Resyncs received                              ";
            if( counter == 62 + adjustcounter ) name =  "STAT: Sync Error, BC0/BXN=offset mismatch               ";
            if( counter == 63 + adjustcounter ) name =  "STAT: Parity Error in CFEB or RPC raw hits RAM          ";
            //
            // The following are not cleared via VME
            if( counter == 64 + adjustcounter ) name =  "HDR:  Pretrigger counter                                ";
            if( counter == 65 + adjustcounter ) name =  "HDR:  CLCT counter                                      ";
            if( counter == 66 + adjustcounter ) name =  "HDR:  TMB trigger counter                               ";
            if( counter == 67 + adjustcounter ) name =  "HDR:  ALCTs received counter                            ";
            if( counter == 68 + adjustcounter ) name =  "HDR:  L1As received counter (12 bits)                   ";
            if( counter == 69 + adjustcounter ) name =  "HDR:  Readout counter (12 bits)                         ";
            if( counter == 70 + adjustcounter ) name =  "HDR:  Orbit counter                                     ";
            //
            if( counter == 71 + adjustcounter ) name =  "ALCT:Struct Error, expect ALCT0[10:1]=0 when alct0vpf=0 ";
            if( counter == 72 + adjustcounter ) name =  "ALCT:Struct Error, expect ALCT1[10:1]=0 when alct1vpf=0 ";
            if( counter == 73 + adjustcounter ) name =  "ALCT:Struct Error, expect ALCT0vpf=1 when alct1vpf=1    ";
            if( counter == 74 + adjustcounter ) name =  "ALCT:Struct Error, expect ALCT0[10:1]>0 when alct0vpf=1 ";
            if( counter == 75 + adjustcounter ) name =  "ALCT:Struct Error, expect ALCT1[10:1]>0 when alct1vpf=1 ";
            if( counter == 76 + adjustcounter ) name =  "ALCT:Struct Error, expect ALCT1!=alct0 when alct0vpf=1  ";
            //
            if( counter == 77 + adjustcounter ) name =  "CCB:  TTCrx lock lost                                   ";
            if( counter == 78 + adjustcounter ) name =  "CCB:  qPLL lock lost                                    ";
            //
            return name;
        }
        //
        void TMB::ResetCounters(){
            //
            for(int i=0; i<GetMaxCounter(); i++) FinalCounter[i]=0;
            //
            // Clear counters
            //
            WriteRegister(cnt_ctrl_adr,0x21);
            WriteRegister(cnt_ctrl_adr,0x20);
            //
            return;
        }
        //
        int TMB::GetCounter(int counterID){
            //
            return FinalCounter[counterID];
        }
        //
        int * TMB::GetCounters(){
            //
            return NewCounters();
        }
        //
        int * TMB::NewCounters(){
            if(checkvme_fail()) return NULL;
            //
            // Take snapshot of current counter state
            //
            write_later(cnt_ctrl_adr,0x22); //snap
            vme_delay(0x20);
            write_later(cnt_ctrl_adr,0x20); //unsnap
            //
            // Extract counter data whose picture has been taken
            //
            for (int counter=0; counter < GetMaxCounter(); counter++){
                //
                for (int odd_even=0; odd_even<2; odd_even++) {
                    //
                    int write_value = ((counter << 9) & 0xfe00) | ((odd_even << 8) & 0x0100) | 0x0020;
                    //
                    write_later(cnt_ctrl_adr,write_value);
                    //
                    read_later(cnt_rdata_adr);
                }
            }   

            // CFEB BadBits registers: 0x122->0x142, total 17 words => 9 counters (32-bit)
            for(unsigned short add=0x122; add<=0x144; add+=2) read_later(add);
            //for 7DCFEB firmware
            if( GetHardwareVersion() == 2){  
                for(unsigned short add=0x15c; add<=0x168; add+=2) read_later(add);
            }
            // time since last hard_reset (in seconds)
            read_now(0xE8, (char *)FinalCounter);
            //
            return (int *)FinalCounter;
        }
        //
        // JMT uncomment to see scope output on screen as well as file
        //#define fprintf(fp, fmt, s...) { fprintf(fp, fmt, ## s); printf(fmt, ## s); }
        //
        //------------------------------------------------------------------------------
        // Entry scope160c()
        //------------------------------------------------------------------------------
        void    TMB::scope160c (
                unsigned long	 scp_ctrl_adr,
                unsigned long	 scp_rdata_adr,
                int				 scp_arm,
                int				 scp_readout,
                int				 scp_raw_decode,
                int				 scp_silent,
                int				 scp_playback,
                int				 scp_raw_data[512*160/16]
                ) {

            const int		NCHANNELS	= 160;
            const int		NRAMS		= NCHANNELS/16;
            //const int		NBITS		= NCHANNELS*16;
            const int		NTBINS		= 512;			// tbins per channel
            const int		NDSP		= 512;			// tbins to display
            //const int		NDSP		= 64;			// tbins to display
            const int		DISP_ALL	= 0;			// 1= display hex channel binary levels,0=blank them
            //const int		NFRAMES		= NTBINS*NCHANNELS/16;

            int				i;
            int				itbin;
            int				itbin_max;
            int				iram;
            int				ich;
            int				ibit;
            int				idigit;
            int				iframe;

            int				scope_ram[NTBINS][NRAMS];
            int				scope_ch[NTBINS];
            int				ihex[NTBINS];

            static bool		scp_first_pass = true;
            int				last_bit;
            int				ndigits;

            int				scp_ch_trig_en;
            int				scp_runstop;
            int				scp_forcetrig;
            int				scp_auto;
            int				scp_nowrite;
            int				scp_tbins;
            int				scp_ramsel;
            int				scp_waiting;
            int				scp_trig_done;
            int				scp_state;

            //------------------------------------------------------------------------------
            // Channel labels
            //------------------------------------------------------------------------------
            class label
            {
                public:
                    int		nbits;
                    int		bit;
                    std::string	tag;
            };
            static label ch[NCHANNELS];

            if (scp_first_pass) {
                //	Channel has nbits       This is bit                  Channel name tag
                //                  |                 |                  |
                // Pre-trigger to DMB
                ch[  0].nbits = 1;	ch[  0].bit = 0;	ch[  0].tag="sequencer pretrig  ";
                ch[  1].nbits = 1;	ch[  1].bit = 0;	ch[  1].tag="triad_tp Cf0Ds1Ly2 ";
                ch[  2].nbits = 1;	ch[  2].bit = 0;	ch[  2].tag="any_cfeb_hit       ";
                ch[  3].nbits = 1;	ch[  3].bit = 0;	ch[  3].tag="active_feb_flag    ";
                ch[  4].nbits = 5;	ch[  4].bit = 0;	ch[  4].tag="active_feb_flag[0] ";
                ch[  5].nbits = 5;	ch[  5].bit = 1;	ch[  5].tag="active_feb_flag[1] ";
                ch[  6].nbits = 5;	ch[  6].bit = 2;	ch[  6].tag="active_feb_flag[2] ";
                ch[  7].nbits = 5;	ch[  7].bit = 3;	ch[  7].tag="active_feb_flag[3] ";
                ch[  8].nbits = 5;	ch[  8].bit = 4;	ch[  8].tag="active_feb_flag[4] ";

                // Pre-trigger CLCT*ALCT matching
                ch[  9].nbits = 1;	ch[  9].bit = 0;	ch[  9].tag="alct_active_feb    ";
                ch[ 10].nbits = 1;	ch[ 10].bit = 0;	ch[ 10].tag="alct_pretrig_win   ";

                // Pre-trigger Processing
                ch[ 11].nbits = 3;	ch[ 11].bit = 0;	ch[ 11].tag="clct_sm_vec[0]     ";
                ch[ 12].nbits = 3;	ch[ 12].bit = 1;	ch[ 12].tag="clct_sm_vec[1]     ";
                ch[ 13].nbits = 3;	ch[ 13].bit = 2;	ch[ 13].tag="clct_sm_vec[2]     ";

                ch[ 14].nbits = 1;	ch[ 14].bit = 0;	ch[ 14].tag="wr_buf_ready       ";
                ch[ 15].nbits = 1;	ch[ 15].bit = 0;	ch[ 15].tag="sequencer pretrig  ";

                ch[ 16].nbits = 12;	ch[ 16].bit = 0;	ch[ 16].tag="bxn_counter[ 0]    ";
                ch[ 17].nbits = 12;	ch[ 17].bit = 1;	ch[ 17].tag="bxn_counter[ 1]    ";
                ch[ 18].nbits = 12;	ch[ 18].bit = 2;	ch[ 18].tag="bxn_counter[ 2]    ";
                ch[ 19].nbits = 12;	ch[ 19].bit = 3;	ch[ 19].tag="bxn_counter[ 3]    ";
                ch[ 20].nbits = 12;	ch[ 20].bit = 4;	ch[ 20].tag="bxn_counter[ 4]    ";
                ch[ 21].nbits = 12;	ch[ 21].bit = 5;	ch[ 21].tag="bxn_counter[ 5]    ";
                ch[ 22].nbits = 12;	ch[ 22].bit = 6;	ch[ 22].tag="bxn_counter[ 6]    ";
                ch[ 23].nbits = 12;	ch[ 23].bit = 7;	ch[ 23].tag="bxn_counter[ 7]    ";
                ch[ 24].nbits = 12;	ch[ 24].bit = 8;	ch[ 24].tag="bxn_counter[ 8]    ";
                ch[ 25].nbits = 12;	ch[ 25].bit = 9;	ch[ 25].tag="bxn_counter[ 9]    ";
                ch[ 26].nbits = 12;	ch[ 26].bit =10;	ch[ 26].tag="bxn_counter[10]    ";
                ch[ 27].nbits = 12;	ch[ 27].bit =11;	ch[ 27].tag="bxn_counter[11]    ";

                ch[ 28].nbits = 1;	ch[ 28].bit = 0;	ch[ 28].tag="discard_nobuf      ";

                // CLCT Pattern Finder Output
                ch[ 29].nbits = 1;	ch[ 29].bit = 0;	ch[ 29].tag="empty              ";
                ch[ 30].nbits = 1;	ch[ 30].bit = 0;	ch[ 30].tag="empty              ";
                ch[ 31].nbits = 1;	ch[ 31].bit = 0;	ch[ 31].tag="sequencer pretrig  ";

                ch[ 32].nbits = 3;	ch[ 32].bit = 0;	ch[ 32].tag="hs_hit_1st[0]      ";
                ch[ 33].nbits = 3;	ch[ 33].bit = 1;	ch[ 33].tag="hs_hit_1st[1]      ";
                ch[ 34].nbits = 3;	ch[ 34].bit = 2;	ch[ 34].tag="hs_hit_1st[2]      ";

                ch[ 35].nbits = 4;	ch[ 35].bit = 0;	ch[ 35].tag="hs_pid_1st[0]      ";
                ch[ 36].nbits = 4;	ch[ 36].bit = 1;	ch[ 36].tag="hs_pid_1st[1]      ";
                ch[ 37].nbits = 4;	ch[ 37].bit = 2;	ch[ 37].tag="hs_pid_1st[2]      ";
                ch[ 38].nbits = 4;	ch[ 38].bit = 3;	ch[ 38].tag="hs_pid_1st[3]      ";

                ch[ 39].nbits = 8;	ch[ 39].bit = 0;	ch[ 39].tag="hs_key_1st[0]      ";
                ch[ 40].nbits = 8;	ch[ 40].bit = 1;	ch[ 40].tag="hs_key_1st[1]      ";
                ch[ 41].nbits = 8;	ch[ 41].bit = 2;	ch[ 41].tag="hs_key_1st[2]      ";
                ch[ 42].nbits = 8;	ch[ 42].bit = 3;	ch[ 42].tag="hs_key_1st[3]      ";
                ch[ 43].nbits = 8;	ch[ 43].bit = 4;	ch[ 43].tag="hs_key_1st[4]      ";
                ch[ 44].nbits = 8;	ch[ 44].bit = 5;	ch[ 44].tag="hs_key_1st[5]      ";
                ch[ 45].nbits = 8;	ch[ 45].bit = 6;	ch[ 45].tag="hs_key_1st[6]      ";
                ch[ 46].nbits = 8;	ch[ 46].bit = 7;	ch[ 46].tag="hs_key_1st[7]      ";

                ch[ 47].nbits = 1;	ch[ 47].bit = 0;	ch[ 47].tag="sequencer pretrig  ";

                ch[ 48].nbits = 3;	ch[ 48].bit = 0;	ch[ 48].tag="hs_hit_2nd[0]      ";
                ch[ 49].nbits = 3;	ch[ 49].bit = 1;	ch[ 49].tag="hs_hit_2nd[1]      ";
                ch[ 50].nbits = 3;	ch[ 50].bit = 2;	ch[ 50].tag="hs_hit_2nd[2]      ";

                ch[ 51].nbits = 4;	ch[ 51].bit = 0;	ch[ 51].tag="hs_pid_2nd[0]      ";
                ch[ 52].nbits = 4;	ch[ 52].bit = 1;	ch[ 52].tag="hs_pid_2nd[1]      ";
                ch[ 53].nbits = 4;	ch[ 53].bit = 2;	ch[ 53].tag="hs_pid_2nd[2]      ";
                ch[ 54].nbits = 4;	ch[ 54].bit = 3;	ch[ 54].tag="hs_pid_2nd[3]      ";

                ch[ 55].nbits = 8;	ch[ 55].bit = 0;	ch[ 55].tag="hs_key_2nd[0]      ";
                ch[ 56].nbits = 8;	ch[ 56].bit = 1;	ch[ 56].tag="hs_key_2nd[1]      ";
                ch[ 57].nbits = 8;	ch[ 57].bit = 2;	ch[ 57].tag="hs_key_2nd[2]      ";
                ch[ 58].nbits = 8;	ch[ 58].bit = 3;	ch[ 58].tag="hs_key_2nd[3]      ";
                ch[ 59].nbits = 8;	ch[ 59].bit = 4;	ch[ 59].tag="hs_key_2nd[4]      ";
                ch[ 60].nbits = 8;	ch[ 60].bit = 5;	ch[ 60].tag="hs_key_2nd[5]      ";
                ch[ 61].nbits = 8;	ch[ 61].bit = 6;	ch[ 61].tag="hs_key_2nd[6]      ";
                ch[ 62].nbits = 8;	ch[ 62].bit = 7;	ch[ 62].tag="hs_key_2nd[7]      ";

                ch[ 63].nbits = 1;	ch[ 63].bit = 0;	ch[ 63].tag="sequencer pretrig  ";

                // CLCT Builder
                ch[ 64].nbits = 1;	ch[ 64].bit = 0;	ch[ 64].tag="clct0_really_valid ";
                ch[ 65].nbits = 1;	ch[ 65].bit = 0;	ch[ 65].tag="clct0_vpf          ";
                ch[ 66].nbits = 1;	ch[ 66].bit = 0;	ch[ 66].tag="clct1_vpf          ";
                ch[ 67].nbits = 1;	ch[ 67].bit = 0;	ch[ 67].tag="clct_push_xtmb     ";
                ch[ 68].nbits = 1;	ch[ 68].bit = 0;	ch[ 68].tag="discard_invp       ";

                // TMB Matching
                ch[ 69].nbits = 1;	ch[ 69].bit = 0;	ch[ 69].tag="alct0_valid        ";
                ch[ 70].nbits = 1;	ch[ 70].bit = 0;	ch[ 70].tag="alct1_valid        ";

                ch[ 71].nbits = 1;	ch[ 71].bit = 0;	ch[ 71].tag="alct_vpf_tprt      ";
                ch[ 72].nbits = 1;	ch[ 72].bit = 0;	ch[ 72].tag="clct_vpf_tprt      ";
                ch[ 73].nbits = 1;	ch[ 73].bit = 0;	ch[ 73].tag="clct_window_tprt   ";

                ch[ 74].nbits = 4;	ch[ 74].bit = 0;	ch[ 74].tag="tmb_match_win[0]   ";
                ch[ 75].nbits = 4;	ch[ 75].bit = 1;	ch[ 75].tag="tmb_match_win[1]   ";
                ch[ 76].nbits = 4;	ch[ 76].bit = 2;	ch[ 76].tag="tmb_match_win[2]   ";
                ch[ 77].nbits = 4;	ch[ 77].bit = 3;	ch[ 77].tag="tmb_match_win[3]   ";

                ch[ 78].nbits = 1;	ch[ 78].bit = 0;	ch[ 78].tag="tmb_alct_discard   ";
                ch[ 79].nbits = 1;	ch[ 79].bit = 0;	ch[ 79].tag="sequencer pretrig  ";
                ch[ 80].nbits = 1;	ch[ 80].bit = 0;	ch[ 80].tag="tmb_clct_discard   ";

                // TMB Match Results
                ch[ 81].nbits = 1;	ch[ 81].bit = 0;	ch[ 81].tag="tmb_trig_pulse     ";
                ch[ 82].nbits = 1;	ch[ 82].bit = 0;	ch[ 82].tag="tmb_trig_keep      ";
                ch[ 83].nbits = 1;	ch[ 83].bit = 0;	ch[ 83].tag="tmb_match          ";
                ch[ 84].nbits = 1;	ch[ 84].bit = 0;	ch[ 84].tag="tmb_alct_only      ";
                ch[ 85].nbits = 1;	ch[ 85].bit = 0;	ch[ 85].tag="tmb_clct_only      ";
                ch[ 86].nbits = 1;	ch[ 86].bit = 0;	ch[ 86].tag="discard_tmbreject  ";

                // MPC
                ch[ 87].nbits = 1;	ch[ 87].bit = 0;	ch[ 87].tag="mpc_xmit_lct0      ";
                ch[ 88].nbits = 1;	ch[ 88].bit = 0;	ch[ 88].tag="mpc_xmit_lct1      ";
                ch[ 89].nbits = 1;	ch[ 89].bit = 0;	ch[ 89].tag="mpc_response_ff    ";

                ch[ 90].nbits = 2;	ch[ 90].bit = 0;	ch[ 90].tag="mpc_accept[0]      ";
                ch[ 91].nbits = 2;	ch[ 91].bit = 1;	ch[ 91].tag="mpc_accept[1]      ";

                // L1A
                ch[ 92].nbits = 1;	ch[ 92].bit = 0;	ch[ 92].tag="l1a_pulse          ";
                ch[ 93].nbits = 1;	ch[ 93].bit = 0;	ch[ 93].tag="l1a_window_open    ";
                ch[ 94].nbits = 1;	ch[ 94].bit = 0;	ch[ 94].tag="l1a_match          ";

                ch[ 95].nbits = 1;	ch[ 95].bit = 0;	ch[ 95].tag="sequencer pretrig  ";

                // Buffer push at L1A
                ch[ 96].nbits = 1;	ch[ 96].bit = 0;	ch[ 96].tag="buf_push at l1a    ";

                ch[ 97].nbits = 7;	ch[ 97].bit = 0;	ch[ 97].tag="buf_push_adr[0]l1a ";
                ch[ 98].nbits = 7;	ch[ 98].bit = 1;	ch[ 98].tag="buf_push_adr[1]l1a ";
                ch[ 99].nbits = 7;	ch[ 99].bit = 2;	ch[ 99].tag="buf_push_adr[2]l1a ";
                ch[100].nbits = 7;	ch[100].bit = 3;	ch[100].tag="buf_push_adr[3]l1a ";
                ch[101].nbits = 7;	ch[101].bit = 4;	ch[101].tag="buf_push_adr[4]l1a ";
                ch[102].nbits = 7;	ch[102].bit = 5;	ch[102].tag="buf_push_adr[5]l1a ";
                ch[103].nbits = 7;	ch[103].bit = 6;	ch[103].tag="buf_push_adr[6]l1a ";

                // DMB Readout
                ch[104].nbits = 1;	ch[104].bit = 0;	ch[104].tag="dmb_dav            ";
                ch[105].nbits = 1;	ch[105].bit = 0;	ch[105].tag="dmb_busy           ";

                ch[106].nbits = 5;	ch[106].bit = 0;	ch[106].tag="read_sm_vec[0]     ";
                ch[107].nbits = 5;	ch[107].bit = 1;	ch[107].tag="read_sm_vec[1]     ";
                ch[108].nbits = 5;	ch[108].bit = 2;	ch[108].tag="read_sm_vec[2]     ";
                ch[109].nbits = 5;	ch[109].bit = 3;	ch[109].tag="read_sm_vec[3]     ";
                ch[110].nbits = 5;	ch[110].bit = 4;	ch[110].tag="read_sm_vec[4]     ";

                ch[111].nbits = 1;	ch[111].bit = 0;	ch[111].tag="sequencer pretrig  ";

                ch[112].nbits = 15;	ch[112].bit = 0;	ch[112].tag="dmb_seq_wdata[0]   ";
                ch[113].nbits = 15;	ch[113].bit = 1;	ch[113].tag="dmb_seq_wdata[1]   ";
                ch[114].nbits = 15;	ch[114].bit = 2;	ch[114].tag="dmb_seq_wdata[2]   ";
                ch[115].nbits = 15;	ch[115].bit = 3;	ch[115].tag="dmb_seq_wdata[3]   ";
                ch[116].nbits = 15;	ch[116].bit = 4;	ch[116].tag="dmb_seq_wdata[4]   ";
                ch[117].nbits = 15;	ch[117].bit = 5;	ch[117].tag="dmb_seq_wdata[5]   ";
                ch[118].nbits = 15;	ch[118].bit = 6;	ch[118].tag="dmb_seq_wdata[6]   ";
                ch[119].nbits = 15;	ch[119].bit = 7;	ch[119].tag="dmb_seq_wdata[7]   ";
                ch[120].nbits = 15;	ch[120].bit = 8;	ch[120].tag="dmb_seq_wdata[8]   ";
                ch[121].nbits = 15;	ch[121].bit = 9;	ch[121].tag="dmb_seq_wdata[9]   ";
                ch[122].nbits = 15;	ch[122].bit = 10;	ch[122].tag="dmb_seq_wdata[10]  ";
                ch[123].nbits = 15;	ch[123].bit = 11;	ch[123].tag="dmb_seq_wdata[11]  ";
                ch[124].nbits = 15;	ch[124].bit = 12;	ch[124].tag="dmb_seq_wdata[12]  ";
                ch[125].nbits = 15;	ch[125].bit = 13;	ch[125].tag="dmb_seq_wdata[13]  ";
                ch[126].nbits = 15;	ch[126].bit = 14;	ch[126].tag="dmb_seq_wdata[14]  ";

                ch[127].nbits = 1;	ch[127].bit = 0;	ch[127].tag="sequencer pretrig  ";

                ch[128].nbits = 1;	ch[128].bit = 0;	ch[128].tag="dmb_seq_wdata[15]  ";

                // CLCT+TMB Pipelines
                ch[129].nbits = 4;	ch[129].bit = 0;	ch[129].tag="wr_buf_adr[0]      ";
                ch[130].nbits = 4;	ch[130].bit = 1;	ch[130].tag="wr_buf_adr[1]      ";
                ch[131].nbits = 4;	ch[131].bit = 2;	ch[131].tag="wr_buf_adr[2]      ";
                ch[132].nbits = 4;	ch[132].bit = 3;	ch[132].tag="wr_buf_adr[3]      ";

                ch[133].nbits = 1;	ch[133].bit = 0;	ch[133].tag="wr_push_xtmb       ";
                ch[134].nbits = 4;	ch[134].bit = 0;	ch[134].tag="wr_adr_xtmb[0]     ";
                ch[135].nbits = 4;	ch[135].bit = 1;	ch[135].tag="wr_adr_xtmb[1]     ";
                ch[136].nbits = 4;	ch[136].bit = 2;	ch[136].tag="wr_adr_xtmb[2]     ";
                ch[137].nbits = 4;	ch[137].bit = 3;	ch[137].tag="wr_adr_xtmb[3]     ";

                ch[138].nbits = 1;	ch[138].bit = 0;	ch[138].tag="wr_push_rtmb       ";
                ch[139].nbits = 4;	ch[139].bit = 0;	ch[139].tag="wr_adr_rtmb[0]     ";
                ch[140].nbits = 4;	ch[140].bit = 1;	ch[140].tag="wr_adr_rtmb[1]     ";
                ch[141].nbits = 4;	ch[141].bit = 2;	ch[141].tag="wr_adr_rtmb[2]     ";
                ch[142].nbits = 4;	ch[142].bit = 3;	ch[142].tag="wr_adr_rtmb[3]     ";

                ch[143].nbits = 1;	ch[143].bit = 0;	ch[143].tag="sequencer pretrig  ";

                ch[144].nbits = 1;	ch[144].bit = 0;	ch[144].tag="wr_push_xmpc       ";
                ch[145].nbits = 4;	ch[145].bit = 0;	ch[145].tag="wr_adr_xmpc[0]     ";
                ch[146].nbits = 4;	ch[146].bit = 1;	ch[146].tag="wr_adr_xmpc[1]     ";
                ch[147].nbits = 4;	ch[147].bit = 2;	ch[147].tag="wr_adr_xmpc[2]     ";
                ch[148].nbits = 4;	ch[148].bit = 3;	ch[148].tag="wr_adr_xmpc[3]     ";

                ch[149].nbits = 1;	ch[149].bit = 0;	ch[149].tag="wr_push_rmpc       ";
                ch[150].nbits = 4;	ch[150].bit = 0;	ch[150].tag="wr_adr_rmpc[0]     ";
                ch[151].nbits = 4;	ch[151].bit = 1;	ch[151].tag="wr_adr_rmpc[1]     ";
                ch[152].nbits = 4;	ch[152].bit = 2;	ch[152].tag="wr_adr_rmpc[2]     ";
                ch[153].nbits = 4;	ch[153].bit = 3;	ch[153].tag="wr_adr_rmpc[3]     ";

                // Buffer pop at readout completion
                ch[154].nbits = 1;	ch[154].bit = 0;	ch[154].tag="buf_pop            ";
                ch[155].nbits = 4;	ch[155].bit = 0;	ch[155].tag="buf_pop_adr[0]     ";
                ch[156].nbits = 4;	ch[156].bit = 1;	ch[156].tag="buf_pop_adr[1]     ";
                ch[157].nbits = 4;	ch[157].bit = 2;	ch[157].tag="buf_pop_adr[2]     ";
                ch[158].nbits = 4;	ch[158].bit = 3;	ch[158].tag="buf_pop_adr[3]     ";

                ch[159].nbits = 1;	ch[159].bit = 0;	ch[159].tag="sequencer pretrig  ";

                scp_first_pass=false;
            }

            //------------------------------------------------------------------------------
            //	scp_status for debugging
            //------------------------------------------------------------------------------
            rd_data=0;
            if(!scp_playback) {
                adr = scp_ctrl_adr;
                status = vme_read(adr,rd_data);
            }

            scp_ch_trig_en	= (rd_data >> 0) & 0x1;
            scp_runstop		= (rd_data >> 1) & 0x1;
            scp_forcetrig	= (rd_data >> 2) & 0x1;
            scp_auto		= (rd_data >> 3) & 0x1;
            scp_nowrite		= (rd_data >> 4) & 0x1;
            scp_tbins		= (rd_data >> 5) & 0x7;
            scp_ramsel		= (rd_data >> 8) & 0xF;
            scp_waiting		= (rd_data >>12) & 0x1;
            scp_trig_done	= (rd_data >>13) & 0x1;

            (*MyOutput_) << "\nScope Call\n";
            (*MyOutput_) << "----------\n";
            (*MyOutput_) << "\nscp_arm        = " << logical(scp_arm);
            (*MyOutput_) << "\nscp_readout    = " << logical(scp_readout);
            (*MyOutput_) << "\nscp_raw_decode = " << logical(scp_raw_decode);
            (*MyOutput_) << "\nscp_silent     = " << logical(scp_silent);
            (*MyOutput_) << "\nscp_playback   = " << logical(scp_playback);
            (*MyOutput_) << "\n";
            (*MyOutput_) << "\nscp_ch_trig_en = " << scp_ch_trig_en;
            (*MyOutput_) << "\nscp_runstop    = " << scp_runstop;
            (*MyOutput_) << "\nscp_forcetrig  = " << scp_forcetrig;
            (*MyOutput_) << "\nscp_auto       = " << scp_auto;
            (*MyOutput_) << "\nscp_nowrite    = " << scp_nowrite;
            (*MyOutput_) << "\nscp_tbins      = " << scp_tbins;
            (*MyOutput_) << "\nscp_ramsel     = " << scp_ramsel;
            (*MyOutput_) << "\nscp_waiting    = " << scp_waiting;
            (*MyOutput_) << "\nscp_trig_done  = " << scp_trig_done;

            //------------------------------------------------------------------------------
            //	scp_arm
            //------------------------------------------------------------------------------
            if (scp_arm)
            {
                // Get current scope control state
                adr = scp_ctrl_adr;
                status = vme_read(adr,rd_data);
                scp_runstop		= (rd_data >> 1) & 0x1;
                scp_forcetrig	= (rd_data >> 2) & 0x1;

                // Reset scope state to idle
                scp_runstop=0;
                scp_forcetrig=0;

                wr_data=rd_data & 0xFFF9;	//clear bits 1,2
                wr_data=wr_data | (scp_runstop   << 1);
                wr_data=wr_data | (scp_forcetrig << 2);
                status = vme_write(adr,wr_data);

                //	status = vme_read(adr),rd_data);	//read scope status
                //	printf("\tScope status %4.4X\n",rd_data);

                // Arm scope for triggering, send scope state to wait_trig
                scp_runstop=1;

                wr_data=rd_data & 0xFFF9;	//clear bits 1,2
                wr_data=wr_data | (scp_runstop   << 1);
                wr_data=wr_data | (scp_forcetrig << 2);
                status = vme_write(adr,wr_data);
                goto exit;
            }	//close scp_arm

            //------------------------------------------------------------------------------
            //	scp_readout
            //------------------------------------------------------------------------------
            // Wait for scope to trigger
            if(scp_readout)
            {
                // Get current scope control state, exit if in auto mode
                adr = scp_ctrl_adr;
                status = vme_read(adr,rd_data);
                scp_auto = (rd_data >> 3) & 0x1;
                if(scp_auto==1) goto exit;					// Exit if in auto mode

                for (i=1; i<=20; ++i) {						// Give it time to store 512 words
                    adr = scp_ctrl_adr;
                    status = vme_read(adr,rd_data);				// Read scope status
                    //	printf("\tScope status %4.4X\n",rd_data);
                    scp_trig_done = (rd_data >>13) & 0x1;
                    if(scp_trig_done != 0) goto triggered;		// Triggered and done
                    if(!scp_silent)
                        (*MyOutput_) << "Waiting for scope trigger " << i;
                }

                (*MyOutput_) << "Scope never triggered\n";// Bummer, dude
                goto exit;

                // Read back embedded scope data
triggered:
                if(!scp_silent)
                    (*MyOutput_) << "\tScope triggered\n";

                adr = scp_ctrl_adr;
                status = vme_read(adr,rd_data);				// Read scope status
                scp_state=rd_data;

                for (itbin=0; itbin<=NTBINS-1; ++itbin) {	// Loop over ram addresses
                    for (iram=0;  iram <=NRAMS-1;  ++iram )	{	// Loop over ram chips
                        adr = scp_ctrl_adr;
                        wr_data=scp_state & 0xF0FF;					// Clear ramsel bits 8,9.10,11
                        wr_data=wr_data | (iram << 8);				// Ram block select
                        status = vme_write(adr,wr_data);

                        adr = scp_rdata_adr;
                        wr_data=itbin;								// Write ram address
                        status = vme_write(adr,wr_data);

                        status = vme_read(adr,rd_data);				// Read scope data at this address
                        scope_ram[itbin][iram]=rd_data;				// Store 16 parallel in local array

                        //	fprintf(stdout,"%3.3i %1i %4.4X\n",itbin,iram,rd_data);
                    }		//close iram
                }		//close itbin
                goto display;
            }		//close scp_readout

            //------------------------------------------------------------------------------
            //	scp_raw_decode
            //------------------------------------------------------------------------------
            // load scope_ram from raw-hits format readout
            if(scp_raw_decode) {
                if((scp_auto!=1) && !scp_playback) goto exit;	// Exit if not auto mode

                iframe=0;
                itbin_max=(scp_tbins+1)*64-1;					// user limited number of tbins

                for (iram=0;  iram <=NRAMS-1; ++iram)  {		// Loop over RAM chips
                    for (itbin=0; itbin<=NTBINS-1;++itbin) {		// Loop over time bins in ram chip	
                        scope_ram[itbin][iram]=0;						// Pad 0s for shorter tbin runs
                        if(itbin <= itbin_max) {
                            scope_ram[itbin][iram]=scp_raw_data[iframe];	// Raw hits scope data
                            iframe++;
                        }
                    }}

                //	iframe=0;
                //	for (iram=0;  iram <=NRAMS-1;  ++iram)  {	// Loop over RAM chips
                //	for (itbin=0; itbin<=itbin_max;++itbin) {	// Loop over time bins in ram chip	
                //	fprintf(stdout,"scope160c frame=%4i%5.4X\n",iframe,scope_ram[itbin][iram]);
                //	iframe++;
                //	}}

            }	//close scp_raw_decode

            //------------------------------------------------------------------------------
            //	Display
            //------------------------------------------------------------------------------
            // Construct waveform
display:
            (*MyOutput_) << "\n";

            for (ich=0; ich<=NCHANNELS-1; ++ich)    {	//Loop over scope channels
                iram=ich/16;								//RAM chip has 16 channels
                for (itbin=0; itbin<=NTBINS-1; ++itbin) {	//Time bins per channel

                    // Construct binary waveforms for single-bit channels	
                    ibit=(scope_ram[itbin][iram] >> (ich % 16)) & 0x1; //Logic levels vs tbin for this channel
                    if(ibit==0) scope_ch[itbin]='_';			//Display symbol for logic 0					
                    if(ibit==1) scope_ch[itbin]='-';			//Display symbol for logic 1	

                    // Build integer for special channel groups
                    if (ch[ich].nbits > 1) {
                        if (ch[ich].bit == 0) ihex[itbin]=0;
                        ihex[itbin] = ihex[itbin] | (ibit << ch[ich].bit);
                    }
                } //close itbin

                // Display binary waveforms
                int chblank=(ch[ich].nbits!=1) && !DISP_ALL;	// dont display channels that are hex digits

                if(!chblank) {
                    (*MyOutput_) << "ch" << ich << "\t" << ch[ich].tag.c_str() << "\t";
                    for(i=0;i<NDSP;++i) 
                        (*MyOutput_) << scope_ch[i];
                    (*MyOutput_) << std::endl;
                }

                // Display hex integers for special channel groups
                if (ch[ich].nbits > 1) {
                    last_bit=(ch[ich].nbits == (ch[ich].bit + 1));
                    if (last_bit) {
                        ndigits=(ch[ich].nbits+3)/4;
                        for (idigit=ndigits-1; idigit>=0; --idigit) {
                            (*MyOutput_) << "ch" << ich << "\t" << ch[ich].tag.c_str() << "\t";
                            for(i=0;i<NDSP;++i) 
                                (*MyOutput_) << std::hex << ((ihex[i] >> (4*idigit)) & 0xF);
                            (*MyOutput_) << std::endl;
                        } // close for idigit
                    } // close if last_bit
                } //close if ch[ich]
            } //close for (ich=0..

            (*MyOutput_) << std::endl;

            //------------------------------------------------------------------------------
            // We be done
            //------------------------------------------------------------------------------
exit:
            return;
        }
        void TMB::scope(int scp_arm,int scp_readout, int scp_channel) {

            unsigned int nchannels = 128;
            unsigned int nrams     = nchannels/16;
            unsigned int nbits     = nchannels*16;

            static const char* scope_tag[128] = {"ch00 sequencer pretrig    ",
                "ch01 active_feb_flag      ",
                "ch02 any_cfeb_hit         ",
                "ch03 any_cfeb_hsds        ",
                "ch04 wr_buf_busy          ",
                "ch05 wr_buf_ready         ",
                "ch06 clct_ext_trig_os     ",
                "ch07 alct_active_feb      ",
                "ch08 alct_pretrig_win     ",
                "ch09 first_really_valid   ",
                "ch10 clct_sm==xtmb        ",
                "ch11 tmb_discard          ",
                "ch12 discard_nobuf        ",
                "ch13 discard_invp         ",
                "ch14 discard_tmbreject    ",
                "ch15 0(no dmb readout)    ",
                "ch16 first_nhit[0]        ",
                "ch17 first_nhit[1]        ",
                "ch18 first_nhit[2]        ",
                "ch19 first_pat[3]hsds     ",
                "ch20 second_nhit[0]       ",
                "ch21 second_nhit[1]       ",
                "ch22 second_nhit[2]       ",
                "ch23 second_pat[3]hsds    ",
                "ch24 latch_clct0          ",
                "ch25 latch_clct1          ",
                "ch26 alct_1st_valid       ",
                "ch27 alct_2nd_valid       ",
                "ch28 alct_vpf_tp          ",
                "ch29 clct_vpf_tp          ",
                "ch30 clct_window_tp       ",
                "ch31 0(no dmb readout)    ",
                "ch32 sequencer pretrig    ",
                "ch33 mpc_frame_ff         ",
                "ch34 mpc_response_ff      ",
                "ch35 mpc_accept_tp[0]     ",
                "ch36 mpc_accept_tp[1]     ",
                "ch37 l1a_pulse_dsp        ",
                "ch38 l1a_window_dsp       ",
                "ch39 dmb_dav_mux          ",
                "ch40 dmb_busy             ",
                "ch41 hs_thresh[0]         ",
                "ch42 hs_thresh[1]         ",
                "ch43 hs_thresh[2]         ",
                "ch44 ds_thresh[0]         ",
                "ch45 ds_thresh[1]         ",
                "ch46 ds_thresh[2]         ",
                "ch47 0(no dmb readout)    ",
                "ch48 sequencer pretrig    ",
                "ch49 valid_clct_required  ",
                "ch50 buf_nbusy[0]         ",
                "ch51 buf_nbusy[1]         ",
                "ch52 buf_nbusy[2]         ",
                "ch53 buf_nbusy[3]         ",
                "ch54 0                    ",
                "ch55 0                    ",
                "ch56 0                    ",
                "ch57 0                    ",
                "ch58 0                    ",
                "ch59 l1a_rx_counter[0]    ",
                "ch60 l1a_rx_counter[1]    ",
                "ch61 l1a_rx_counter[2]    ",
                "ch62 l1a_rx_counter[3]    ",
                "ch63 0(no dmb readout)    ",
                "ch64 sequencer pretrig    ",
                "ch65 bxn_counter[ 0]      ",
                "ch66 bxn_counter[ 1]      ",
                "ch67 bxn_counter[ 2]      ",
                "ch68 bxn_counter[ 3]      ",
                "ch69 bxn_counter[ 4]      ",
                "ch70 bxn_counter[ 5]      ",
                "ch71 bxn_counter[ 6]      ",
                "ch72 bxn_counter[ 7]      ",
                "ch73 bxn_counter[ 8]      ",
                "ch74 bxn_counter[ 9]      ",
                "ch75 bxn_counter[10]      ",
                "ch76 bxn_counter[11]      ",
                "ch77 0                    ",
                "ch78 0                    ",
                "ch79 0(no dmb readout)    ",
                "ch80 dmb seq_wdata[0]     ",
                "ch81 dmb seq_wdata[1]     ",
                "ch82 dmb seq_wdata[2]     ",
                "ch83 dmb seq_wdata[3]     ",
                "ch84 dmb seq_wdata[4]     ",
                "ch85 dmb seq_wdata[5]     ",
                "ch86 dmb seq_wdata[6]     ",
                "ch87 dmb seq_wdata[7]     ",
                "ch88 dmb seq_wdata[8]     ",
                "ch89 dmb seq_wdata[9]     ",
                "ch90 dmb seq_wdata[10]    ",
                "ch91 dmb seq_wdata[11]    ",
                "ch92 dmb seq_wdata[12]    ",
                "ch93 dmb seq_wdata[13]    ",
                "ch94 dmb seq_wdata[14]    ",
                "ch95 dmb seq_wdata[15]    ",
                "ch96  rpc0_bxn[0]         ",
                "ch97  rpc0_bxn[1]         ",
                "ch98  rpc0_bxn[2]         ",
                "ch99  rpc1_bxn[0]         ",
                "ch100 rpc1_bxn[1]         ",
                "ch101 rpc1_bxn[2]         ",
                "ch102 rpc2bxn[0]          ",
                "ch103 rpc2bxn[1]          ",
                "ch104 rpc2bxn[2]          ",
                "ch105 rpc3bxn[0]          ",
                "ch106 rpc3bxn[1]          ",
                "ch107 rpc3bxn[2]          ",
                "ch108 0                   ",
                "ch109 0                   ",
                "ch110 0                   ",
                "ch111 0(no dmb readout)   ",
                "ch112 rpc0_nhits[0]       ",
                "ch113 rpc0_nhits[1]       ",
                "ch114 rpc0_nhits[2]       ",
                "ch115 rpc0_nhits[3]       ",
                "ch116 rpc1_nhits[0]       ",
                "ch117 rpc1_nhits[1]       ",
                "ch118 rpc1_nhits[2]       ",
                "ch119 rpc1_nhits[3]       ",
                "ch120 rpc2_nhits[0]       ",
                "ch121 rpc2_nhits[1]       ",
                "ch122 rpc2_nhits[2]       ",
                "ch123 rpc2_nhits[3]       ",
                "ch124 rpc3_nhits[0]       ",
                "ch125 rpc3_nhits[1]       ",
                "ch126 rpc3_nhits[2]       ",
                "ch127 rpc3_nhits[3](no d) "
            } ;

            unsigned long int scope_ram[256][nrams];
            int scp_raw_data[nbits];
            char *scope_ch[256];
            int scope_raw_decode = 1;

            unsigned long int runstop;
            //unsigned long int force_trig;
            //unsigned long int ch_source;
            unsigned long int ram_sel=0;
            unsigned long int Auto=0;
            //unsigned long int nowrite;
            //unsigned long int ready;
            //unsigned long int trig_done;

            unsigned long int adr;
            unsigned long int rd_data = 0;
            unsigned long int wr_data;
            //unsigned long int status;
            unsigned long int i;
            unsigned long int itbin;
            unsigned long int ich;
            unsigned long int ibit;
            unsigned long int iram;
            //unsigned long int idigit;
            unsigned long int iline;
            unsigned long int iadr;

            unsigned long int first_nhit[256];
            unsigned long int second_nhit[256];
            unsigned long int hs_thresh[256] ;
            unsigned long int ds_thresh[256] ;
            unsigned long int bxn[256] ;
            unsigned long int dmb[256] ;
            unsigned long int l1a_rx_cnt[256] ;
            unsigned long int buf_nbusy[256] ;

            unsigned long int	rpc0_bxn[256] ;
            unsigned long int	rpc1_bxn[256] ;
            unsigned long int	rpc2_bxn[256] ;
            unsigned long int	rpc3_bxn[256] ;
            unsigned long int	rpc0_nhits[256] ;
            unsigned long int	rpc1_nhits[256] ;
            unsigned long int	rpc2_nhits[256] ;
            unsigned long int	rpc3_nhits[256] ;


            rd_data = 0; //temp

            /**** scp_arm ****************************************************/
            if(scp_arm) {

                //Get current scope control state, exit if in Auto mode
                adr = scp_ctrl_adr;
                tmb_vme(VME_READ,adr,sndbuf,rcvbuf,NOW);
                Auto = ((rcvbuf[0]&0xff) << 8) & (rcvbuf[1]&0xff);
                Auto = (Auto >> 5) & 0x1;
                if(Auto == 1) return;

                //Reset scope state to idle
                runstop = 0;
                ram_sel = 0;

                adr = scp_ctrl_adr ;
                wr_data = (Auto << 5) | (ram_sel << 2) | runstop;
                sndbuf[0] = (wr_data & 0xff00)>>8 ;
                sndbuf[1] = wr_data & 0x00ff ;
                tmb_vme(VME_WRITE,adr,sndbuf,rcvbuf,NOW);
                //status = tmb_vme(VME_READ,adr,sndbuf,rcvbuf,NOW);
                //printf("Scope status %04x",rd_data);

                //Select channel
                sndbuf[0] = 0x00;
                sndbuf[1] = scp_channel&0xff;
                tmb_vme(VME_WRITE,0xce,sndbuf,rcvbuf,NOW);

                //Arm scope for triggering, send scope state to wait_trig
                runstop = 1;
                adr = scp_ctrl_adr ;
                wr_data = (Auto << 5) | (ram_sel << 2) | runstop;
                sndbuf[0] = (wr_data & 0xff00)>>8 ;
                sndbuf[1] = wr_data & 0x00ff ;
                tmb_vme(VME_WRITE,adr,sndbuf,rcvbuf,NOW);
                return;
            }

            /**** scp_readout *******************************************************/

            //Exit if in Auto mode
            if(Auto == 1) return;

            //Wait for scope to trigger
            if(scp_readout) {
                for(i=1;i<100;i++) {                              //Give it time to store 255 words
                    adr = scp_ctrl_adr ;
                    tmb_vme(VME_READ,adr,sndbuf,rcvbuf,NOW);              //read scope status
                    rd_data = ((rcvbuf[0]&0xff) << 8) | (rcvbuf[1]&0xff) ;
                    printf("Scope status %04x\n",(unsigned int)rd_data);
                    if((rd_data & 0x0080) != 0) goto TRIGGERED;                    //triggered and done
                    printf("Waiting for scope to trigger %ld\n",i);
                }
                (*MyOutput_) << "Scope never triggered" << std::endl;
                //
                SendOutput("Scope never triggered");
                //
                goto END;

                //Read back embedded scope data
TRIGGERED:
                printf("Scope triggered\n");

                for(itbin=0;itbin<256;itbin++) {                    //loop over ram addresses
                    for(iram=0;iram<nrams;iram++) {
                        adr = scp_ctrl_adr ;
                        wr_data = 0x0000 | (itbin << 8) | (iram << 2) | (Auto << 5) ;             //write scope ram address
                        sndbuf[0] = (wr_data & 0xff00)>>8 ;
                        sndbuf[1] = wr_data & 0x00ff ;
                        tmb_vme(VME_WRITE,adr,sndbuf,rcvbuf,NOW);

                        adr = scp_rdata_adr ;
                        tmb_vme(VME_READ,adr,sndbuf,rcvbuf,NOW);              //read scope data at this address
                        rd_data = ((rcvbuf[0]&0xff) << 8) | (rcvbuf[1]&0xff) ;
                        scope_ram[itbin][iram] = rd_data;                  //store 16 parallel in local array
                        //printf(" 1 %3d %1d %4x %4x \n", itbin,iram,scope_ram[itbin][iram] ) ;
                    }
                }
                goto DISPLAY;

                //for(itbin=0;itbin<256;itbin++) {               //loop over ram addresses
                //for(iram=0;iram<4;iram++) {
                //  printf(" 2 %3d %1d %4x %4x \n", itbin,iram,scope_ram[itbin][iram] ) ;
                //}
                //}
            }

            /**** scp_raw_decode *************************************************/

            //Exit if not Auto mode
            if(Auto == 1) return;

            //load scope_ram from raw-hits format readout
            if(scope_raw_decode) {
                iline = 0;
                for(iram=0;iram<nrams;iram++){
                    for(iadr=0;iadr<256;iadr++) {
                        itbin = ram_sel*256 + iadr;
                        scope_ram[itbin][iram] = scp_raw_data[iline];
                        iline++;
                    }
                }
            }
            goto DISPLAY;


            /**** Display *********************************************************/

            //Construct waveform
DISPLAY:
            //
            (*MyOutput_) << "Displaying " << std::endl;
            //
            //if (!pfile) pfile = fopen("tmb_scope.txt","w");
            //
            for(ich=0;ich<128;ich++) {                      //loop over 128 scope channels
                //
                iram=ich/16;
                (*MyOutput_) << scope_tag[ich] ;
                //
                for(itbin=0;itbin<256;itbin++) {                      //256 time bins per channel
                    //
                    ibit = ((scope_ram[itbin][iram]) >> (ich%16) ) & 1; //logic levels vs tbin for this chan	      
                    if(ibit == 0) scope_ch[itbin] = "_";       //display symbol for logic 0
                    if(ibit == 1) scope_ch[itbin] = "-";       //display symbol for logic 1
                    (*MyOutput_) << scope_ch[itbin];
                    //
                    // Construct integer for special channel groups
                    //
                    if (ich == 16) first_nhit[itbin]=ibit ;
                    if (ich == 17) first_nhit[itbin]=first_nhit[itbin] | (ibit<<1);
                    if (ich == 18) first_nhit[itbin]=first_nhit[itbin] | (ibit<<2);
                    //
                    if (ich == 20) second_nhit[itbin]=ibit;
                    if (ich == 21) second_nhit[itbin]=second_nhit[itbin] | (ibit<<1);
                    if (ich == 22) second_nhit[itbin]=second_nhit[itbin] | (ibit<<2);
                    //
                    if (ich == 41) hs_thresh[itbin]=ibit ;
                    if (ich == 42) hs_thresh[itbin]=hs_thresh[itbin] | (ibit<<1) ;
                    if (ich == 43) hs_thresh[itbin]=hs_thresh[itbin] | (ibit<<2) ;
                    //
                    if (ich == 44) ds_thresh[itbin]=ibit;
                    if (ich == 45) ds_thresh[itbin]=ds_thresh[itbin] | (ibit<<1);
                    if (ich == 46) ds_thresh[itbin]=ds_thresh[itbin] | (ibit<<2);
                    //
                    if (ich == 50) buf_nbusy[itbin]=ibit ;
                    if (ich == 51) buf_nbusy[itbin]=buf_nbusy[itbin] | (ibit<<1) ;
                    if (ich == 52) buf_nbusy[itbin]=buf_nbusy[itbin] | (ibit<<2) ;
                    if (ich == 53) buf_nbusy[itbin]=buf_nbusy[itbin] | (ibit<<3) ;
                    //									  //
                    if (ich == 59) l1a_rx_cnt[itbin]=ibit;
                    if (ich == 60) l1a_rx_cnt[itbin]=l1a_rx_cnt[itbin] | (ibit<<1);
                    if (ich == 61) l1a_rx_cnt[itbin]=l1a_rx_cnt[itbin] | (ibit<<2);
                    if (ich == 62) l1a_rx_cnt[itbin]=l1a_rx_cnt[itbin] | (ibit<<3);
                    //
                    if (ich == 65) bxn[itbin]=ibit ;
                    if (ich >= 66 && ich <= 76) bxn[itbin]=bxn[itbin] | (ibit<<(ich-65)) ;
                    // 
                    if (ich == 80) dmb[itbin] = ibit ;
                    if (ich >= 81 && ich <= 95) dmb[itbin]=dmb[itbin] | (ibit<<(ich-80)) ;
                    //
                    if (ich == 96) rpc0_bxn[itbin]=ibit ;
                    if (ich == 97) rpc0_bxn[itbin]=rpc0_bxn[itbin] | (ibit << 1);
                    if (ich == 98) rpc0_bxn[itbin]=rpc0_bxn[itbin] | (ibit << 2);
                    //
                    if (ich == 99 )rpc1_bxn[itbin]=ibit;
                    if (ich == 100)rpc1_bxn[itbin]=rpc1_bxn[itbin] | (ibit << 1);
                    if (ich == 101)rpc1_bxn[itbin]=rpc1_bxn[itbin] | (ibit << 2);
                    //
                    if (ich == 102)rpc2_bxn[itbin]=ibit;
                    if (ich == 103)rpc2_bxn[itbin]=rpc2_bxn[itbin] | (ibit << 1);
                    if (ich == 104)rpc2_bxn[itbin]=rpc2_bxn[itbin] | (ibit << 2);
                    //
                    if (ich == 105)rpc3_bxn[itbin]=ibit;
                    if (ich == 106)rpc3_bxn[itbin]=rpc3_bxn[itbin] | (ibit << 1);
                    if (ich == 107)rpc3_bxn[itbin]=rpc3_bxn[itbin] | (ibit << 2);
                    //
                    if(ich == 112)rpc0_nhits[itbin]=ibit;
                    if(ich == 113)rpc0_nhits[itbin]=rpc0_nhits[itbin] | (ibit << 1);
                    if(ich == 114)rpc0_nhits[itbin]=rpc0_nhits[itbin] | (ibit << 2);
                    if(ich == 115)rpc0_nhits[itbin]=rpc0_nhits[itbin] | (ibit << 3);
                    //
                    if(ich == 116)rpc1_nhits[itbin]=ibit;
                    if(ich == 117)rpc1_nhits[itbin]=rpc1_nhits[itbin] | (ibit << 1);
                    if(ich == 118)rpc1_nhits[itbin]=rpc1_nhits[itbin] | (ibit << 2);
                    if(ich == 119)rpc1_nhits[itbin]=rpc1_nhits[itbin] | (ibit << 3);
                    //
                    if(ich == 120)rpc2_nhits[itbin]=ibit;
                    if(ich == 121)rpc2_nhits[itbin]=rpc2_nhits[itbin] | (ibit << 1);
                    if(ich == 122)rpc2_nhits[itbin]=rpc2_nhits[itbin] | (ibit << 2);
                    if(ich == 123)rpc2_nhits[itbin]=rpc2_nhits[itbin] | (ibit << 3);
                    //
                    if(ich == 124)rpc3_nhits[itbin]=ibit;
                    if(ich == 125)rpc3_nhits[itbin]=rpc3_nhits[itbin] | (ibit << 1);
                    if(ich == 126)rpc3_nhits[itbin]=rpc3_nhits[itbin] | (ibit << 2);
                    if(ich == 127)rpc3_nhits[itbin]=rpc3_nhits[itbin] | (ibit << 3);
                    //
                }  //close itbin
                //
                if (ich == 18) {
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << first_nhit[itbin] ;
                    }
                }
                if (ich == 22) {
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << second_nhit[itbin] ;
                    }
                }
                if (ich == 43) {
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << hs_thresh[itbin] ;
                    }
                }
                if (ich == 46) {
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << ds_thresh[itbin] ;
                    }
                }
                if (ich == 53) {
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << std::hex << buf_nbusy[itbin] ;
                    }
                }
                if (ich == 62) {
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << std::hex << ((l1a_rx_cnt[itbin]>>8)&0xf) ;
                    }
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << std::hex << ((l1a_rx_cnt[itbin]>>4)&0xf) ;
                    }
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << std::hex << ((l1a_rx_cnt[itbin])&0xf) ;
                    }
                }
                if (ich == 76) {
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << std::hex << ((bxn[itbin] >> 8) & 0xf) ;
                    }
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << std::hex << ((bxn[itbin] >> 4) & 0xf) ;
                    }
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << std::hex << ((bxn[itbin]) & 0xf ) ;
                    }
                }
                //
                if (ich == 95) {
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << std::hex << ((dmb[itbin] >> 12) & 0xf ) ;
                    }
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << std::hex << ((dmb[itbin] >> 8) & 0xf ) ;
                    }
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << std::hex << ((dmb[itbin] >> 4) & 0xf) ;
                    }
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << ((dmb[itbin]) & 0xf ) ;
                    }
                }
                //
                if (ich == 98 ) {
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << ((rpc0_bxn[itbin]) & 0xf ) ;
                    }
                }
                //
                if (ich == 101 ) {
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << ((rpc1_bxn[itbin]) & 0xf ) ;
                    }
                }
                //      
                if (ich == 104 ) {
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << ((rpc2_bxn[itbin]) & 0xf ) ;
                    }
                }
                //
                if (ich == 107 ) {
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << ((rpc3_bxn[itbin]) & 0xf ) ;
                    }
                }
                //
                if (ich == 115 ) {
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << ((rpc0_nhits[itbin]) & 0xf ) ;
                    }
                }
                //
                if (ich == 119 ) {
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << ((rpc1_nhits[itbin]) & 0xf ) ;
                    }
                }
                //
                if (ich == 123 ) {
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << ((rpc2_nhits[itbin]) & 0xf ) ;
                    }
                }
                //
                if (ich == 127 ) {
                    (*MyOutput_) << std::endl;
                    (*MyOutput_) << scope_tag[ich] ;
                    for(itbin=0;itbin<256;itbin++) {             //256 time bins per channel
                        (*MyOutput_) << ((rpc3_nhits[itbin]) & 0xf ) ;
                    }
                }
                //
                (*MyOutput_) << std::endl;
                //
            }    
            // JMT close the file so it actually gets all flushed
            //if (pfile) fclose(pfile);
            //
END:
            return;
        } //scope

        std::bitset<22> TMB::calCRC22(const std::vector< std::bitset<16> >& datain){
            std::bitset<22> CRC;
            CRC.reset();
            for(unsigned int i=0;i<datain.size()-4;i++){
                //    printf("Taking %d %x \n",i,(unsigned int)datain[i].to_ulong());
                CRC=nextCRC22_D16(datain[i],CRC);
            }
            return CRC;
        }


        std::bitset<22> TMB::nextCRC22_D16(const std::bitset<16>& D, 
                const std::bitset<22>& C){
            std::bitset<22> NewCRC;

            NewCRC[ 0] = D[ 0] ^ C[ 6];
            NewCRC[ 1] = D[ 1] ^ D[ 0] ^ C[ 6] ^ C[ 7];
            NewCRC[ 2] = D[ 2] ^ D[ 1] ^ C[ 7] ^ C[ 8];
            NewCRC[ 3] = D[ 3] ^ D[ 2] ^ C[ 8] ^ C[ 9];
            NewCRC[ 4] = D[ 4] ^ D[ 3] ^ C[ 9] ^ C[10];
            NewCRC[ 5] = D[ 5] ^ D[ 4] ^ C[10] ^ C[11];
            NewCRC[ 6] = D[ 6] ^ D[ 5] ^ C[11] ^ C[12];
            NewCRC[ 7] = D[ 7] ^ D[ 6] ^ C[12] ^ C[13];
            NewCRC[ 8] = D[ 8] ^ D[ 7] ^ C[13] ^ C[14];
            NewCRC[ 9] = D[ 9] ^ D[ 8] ^ C[14] ^ C[15];
            NewCRC[10] = D[10] ^ D[ 9] ^ C[15] ^ C[16];
            NewCRC[11] = D[11] ^ D[10] ^ C[16] ^ C[17];
            NewCRC[12] = D[12] ^ D[11] ^ C[17] ^ C[18];
            NewCRC[13] = D[13] ^ D[12] ^ C[18] ^ C[19];
            NewCRC[14] = D[14] ^ D[13] ^ C[19] ^ C[20];
            NewCRC[15] = D[15] ^ D[14] ^ C[20] ^ C[21];
            NewCRC[16] = D[15] ^ C[ 0] ^ C[21];
            NewCRC[17] = C[ 1];
            NewCRC[18] = C[ 2];
            NewCRC[19] = C[ 3];
            NewCRC[20] = C[ 4];
            NewCRC[21] = C[ 5];

            return NewCRC;
        }
        //
        int TMB::TestArray(){
            (*MyOutput_) << "In TestArray" << std::endl;
            int data[] = {      
                0x6b0c 
                    ,0x13e7 
                    ,0x1291 
                    ,0x135f 
                    ,0x5ba 
                    ,0x13 
                    ,0x3ec 
                    ,0x12e9 
                    ,0x402d 
                    ,0x157 
                    ,0x515 
                    ,0x29d1 
                    ,0x5125 
                    ,0x1660 
                    ,0x3aa5 
                    ,0x1700 
                    ,0x243f 
                    ,0x5d 
                    ,0x21 
                    ,0xbb9 
                    ,0x0 
                    ,0x53 
                    ,0xcff 
                    ,0x23 
                    ,0x24 
                    ,0x38ca 
                    ,0x6e0b 
                    ,0x0 
                    ,0x0 
                    ,0x0 
                    ,0x0 
                    ,0x0 
                    ,0x0 
                    ,0x100 
                    ,0x100 
                    ,0x100 
                    ,0x100 
                    ,0x100 
                    ,0x100 
                    ,0x200 
                    ,0x200 
                    ,0x200 
                    ,0x200 
                    ,0x200 
                    ,0x200 
                    ,0x300 
                    ,0x300 
                    ,0x300 
                    ,0x300 
                    ,0x300 
                    ,0x300 
                    ,0x400 
                    ,0x400 
                    ,0x400 
                    ,0x400 
                    ,0x400 
                    ,0x400 
                    ,0x500 
                    ,0x500 
                    ,0x500 
                    ,0x500 
                    ,0x500 
                    ,0x500 
                    ,0x600 
                    ,0x600 
                    ,0x600 
                    ,0x600 
                    ,0x600 
                    ,0x600 
                    ,0x1000 
                    ,0x1000 
                    ,0x1000 
                    ,0x1000 
                    ,0x1000 
                    ,0x1000 
                    ,0x1100 
                    ,0x1100 
                    ,0x1100 
                    ,0x1100 
                    ,0x1100 
                    ,0x1100 
                    ,0x1200 
                    ,0x1200 
                    ,0x1200 
                    ,0x1200 
                    ,0x1200 
                    ,0x1200 
                    ,0x1300 
                    ,0x1300 
                    ,0x1300 
                    ,0x1300 
                    ,0x1300 
                    ,0x1300 
                    ,0x1400 
                    ,0x1400 
                    ,0x1400 
                    ,0x1400 
                    ,0x1400 
                    ,0x1400 
                    ,0x1500 
                    ,0x1500 
                    ,0x1500 
                    ,0x1500 
                    ,0x1500 
                    ,0x1500 
                    ,0x1600 
                    ,0x1600 
                    ,0x1600 
                    ,0x1600 
                    ,0x1600 
                    ,0x1600 
                    ,0x2000 
                    ,0x2000 
                    ,0x2000 
                    ,0x2000 
                    ,0x2000 
                    ,0x2000 
                    ,0x2100 
                    ,0x2180 
                    ,0x2100 
                    ,0x2100 
                    ,0x2100 
                    ,0x2100 
                    ,0x2280 
                    ,0x2280 
                    ,0x2280 
                    ,0x2200 
                    ,0x2200 
                    ,0x2200 
                    ,0x2300 
                    ,0x2300 
                    ,0x2380 
                    ,0x2300 
                    ,0x2300 
                    ,0x2300 
                    ,0x2400 
                    ,0x2400 
                    ,0x2400 
                    ,0x2400 
                    ,0x2400 
                    ,0x2400 
                    ,0x2500 
                    ,0x2500 
                    ,0x2500 
                    ,0x2500 
                    ,0x2500 
                    ,0x2500 
                    ,0x2600 
                    ,0x2600 
                    ,0x2600 
                    ,0x2600 
                    ,0x2600 
                    ,0x2600 
                    ,0x3000 
                    ,0x3000 
                    ,0x3000 
                    ,0x3000 
                    ,0x3000 
                    ,0x3000 
                    ,0x3100 
                    ,0x3100 
                    ,0x3100 
                    ,0x3101 
                    ,0x3100 
                    ,0x3100 
                    ,0x3200 
                    ,0x3200 
                    ,0x3200 
                    ,0x3200 
                    ,0x3200 
                    ,0x3200 
                    ,0x3300 
                    ,0x3300 
                    ,0x3300 
                    ,0x3301 
                    ,0x3300 
                    ,0x3302 
                    ,0x3400 
                    ,0x3400 
                    ,0x3400 
                    ,0x3400 
                    ,0x3401 
                    ,0x3400 
                    ,0x3500 
                    ,0x3500 
                    ,0x3500 
                    ,0x3500 
                    ,0x3500 
                    ,0x3500 
                    ,0x3600 
                    ,0x3600 
                    ,0x3600 
                    ,0x3600 
                    ,0x3601 
                    ,0x3600 
                    ,0x4000 
                    ,0x4000 
                    ,0x4000 
                    ,0x4000 
                    ,0x4000 
                    ,0x4000 
                    ,0x4100 
                    ,0x4100 
                    ,0x4100 
                    ,0x4100 
                    ,0x4100 
                    ,0x4100 
                    ,0x4200 
                    ,0x4200 
                    ,0x4200 
                    ,0x4200 
                    ,0x4200 
                    ,0x4200 
                    ,0x4300 
                    ,0x4300 
                    ,0x4300 
                    ,0x4300 
                    ,0x4300 
                    ,0x4300 
                    ,0x4400 
                    ,0x4400 
                    ,0x4400 
                    ,0x4400 
                    ,0x4400 
                    ,0x4400 
                    ,0x4500 
                    ,0x4500 
                    ,0x4500 
                    ,0x4500 
                    ,0x4500 
                    ,0x4500 
                    ,0x4600 
                    ,0x4600 
                    ,0x4600 
                    ,0x4600 
                    ,0x4600 
                    ,0x4600 
                    ,0x6b04 
                    ,0xff 
                    ,0xf7 
                    ,0x1ff 
                    ,0xf7 
                    ,0x2ff 
                    ,0xf7 
                    ,0x3ff 
                    ,0xf7 
                    ,0x4ff 
                    ,0xf7 
                    ,0x5ff 
                    ,0xf7 
                    ,0x6ff 
                    ,0xf7 
                    ,0x10ff 
                    ,0x17ff 
                    ,0x11ff 
                    ,0x17ff 
                    ,0x12ff 
                    ,0x17ff 
                    ,0x13ff 
                    ,0x17ff 
                    ,0x14ff 
                    ,0x17ff 
                    ,0x15ff 
                    ,0x17ff 
                    ,0x16ff 
                    ,0x17ff 
                    ,0x20ff 
                    ,0x20f7 
                    ,0x21ff 
                    ,0x20f7 
                    ,0x22ff 
                    ,0x20f7 
                    ,0x23ff 
                    ,0x20f7 
                    ,0x24ff 
                    ,0x20f7 
                    ,0x25ff 
                    ,0x20f7 
                    ,0x26ff 
                    ,0x20f7 
                    ,0x30ff 
                    ,0x37ff 
                    ,0x31ff 
                    ,0x37ff 
                    ,0x32ff 
                    ,0x37ff 
                    ,0x33ff 
                    ,0x37ff 
                    ,0x34ff 
                    ,0x37ff 
                    ,0x35ff 
                    ,0x37ff 
                    ,0x36ff 
                    ,0x37ff 
                    ,0x6e04 
                    ,0x6e0c 
                    ,0xdf1a 
                    ,0xdb92 
                    ,0xde0f 
                    ,-1
            };
            std::vector < std::bitset<16> > alct_data;
            for (int i=0; data[i] != -1; i++ ) {
                alct_data.push_back((std::bitset<16>)data[i]);
            }
            int CRC_end  = alct_data.size();
            printf(" Size = %d \n",CRC_end);
            int CRC_low  = (alct_data[CRC_end-3].to_ulong()) &0x7ff ;
            int CRC_high = (alct_data[CRC_end-2].to_ulong()) &0x7ff ;
            int CRCdata  = (CRC_high<<11) | CRC_low ;
            printf(" CRC in data stream %x %x %x \n",(unsigned int)alct_data[CRC_end-3].to_ulong(),
                    (unsigned int)alct_data[CRC_end-2].to_ulong(),
                    CRCdata);
            printf(" CRC %x \n",TMBCRCcalc(alct_data));
            return 0;
        }
        //
        int TMB::TMBCRCcalc(std::vector< std::bitset <16> >& TMBData) {
            //
            std::bitset<22> CRC=calCRC22(TMBData);
            //  (*MyOutput_) << " Test here " << CRC.to_ulong() << std::endl ;
            return CRC.to_ulong();
            //
        }
        //
        void TMB::FireALCTInjector(){
            //
            tmb_vme(VME_READ, alct_inj_adr, sndbuf,rcvbuf,NOW);
            sndbuf[0] =   rcvbuf[0]&0xff ;
            sndbuf[1] =  (rcvbuf[1]&0xff) | 0x2 ;
            tmb_vme(VME_WRITE, alct_inj_adr, sndbuf,rcvbuf,NOW);
            //
        }

        void TMB::ClearALCTInjector(){
            //
            tmb_vme(VME_READ, alct_inj_adr, sndbuf,rcvbuf,NOW);
            sndbuf[0] =  (rcvbuf[0]&0xff) ;
            sndbuf[1] =  (rcvbuf[1]&0xfd) ;
            tmb_vme(VME_WRITE, alct_inj_adr, sndbuf,rcvbuf,NOW);
            //
        }

        void TMB::ClearScintillatorVeto(){
            //
            tmb_vme(VME_READ, seqmod_adr, sndbuf,rcvbuf,NOW);
            sndbuf[0] = (rcvbuf[0]&0xef) | (0x1<<4);
            sndbuf[1] =  rcvbuf[1]&0xff ;
            tmb_vme(VME_WRITE, seqmod_adr, sndbuf,rcvbuf,NOW);
            //
        }

        void TMB::FireCLCTInjector(){
            //
            tmb_vme(VME_READ, cfeb_inj_adr, sndbuf,rcvbuf,NOW);
            sndbuf[0] =  (rcvbuf[0]&0x7f) | (0x80) ;
            sndbuf[1] =  (rcvbuf[1]&0xff);
            tmb_vme(VME_WRITE, cfeb_inj_adr, sndbuf,rcvbuf,NOW);
            //
        }

        void TMB::ClearCLCTInjector(){
            //
            tmb_vme(VME_READ, cfeb_inj_adr, sndbuf,rcvbuf,NOW);
            sndbuf[0] =  (rcvbuf[0]&0x7f) ;
            sndbuf[1] =  (rcvbuf[1]&0xff);
            tmb_vme(VME_WRITE, cfeb_inj_adr, sndbuf,rcvbuf,NOW);
            //
        }



        void TMB::DisableALCTInputs(){
            //
            tmb_vme(VME_READ, alct_inj_adr, sndbuf,rcvbuf,NOW);
            sndbuf[0] =  (rcvbuf[0]&0xff) ;
            sndbuf[1] =  (rcvbuf[1]&0xfe) | (0x1);
            tmb_vme(VME_WRITE, alct_inj_adr, sndbuf,rcvbuf,NOW);
            //
        }
        //
        void TMB::DisableALCTCLCTSync(){
            //
            tmb_vme(VME_READ, alct_inj_adr, sndbuf,rcvbuf,NOW);
            sndbuf[0] =  (rcvbuf[0]&0xff) ;
            sndbuf[1] =  (rcvbuf[1]&0xfb) ;
            tmb_vme(VME_WRITE, alct_inj_adr, sndbuf,rcvbuf,NOW);
            //
        }


        //
        void TMB::DisableCLCTInputs(){
            //
            tmb_vme(VME_READ,cfeb_inj_adr,sndbuf,rcvbuf,NOW);
            sndbuf[0] = (rcvbuf[0]&0xff);
            sndbuf[1] = (rcvbuf[1]&0xe0) ;
            tmb_vme(VME_WRITE,cfeb_inj_adr,sndbuf,rcvbuf,NOW);
            //
        }
        //
        void TMB::DisableExternalCCB(){
            //
            tmb_vme(VME_READ,ccb_cfg_adr,sndbuf,rcvbuf,NOW);
            sndbuf[0] = (rcvbuf[0]&0xff);
            sndbuf[1] = (rcvbuf[1]&0xfc) | (0x3);
            tmb_vme(VME_WRITE,ccb_cfg_adr,sndbuf,rcvbuf,NOW);
            //
        }

        void TMB::EnableInternalL1aEmulator(){
            //
            tmb_vme(VME_READ,ccb_cfg_adr,sndbuf,rcvbuf,NOW);
            sndbuf[0] = (rcvbuf[0]&0xff);
            sndbuf[1] = (rcvbuf[1]&0xfb) | (0x4);
            tmb_vme(VME_WRITE,ccb_cfg_adr,sndbuf,rcvbuf,NOW);
            //
        }

        void TMB::DisableInternalL1aSequencer(){
            //
            tmb_vme(VME_READ,seq_l1a_adr,sndbuf,rcvbuf,NOW);
            sndbuf[0] = (rcvbuf[0]&0x0f);
            sndbuf[1] = (rcvbuf[1]&0xff) ;
            tmb_vme(VME_WRITE,seq_l1a_adr,sndbuf,rcvbuf,NOW);
            //
        }

        void TMB::EnableInternalL1aSequencer(){
            //
            tmb_vme(VME_READ,seq_l1a_adr,sndbuf,rcvbuf,NOW);
            sndbuf[0] = (rcvbuf[0]&0x0f) | 0x10;
            sndbuf[1] = (rcvbuf[1]&0xff) ;
            tmb_vme(VME_WRITE,seq_l1a_adr,sndbuf,rcvbuf,NOW);
            //
        }

        void TMB::EnableCLCTInputs(int CLCTInputs = 0x1f){
            //
            int adr;
            int rd_data;
            adr = cfeb_inj_adr ;
            tmb_vme(VME_READ,adr,sndbuf,rcvbuf,NOW);
            rd_data   = ((rcvbuf[0]&0xff) << 8) | (rcvbuf[1]&0xff) ;
            sndbuf[0] = rcvbuf[0];
            sndbuf[1] = (rcvbuf[1] & 0xe0) | CLCTInputs ;
            tmb_vme(VME_WRITE,adr,sndbuf,rcvbuf,NOW);
            //
        }

        void TMB::EnableL1aRequest(){
            //
            int adr;
            adr = ccb_trig_adr;
            tmb_vme(VME_READ,adr,sndbuf,rcvbuf,NOW);
            //printf(" Current %x %x \n",rcvbuf[0], rcvbuf[1]);
            //
            sndbuf[0] = rcvbuf[0];
            sndbuf[1] = 4;
            tmb_vme(VME_WRITE,adr,sndbuf,rcvbuf,NOW);
            //
            //tmb_vme(VME_READ,adr,sndbuf,rcvbuf,NOW);
            //printf(" Setting to %x %x \n",rcvbuf[0], rcvbuf[1]);
            //
        }
        //
        void TMB::DisableL1aRequest(){
            //
            int adr = ccb_trig_adr;
            tmb_vme(VME_READ,adr,sndbuf,rcvbuf,NOW);
            //printf(" Current %x %x \n",rcvbuf[0], rcvbuf[1]);
            //
            sndbuf[0] = rcvbuf[0];
            sndbuf[1] = 0;
            tmb_vme(VME_WRITE,adr,sndbuf,rcvbuf,NOW);
            //
            //tmb_vme(VME_READ,adr,sndbuf,rcvbuf,NOW);
            //printf(" Setting to %x %x \n",rcvbuf[0], rcvbuf[1]);
            //
        }
        //
        ////////////////////////////////////////////////////
        // ALCT and TMB data from VME reads
        ////////////////////////////////////////////////////
        void TMB::TMBRawhits() {
            TMBRawhits(100000);
            return;
        }
        //
        void TMB::TMBRawhits(int microseconds_between_data_reads){
            //
            bool read_ok = false;
            //
            int max_number_of_times = 10;  //prevent going into an infinite loop
            int number_of_reads = 0;
            //
            while (!read_ok && (number_of_reads<max_number_of_times) ) {
                //
                number_of_reads++;
                //
                //pretrigger and halt until next unhalt arrives:
                SetPretriggerHalt(1);
                WriteRegister(seq_clct_adr);
                ::usleep(microseconds_between_data_reads);   // Give the chamber time to trigger on and read an event
                //
                // Attempt to read the data:
                ResetRAMAddress();
                read_ok = ReadTMBRawhits_();   //check to see that pretrigger made a L1A -> read out...
                //
                // Pretrigger unhalt, go back to normal data taking:
                SetPretriggerHalt(0);
                WriteRegister(seq_clct_adr);
                ::usleep(10000);
            }
            //
            if (number_of_reads >= max_number_of_times) 
                (*MyOutput_) << "TMB read " << std::dec << number_of_reads << " times with no data..." << std::endl;
            //
            return;
        }
        //
        void TMB::ResetRAMAddress(){
            //
            //Clear RAM address for next event
            //
            WriteRegister(dmb_ram_adr,0x2000); //reset RAM write address
            WriteRegister(dmb_ram_adr,0x0000); //unreset
            //
            return;
        }
        //
        bool TMB::ReadTMBRawhits_(){
            //
            tmb_data_.clear();
            //
            // Check state machine, is it halted while we extract the data?
            //
            ReadRegister(seq_clct_adr);
            int halt_state = GetReadPretriggerHalt();
            if (debug_) (*MyOutput_) << "TMB halt_state before read RAM = " << halt_state << std::endl;
            //
            if (!halt_state) {
                (*MyOutput_) << "ERROR:  TMB not halted.  halt_state before read RAM = " << halt_state << std::endl;
                return false;
            }
            //
            int dmb_busy  = 1;
            dmb_wordcount_ = 0;
            //
            // Probe the RAM to see if there is data.  If there is nothing after a few attempts, try again...
            //
            const int max_number_of_tries = 5;
            int number_of_tries = 0;
            //
            while( ((dmb_busy) || (dmb_wordcount_ <= 0)) && (number_of_tries < max_number_of_tries) ) {
                //
                number_of_tries++;
                //
                int rd_data = ReadRegister(dmb_wdcnt_adr);
                dmb_wordcount_   = rd_data & 0x0fff;
                dmb_busy    = (rd_data>>14) & 0x1;  
                //
                //(*MyOutput_) << "Try to get TMB data through VME " << std::dec << number_of_tries << " times" << std::endl;
                //(*MyOutput_) << "DMB busy       = " << dmb_busy << std::endl;
                //(*MyOutput_) << "DMB word count = " << std::dec << dmb_wordcount_ << std::endl;
            }
            //
            if (number_of_tries >= max_number_of_tries) {
                if (debug_) (*MyOutput_) << "DMB word count=0 or DMB busy "<< std::dec << number_of_tries << " times..." << std::endl;
                return false;
            } else {
                if (debug_) (*MyOutput_) << "Got TMB data on the " << std::dec << number_of_tries << " time" << std::endl;
            }
            // Get the data:
            for(int i=0; i<dmb_wordcount_; i++) {
                //
                //Write RAM read address
                int address = (i & 0xFFFF);
                WriteRegister(dmb_ram_adr,address);
                //    
                //Read RAM data
                int dmb_rdata = ReadRegister(dmb_rdata_adr);
                //
                tmb_data_.push_back((std::bitset<16>) dmb_rdata);
                if (debug_) (*MyOutput_) << "Address = " << std::dec << i << ", data = " << std::hex << dmb_rdata << std::endl;
            }
            //
            if (debug_) (*MyOutput_) << "Total number of words read = " << std::dec << tmb_data_.size() << std::endl;
            //
            // Determine the CRC to see if we've extracted the data correctly, among other possibilities
            int CRC_end  = tmb_data_.size();
            int CRC_low  = (tmb_data_[CRC_end-4].to_ulong()) &0x7ff;
            int CRC_high = (tmb_data_[CRC_end-3].to_ulong()) &0x7ff;
            //
            int CRCdata  = (CRC_high<<11) | CRC_low;
            int CRCcalc = TMBCRCcalc(tmb_data_);
            //
            int dataOK = compareValues("TMB CRC", CRCcalc, CRCdata);
            //
            if (dataOK) {
                if (debug_) (*MyOutput_) << "CRC OK..." << std::endl;
                DecodeTMBRawHits_();
            } else {
                (*MyOutput_) << "CRC not OK..." << std::endl;
            }
            //
            return dataOK;
        }
        //
        void TMB::ALCTRawhits() {
            //   
            bool read_ok = false;
            //
            int max_number_of_times = 10;  //prevent going into an infinite loop
            int number_of_reads = 0;
            //
            while (!read_ok && (number_of_reads<max_number_of_times) ) {
                //
                number_of_reads++;
                //
                //pretrigger and halt until next unhalt arrives:
                //    if (debug_) std::cout << "TMB:  Halt pretrigger" << std::endl;
                //    SetPretriggerHalt(1);
                //    WriteRegister(seq_clct_adr);
                //    ::sleep(100000);   // Give the chamber time to trigger on and read an event
                //
                // Attempt to read the data:
                read_ok = ReadALCTRawhits_();   //check to see that pretrigger made a L1A -> read out...
                //
                // Pretrigger unhalt, go back to normal data taking:
                //    if (debug_) std::cout << "TMB:  Unhalt pretrigger" << std::endl;
                //    SetPretriggerHalt(0);
                //    WriteRegister(seq_clct_adr);
                //    ::usleep(10000);
            }
            //
            if (number_of_reads >= max_number_of_times) 
                (*MyOutput_) << "TMB read ALCT " << std::dec << number_of_reads << " times with no data..." << std::endl;
            //
            return;
        }
        //
        bool TMB::ReadALCTRawhits_() {
            //
            const int max_number_of_waits_for_busy = 20;
            //
            ReadRegister(seq_clct_adr);
            int halt_state = GetReadPretriggerHalt();
            if (debug_) std::cout << "TMB:  TMB halt_state before read ALCT raw hits RAM = " << halt_state << std::endl;
            //
            //  if (!halt_state) {
            //    std::cout << "ERROR:  TMB not halted.  halt_state before read ALCT raw hits RAM = " << halt_state << std::endl;
            //    return false;
            //  }
            //
            if (!CheckAlctFIFOBusy(max_number_of_waits_for_busy)) {
                std::cout << "TMB:  At beginning of ReadALCTRawHits(),  ALCT FIFO Busy " << max_number_of_waits_for_busy << " times... " << std::endl;
                std::cout << "..... aborting" << std::endl;
                return false;
            }
            //
            int data = ReadRegister(alct_fifo_adr);
            if (debug_) (*MyOutput_) << "Register 0x3E -> Read=0x" << std::hex << data << std::endl;
            //
            int alct_wdcnt = GetReadAlctRawWordCount();
            if (debug_) (*MyOutput_) << "Number of raw words =" << std::dec << alct_wdcnt << std::endl;
            //
            if (alct_wdcnt == 0) {
                if (debug_) std::cout << "Try again" << std::endl;
                return false;
            }
            //
            for(int i=0;i<alct_wdcnt;i++) {
                //
                //Write RAM read address to TMB
                SetAlctDemuxMode(RAM_DATA);         //set to enable alctfifo2 address to contain raw hits
                SetAlctRawReadAddress(i);
                WriteRegister(alctfifo1_adr);
                int data = ReadRegister(alctfifo1_adr);
                //    if (debug_) (*MyOutput_) << "Register ALCTFIFO1 ADR -> Read=" << std::hex << data << std::endl;
                //
                //Read RAM data from TMB...
                //
                // Least Significant Bits:
                data = ReadRegister(alctfifo2_adr);
                long int alct_rdata = (GetReadAlctRawDataLeastSignificantBits() & 0xffff);
                //    if (debug_) (*MyOutput_) << "Register 0xAA -> Read=" << std::hex << data << std::endl;
                //
                // Add on the most significant bits:
                data = ReadRegister(alct_fifo_adr);
                //    if (debug_) (*MyOutput_) << "Register 0x3E -> Read=" << std::hex << data << std::endl;
                alct_rdata |= ( (GetReadAlctRawDataMostSignificantBits()&0x3) << 16 );
                //
                (*MyOutput_) << "Adr=" << std::dec << std::setw(4) << i 
                    << ", Data=0x" << std::hex 
                    << ((alct_rdata>>16)&0xf) 
                    << ((alct_rdata>>12)&0xf) 
                    << ((alct_rdata>> 8)&0xf) 
                    << ((alct_rdata>> 4)&0xf) 
                    << ((alct_rdata>> 0)&0xf)
                    << std::endl;
                if (debug_) 
                    std::cout << "Adr=" << std::dec << std::setw(4) << i 
                        << ", Data=" << std::hex 
                        << ((alct_rdata>>16)&0xf) 
                        << ((alct_rdata>>12)&0xf) 
                        << ((alct_rdata>> 8)&0xf) 
                        << ((alct_rdata>> 4)&0xf) 
                        << ((alct_rdata>> 0)&0xf)
                        << std::endl;
                //
                //alct_data.push_back((std::bitset<16>)alct_rdata);
            }
            //
            //  if ( alct_wdcnt > 0 ) {
            //    
            //    printf("The size is %d\n",alct_data.size());
            //	
            //    int CRC_end  = alct_data.size();
            //    int CRC_low  = (alct_data[CRC_end-4].to_ulong()) &0x7ff ;
            //    int CRC_high = (alct_data[CRC_end-3].to_ulong()) &0x7ff ;
            //    int CRCdata  = (CRC_high<<11) | CRC_low ;
            //    
            //    int CRCcalc = TMBCRCcalc(alct_data) ;
            //    
            //    printf(" CRC %x \n",CRCcalc);
            //    printf(" CRC in data stream %lx %lx %x \n",alct_data[CRC_end-4].to_ulong(),
            //	   alct_data[CRC_end-3].to_ulong(),CRCdata);
            //	 
            //    if ( CRCcalc != CRCdata ) {
            //      printf("ALCT CRC doesn't agree \n");
            //    } else {
            //      printf("ALCT CRC does    agree \n");
            //    }
            //
            //}
            //
            //  alct_data.clear();
            //
            return true;
        }
        //
        bool TMB::ResetALCTRAMAddress(){
            //
            //Clear RAM address
            //
            if (debug_) std::cout << "Reset ALCTRAMAddress" << std::endl;
            //
            const int maximum_number_of_allowed_busies = 20;
            //
            if (!CheckAlctFIFOBusy(maximum_number_of_allowed_busies)) {
                std::cout << "TMB:  At beginning of ResetALCTRAMAddress(),  ALCT FIFO Busy " << maximum_number_of_allowed_busies << " times... " << std::endl;
                std::cout << "..... aborting" << std::endl;
                return false;
            }
            //
            //reset ALCT raw hits FIFO controller:
            SetAlctRawReset(1);
            WriteRegister(alctfifo1_adr);
            //
            if (!CheckAlctFIFOBusy(maximum_number_of_allowed_busies)) {
                std::cout << "TMB:  After resetting ALCT FIFO controller,  ALCT FIFO Busy " << maximum_number_of_allowed_busies << " times... " << std::endl;
                std::cout << "..... aborting" << std::endl;
                return false;
            }
            //
            //unreset ALCT raw hits FIFO controller:
            SetAlctRawReset(0);
            WriteRegister(alctfifo1_adr);
            //
            if (!CheckAlctFIFOBusy(maximum_number_of_allowed_busies)) {
                std::cout << "TMB:  After unresetting ALCT FIFO controller,  ALCT FIFO Busy " << maximum_number_of_allowed_busies << " times... " << std::endl;
                std::cout << "..... aborting" << std::endl;
                return false;
            }
            //
            return true;
        }
        //
        //
        bool TMB::CheckAlctFIFOBusy(int number_of_checks_before_aborting) {
            //
            int number_of_checks = 0;
            //
            int data = ReadRegister(alct_fifo_adr);
            if (debug_) std::cout << "CheckAlctFIFOBusy:  TMB register 0x3E = " << std::hex << data << std::endl;
            //
            while ( GetReadAlctRawBusy() != 0 && 
                    GetReadAlctRawDone() != 1 && 
                    number_of_checks < number_of_checks_before_aborting ){
                //
                if (debug_) std::cout << "TMB:  ALCT raw hits FIFO busy writing ALCT data... " << number_of_checks << " times" << std::endl;
                //
                data = ReadRegister(alct_fifo_adr);
                if (debug_) std::cout << "CheckAlctFIFOBusy:  TMB register 0x3E = " << std::hex << data << std::endl;
                //
                number_of_checks++;
            }
            //
            if (number_of_checks < number_of_checks_before_aborting) {
                if (debug_) std::cout << "CheckAlctFIFOBusy:  Not busy, continuing..." << std::endl;
                return true;
            } else {
                if (debug_) std::cout << "CheckAlctFIFOBusy:  BUSY, should abort..." << std::endl;
                return false;
            }
        }
        //
        //
        void TMB::DecodeTMBRawHits_() {
            //
            for (int word_count=0; word_count<dmb_wordcount_; word_count++) 
                DecodeTMBRawHitWord_(word_count);
            //
            return;
        }
        //
        void TMB::DecodeTMBRawHitWord_(int address) {
            //
            int data = tmb_data_[address].to_ulong();
            //
            if (address == 0) {
                h0_beginning_of_cathode_ = ExtractValueFromData(data ,h0_beginning_of_cathode_lo_bit ,h0_beginning_of_cathode_hi_bit );
                h0_marker_6_             = ExtractValueFromData(data ,h0_marker_6_lo_bit             ,h0_marker_6_hi_bit             );
                //
            } else if (address == 1) { 
                h1_nTbins_per_cfeb_ = ExtractValueFromData(data ,h1_nTbins_per_cfeb_lo_bit ,h1_nTbins_per_cfeb_hi_bit );
                h1_cfebs_read_      = ExtractValueFromData(data ,h1_cfebs_read_lo_bit      ,h1_cfebs_read_hi_bit      );
                h1_fifo_mode_       = ExtractValueFromData(data ,h1_fifo_mode_lo_bit       ,h1_fifo_mode_hi_bit       );
                //
            } else if (address == 2) { 
                h2_l1a_counter_ = ExtractValueFromData(data ,h2_l1a_counter_lo_bit ,h2_l1a_counter_hi_bit );
                h2_csc_id_      = ExtractValueFromData(data ,h2_csc_id_lo_bit      ,h2_csc_id_hi_bit      );
                h2_board_id_    = ExtractValueFromData(data ,h2_board_id_lo_bit    ,h2_board_id_hi_bit    );
                h2_l1a_type_    = ExtractValueFromData(data ,h2_l1a_type_lo_bit    ,h2_l1a_type_hi_bit    );
                //
            } else if (address == 3) { 
                h3_bxn_counter_   = ExtractValueFromData(data ,h3_bxn_counter_lo_bit   ,h3_bxn_counter_hi_bit   );
                h3_record_type_   = ExtractValueFromData(data ,h3_record_type_lo_bit   ,h3_record_type_hi_bit   );
                h3_scope_in_data_ = ExtractValueFromData(data ,h3_scope_in_data_lo_bit ,h3_scope_in_data_hi_bit );
                //
            } else if (address == 4) { 
                h4_nheader_words_   = ExtractValueFromData(data ,h4_nheader_words_lo_bit   ,h4_nheader_words_hi_bit   );
                h4_nCFEBs_read_     = ExtractValueFromData(data ,h4_nCFEBs_read_lo_bit     ,h4_nCFEBs_read_hi_bit     );
                h4_has_buffer_data_ = ExtractValueFromData(data ,h4_has_buffer_data_lo_bit ,h4_has_buffer_data_hi_bit );
                h4_fifo_pretrig_    = ExtractValueFromData(data ,h4_fifo_pretrig_lo_bit    ,h4_fifo_pretrig_hi_bit    );
                //
            } else if (address == 5) { 
                h5_l1a_at_pretrig_                   = ExtractValueFromData(data ,h5_l1a_at_pretrig_lo_bit                   ,h5_l1a_at_pretrig_hi_bit                   );
                h5_trigger_source_vector_            = ExtractValueFromData(data ,h5_trigger_source_vector_lo_bit            ,h5_trigger_source_vector_hi_bit            );
                h5_trigger_source_halfstrip_distrip_ = ExtractValueFromData(data ,h5_trigger_source_halfstrip_distrip_lo_bit ,h5_trigger_source_halfstrip_distrip_hi_bit );
                //
            } else if (address == 6) { 
                h6_aff_to_dmb_  = ExtractValueFromData(data ,h6_aff_to_dmb_lo_bit  ,h6_aff_to_dmb_hi_bit  );
                h6_cfeb_exists_ = ExtractValueFromData(data ,h6_cfeb_exists_lo_bit ,h6_cfeb_exists_hi_bit );
                h6_run_info_    = ExtractValueFromData(data ,h6_run_info_lo_bit    ,h6_run_info_hi_bit    );
                //
            } else if (address == 7) { 
                h7_bxn_at_clct_pretrig_ = ExtractValueFromData(data ,h7_bxn_at_clct_pretrig_lo_bit ,h7_bxn_at_clct_pretrig_hi_bit );
                h7_sync_err_            = ExtractValueFromData(data ,h7_sync_err_lo_bit            ,h7_sync_err_hi_bit            );
                //
            } else if (address == 8) { 
                h8_clct0_lsbs_ = ExtractValueFromData(data ,h8_clct0_lsbs_lo_bit ,h8_clct0_lsbs_hi_bit );
                //
            } else if (address == 9) { 
                h9_clct1_lsbs_ = ExtractValueFromData(data ,h9_clct1_lsbs_lo_bit ,h9_clct1_lsbs_hi_bit );
                //
            } else if (address == 10) { 
                h10_clct0_msbs_            = ExtractValueFromData(data ,h10_clct0_msbs_lo_bit            ,h10_clct0_msbs_hi_bit            );
                h10_clct1_msbs_            = ExtractValueFromData(data ,h10_clct1_msbs_lo_bit            ,h10_clct1_msbs_hi_bit            );
                h10_clct0_invalid_pattern_ = ExtractValueFromData(data ,h10_clct0_invalid_pattern_lo_bit ,h10_clct0_invalid_pattern_hi_bit );
                //
            } else if (address == 11) {
                h11_alct_clct_match_           = ExtractValueFromData(data ,h11_alct_clct_match_lo_bit           ,h11_alct_clct_match_hi_bit           );
                h11_alct_trig_only_            = ExtractValueFromData(data ,h11_alct_trig_only_lo_bit            ,h11_alct_trig_only_hi_bit            );
                h11_clct_trig_only_            = ExtractValueFromData(data ,h11_clct_trig_only_lo_bit            ,h11_clct_trig_only_hi_bit            );
                h11_clct0_alct_bxn_diff_       = ExtractValueFromData(data ,h11_clct0_alct_bxn_diff_lo_bit       ,h11_clct0_alct_bxn_diff_hi_bit       );
                h11_clct1_alct_bxn_diff_       = ExtractValueFromData(data ,h11_clct1_alct_bxn_diff_lo_bit       ,h11_clct1_alct_bxn_diff_hi_bit       );
                h11_alct_in_clct_match_window_ = ExtractValueFromData(data ,h11_alct_in_clct_match_window_lo_bit ,h11_alct_in_clct_match_window_hi_bit );
                h11_triad_persistence_         = ExtractValueFromData(data ,h11_triad_persistence_lo_bit         ,h11_triad_persistence_hi_bit         );
                //
            } else if (address == 12) { 
                h12_mpc0_frame0_lsbs_ = ExtractValueFromData(data ,h12_mpc0_frame0_lsbs_lo_bit ,h12_mpc0_frame0_lsbs_hi_bit );
                //
            } else if (address == 13) { 
                h13_mpc0_frame1_lsbs_ = ExtractValueFromData(data ,h13_mpc0_frame1_lsbs_lo_bit ,h13_mpc0_frame1_lsbs_hi_bit );
                //
            } else if (address == 14) { 
                h14_mpc1_frame0_lsbs_ = ExtractValueFromData(data ,h14_mpc1_frame0_lsbs_lo_bit ,h14_mpc1_frame0_lsbs_hi_bit );
                //
            } else if (address == 15) { 
                h15_mpc1_frame1_lsbs_ = ExtractValueFromData(data ,h15_mpc1_frame1_lsbs_lo_bit ,h15_mpc1_frame1_lsbs_hi_bit );
                //
            } else if (address == 16) { 
                h16_mpc0_frame0_msbs_              = ExtractValueFromData(data ,h16_mpc0_frame0_msbs_lo_bit              ,h16_mpc0_frame0_msbs_hi_bit              );
                h16_mpc0_frame1_msbs_              = ExtractValueFromData(data ,h16_mpc0_frame1_msbs_lo_bit              ,h16_mpc0_frame1_msbs_hi_bit              );
                h16_mpc1_frame0_msbs_              = ExtractValueFromData(data ,h16_mpc1_frame0_msbs_lo_bit              ,h16_mpc1_frame0_msbs_hi_bit              );
                h16_mpc1_frame1_msbs_              = ExtractValueFromData(data ,h16_mpc1_frame1_msbs_lo_bit              ,h16_mpc1_frame1_msbs_hi_bit              );
                h16_mpc_accept_                    = ExtractValueFromData(data ,h16_mpc_accept_lo_bit                    ,h16_mpc_accept_hi_bit                    );
                h16_clct_halfstrip_pretrig_thresh_ = ExtractValueFromData(data ,h16_clct_halfstrip_pretrig_thresh_lo_bit ,h16_clct_halfstrip_pretrig_thresh_hi_bit );
                h16_clct_distrip_pretrig_thresh_   = ExtractValueFromData(data ,h16_clct_distrip_pretrig_thresh_lo_bit   ,h16_clct_distrip_pretrig_thresh_hi_bit   );
                //
            } else if (address == 17) { 
                h17_write_buffer_ready_     = ExtractValueFromData(data ,h17_write_buffer_ready_lo_bit     ,h17_write_buffer_ready_hi_bit     );
                h17_pretrig_tbin_           = ExtractValueFromData(data ,h17_pretrig_tbin_lo_bit           ,h17_pretrig_tbin_hi_bit           );
                h17_write_buffer_address_   = ExtractValueFromData(data ,h17_write_buffer_address_lo_bit   ,h17_write_buffer_address_hi_bit   );
                h17_pretrig_no_free_buffer_ = ExtractValueFromData(data ,h17_pretrig_no_free_buffer_lo_bit ,h17_pretrig_no_free_buffer_hi_bit );
                h17_buffer_full_            = ExtractValueFromData(data ,h17_buffer_full_lo_bit            ,h17_buffer_full_hi_bit            );
                h17_buffer_almost_full_     = ExtractValueFromData(data ,h17_buffer_almost_full_lo_bit     ,h17_buffer_almost_full_hi_bit     );
                h17_buffer_half_full_       = ExtractValueFromData(data ,h17_buffer_half_full_lo_bit       ,h17_buffer_half_full_hi_bit       );
                h17_buffer_empty_           = ExtractValueFromData(data ,h17_buffer_empty_lo_bit           ,h17_buffer_empty_hi_bit           );
                //
            } else if (address == 18) { 
                h18_nbuf_busy_          = ExtractValueFromData(data ,h18_nbuf_busy_lo_bit          ,h18_nbuf_busy_hi_bit          );
                h18_buf_busy_           = ExtractValueFromData(data ,h18_buf_busy_lo_bit           ,h18_buf_busy_hi_bit           );
                h18_l1a_stack_overflow_ = ExtractValueFromData(data ,h18_l1a_stack_overflow_lo_bit ,h18_l1a_stack_overflow_hi_bit );
                //
            } else if (address == 19) { 
                h19_tmb_trig_pulse_         = ExtractValueFromData(data ,h19_tmb_trig_pulse_lo_bit         ,h19_tmb_trig_pulse_hi_bit         );
                h19_tmb_alct_only_          = ExtractValueFromData(data ,h19_tmb_alct_only_lo_bit          ,h19_tmb_alct_only_hi_bit          );
                h19_tmb_clct_only_          = ExtractValueFromData(data ,h19_tmb_clct_only_lo_bit          ,h19_tmb_clct_only_hi_bit          );
                h19_tmb_match_              = ExtractValueFromData(data ,h19_tmb_match_lo_bit              ,h19_tmb_match_hi_bit              );
                h19_write_buffer_ready_     = ExtractValueFromData(data ,h19_write_buffer_ready_lo_bit     ,h19_write_buffer_ready_hi_bit     );
                h19_write_buffer_available_ = ExtractValueFromData(data ,h19_write_buffer_available_lo_bit ,h19_write_buffer_available_hi_bit );
                h19_write_tbin_address_     = ExtractValueFromData(data ,h19_write_tbin_address_lo_bit     ,h19_write_tbin_address_hi_bit     );
                h19_write_buffer_address_   = ExtractValueFromData(data ,h19_write_buffer_address_lo_bit   ,h19_write_buffer_address_hi_bit   );
                //
            } else if (address == 20) { 
                h20_discard_no_write_buf_available_ = ExtractValueFromData(data ,h20_discard_no_write_buf_available_lo_bit ,h20_discard_no_write_buf_available_hi_bit );
                h20_discard_invalid_pattern_        = ExtractValueFromData(data ,h20_discard_invalid_pattern_lo_bit        ,h20_discard_invalid_pattern_hi_bit        );
                h20_discard_tmb_reject_             = ExtractValueFromData(data ,h20_discard_tmb_reject_lo_bit             ,h20_discard_tmb_reject_hi_bit             );
                h20_timeout_no_tmb_trig_pulse_      = ExtractValueFromData(data ,h20_timeout_no_tmb_trig_pulse_lo_bit      ,h20_timeout_no_tmb_trig_pulse_hi_bit      );
                h20_timeout_no_mpc_frame_           = ExtractValueFromData(data ,h20_timeout_no_mpc_frame_lo_bit           ,h20_timeout_no_mpc_frame_hi_bit           );
                h20_timeout_no_mpc_response_        = ExtractValueFromData(data ,h20_timeout_no_mpc_response_lo_bit        ,h20_timeout_no_mpc_response_hi_bit        );
                //
            } else if (address == 21) { 
                h21_match_trig_alct_delay_   = ExtractValueFromData(data ,h21_match_trig_alct_delay_lo_bit   ,h21_match_trig_alct_delay_hi_bit   );
                h21_match_trig_window_width_ = ExtractValueFromData(data ,h21_match_trig_window_width_lo_bit ,h21_match_trig_window_width_hi_bit );
                h21_mpc_tx_delay_            = ExtractValueFromData(data ,h21_mpc_tx_delay_lo_bit            ,h21_mpc_tx_delay_hi_bit            );
                //
            } else if (address == 22) {
                h22_rpc_exist_       = ExtractValueFromData(data ,h22_rpc_exist_lo_bit       ,h22_rpc_exist_hi_bit       );
                h22_rpc_list_        = ExtractValueFromData(data ,h22_rpc_list_lo_bit        ,h22_rpc_list_hi_bit        );
                h22_nrpc_            = ExtractValueFromData(data ,h22_nrpc_lo_bit            ,h22_nrpc_hi_bit            );
                h22_rpc_read_enable_ = ExtractValueFromData(data ,h22_rpc_read_enable_lo_bit ,h22_rpc_read_enable_hi_bit );
                h22_nlayers_hit_     = ExtractValueFromData(data ,h22_nlayers_hit_lo_bit     ,h22_nlayers_hit_hi_bit     );
                h22_l1a_in_window_   = ExtractValueFromData(data ,h22_l1a_in_window_lo_bit   ,h22_l1a_in_window_hi_bit   );
                //
            } else if (address == 23) { 
                h23_board_status_ = ExtractValueFromData(data ,h23_board_status_lo_bit ,h23_board_status_hi_bit );
                //
            } else if (address == 24) { 
                h24_time_since_hard_reset_ = ExtractValueFromData(data ,h24_time_since_hard_reset_lo_bit ,h24_time_since_hard_reset_hi_bit );
                //
            } else if (address == 25) { 
                h25_firmware_version_date_code_ = ExtractValueFromData(data ,h25_firmware_version_date_code_lo_bit ,h25_firmware_version_date_code_hi_bit );
                //
            }
            //
            return;
        }
        //
        void TMB::PrintTMBRawHits() {
            //
            (*MyOutput_) << "Header 0:" << std::endl;
            (*MyOutput_) << "-> beginning of cathode record marker = " << h0_beginning_of_cathode_ << std::endl;
            (*MyOutput_) << "-> marker 6                           = " << h0_marker_6_             << std::endl;
            //
            (*MyOutput_) << "Header 1:" << std::endl;
            (*MyOutput_) << "-> number of time bins per CFEB in dump                = " << h1_nTbins_per_cfeb_ << std::endl;
            (*MyOutput_) << "-> CFEBs read out for this event                       = " << h1_cfebs_read_      << std::endl;
            (*MyOutput_) << "-> fifo mode                                           = " << h1_fifo_mode_       << std::endl;
            //
            (*MyOutput_) << "Header 2:" << std::endl;
            (*MyOutput_) << "-> L1A received and pushed on L1A stack                = " << h2_l1a_counter_ << std::endl;
            (*MyOutput_) << "-> Chamber ID number (= slot/2 or slot/2-1 if slot>12) = " << h2_csc_id_      << std::endl;
            (*MyOutput_) << "-> module ID number (= VME slot)                       = " << h2_board_id_    << std::endl;
            (*MyOutput_) << "-> L1A pop type mode                                   = " << h2_l1a_type_;
            if (h2_l1a_type_ == 0) {
                (*MyOutput_) << " = Normal CLCT trigger with buffer data and L1A window match" << std::endl;
            } else if (h2_l1a_type_ == 1) {
                (*MyOutput_) << " = ALCT-only trigger, no data buffers" << std::endl;
            } else if (h2_l1a_type_ == 2) {
                (*MyOutput_) << " = L1A-only, no matching TMB trigger, no buffer data" << std::endl;
            } else if (h2_l1a_type_ == 3) {
                (*MyOutput_) << " = TMB triggered, no L1A-window match, event has buffer data" << std::endl;
            }
            //
            (*MyOutput_) << "Header 3:" << std::endl;  
            (*MyOutput_) << "-> Bunch-crossing number pushed on L1A stack on L1A arrival = " << h3_bxn_counter_ << std::endl;
            (*MyOutput_) << "-> Record type = " << h3_record_type_;
            if (h3_record_type_ == 0 ) {
                (*MyOutput_) << " = No rawhits, full header" << std::endl;
            } else if (h3_record_type_ == 1 ) {
                (*MyOutput_) << " = Full rawhits, full header" << std::endl;
            } else if (h3_record_type_ == 2 ) {
                (*MyOutput_) << " = Local rawhits, full header" << std::endl;
            } else if (h3_record_type_ == 3 ) {
                (*MyOutput_) << " = No rawhits, short header (no buffer available at pretrigger)" << std::endl;
            }
            (*MyOutput_) << "-> internal logic analyzer scope data included in readout = 0x " << std::hex << h3_scope_in_data_ << std::endl;
            //
            (*MyOutput_) << "Header 4:" << std::endl;  
            (*MyOutput_) << "-> Number of header words                        = 0x " << std::hex << h4_nheader_words_   << std::endl;
            (*MyOutput_) << "-> Number of CFEBs readout                       = 0x " << std::hex << h4_nCFEBs_read_     << std::endl;
            (*MyOutput_) << "-> Number of CFEBs readout                       = 0x " << std::hex << h4_has_buffer_data_ << std::endl;
            (*MyOutput_) << "-> Number time bins in readout before pretrigger = 0x " << std::hex << h4_fifo_pretrig_    << std::endl;
            //
            (*MyOutput_) << "Header 5:" << std::endl;  
            (*MyOutput_) << "-> L1A number at CLCT pretrigger       = 0x " << std::hex << h5_l1a_at_pretrig_                   << std::endl;
            (*MyOutput_) << "-> trigger source vector               = 0x " << std::hex << h5_trigger_source_vector_            << std::endl;
            (*MyOutput_) << "-> trigger source halfstrip or distrip = 0x " << std::hex << h5_trigger_source_halfstrip_distrip_ << std::endl;
            //
            (*MyOutput_) << "Header 6:" << std::endl;  
            (*MyOutput_) << "-> Active CFEB list sent to DMB = 0x " << std::hex << h6_aff_to_dmb_  << std::endl;
            (*MyOutput_) << "-> List of instantiated CFEBs   = 0x " << std::hex << h6_cfeb_exists_ << std::endl;
            (*MyOutput_) << "-> Run info                     = 0x " << std::hex << h6_run_info_    << std::endl;
            //
            (*MyOutput_) << "Header 7:" << std::endl;  
            (*MyOutput_) << "-> bunch crossing number at CLCT pretrigger    = 0x " << std::hex << h7_bxn_at_clct_pretrig_ << std::endl;
            (*MyOutput_) << "-> bunch crossing number synchronization error = 0x " << std::hex << h7_sync_err_            << std::endl;
            //
            (*MyOutput_) << "Header 8:" << std::endl;  
            (*MyOutput_) << "-> CLCT0 pattern trigger (after drift) LSBS = 0x " << std::hex << h8_clct0_lsbs_ << std::endl;
            //
            (*MyOutput_) << "Header 9:" << std::endl;  
            (*MyOutput_) << "-> CLCT1 pattern trigger (after drift) LSBS = 0x " << std::hex << h9_clct1_lsbs_ << std::endl;
            //
            (*MyOutput_) << "Header 10:" << std::endl;  
            (*MyOutput_) << "-> CLCT0 pattern trigger (after drift) MSBS = 0x " << std::hex << h10_clct0_msbs_            << std::endl;
            (*MyOutput_) << "-> CLCT1 pattern trigger (after drift) MSBS = 0x " << std::hex << h10_clct1_msbs_            << std::endl;
            (*MyOutput_) << "-> CLCT0 had invalid pattern after drift    = 0x " << std::hex << h10_clct0_invalid_pattern_ << std::endl;
            //
            (*MyOutput_) << "Header 11:" << std::endl;  
            (*MyOutput_) << "-> ALCT and CLCT matched in time         = 0x " << std::hex << h11_alct_clct_match_           << std::endl;
            (*MyOutput_) << "-> ALCT trigger only                     = 0x " << std::hex << h11_alct_trig_only_            << std::endl;
            (*MyOutput_) << "-> CLCT trigger only                     = 0x " << std::hex << h11_clct_trig_only_            << std::endl;
            (*MyOutput_) << "-> ALCT-CLCT0 bunch crossing difference  = 0x " << std::hex << h11_clct0_alct_bxn_diff_       << std::endl;
            (*MyOutput_) << "-> ALCT-CLCT1 bunch crossing difference  = 0x " << std::hex << h11_clct1_alct_bxn_diff_       << std::endl;
            (*MyOutput_) << "-> Location of ALCT in CLCT match window = 0x " << std::hex << h11_alct_in_clct_match_window_ << std::endl;
            (*MyOutput_) << "-> triad persistence                     = 0x " << std::hex << h11_triad_persistence_         << std::endl;
            //
            (*MyOutput_) << "Header 12:" << std::endl;  
            (*MyOutput_) << "-> MPC muon0 frame 0 LSBs = 0x " << std::hex << h12_mpc0_frame0_lsbs_ << std::endl;
            //
            (*MyOutput_) << "Header 13:" << std::endl;  
            (*MyOutput_) << "-> MPC muon0 frame 1 LSBs = 0x " << std::hex << h13_mpc0_frame1_lsbs_ << std::endl;
            //
            (*MyOutput_) << "Header 14:" << std::endl;  
            (*MyOutput_) << "-> MPC muon1 frame 0 LSBs = 0x " << std::hex << h14_mpc1_frame0_lsbs_ << std::endl;
            //
            (*MyOutput_) << "Header 15:" << std::endl;  
            (*MyOutput_) << "-> MPC muon1 frame 1 LSBs = 0x " << std::hex << h15_mpc1_frame1_lsbs_ << std::endl;
            //
            (*MyOutput_) << "Header 16:" << std::endl;  
            (*MyOutput_) << "-> MPC muon0 frame 0 MSBs              = 0x " << std::hex << h16_mpc0_frame0_msbs_              << std::endl;
            (*MyOutput_) << "-> MPC muon0 frame 1 MSBs              = 0x " << std::hex << h16_mpc0_frame1_msbs_              << std::endl;
            (*MyOutput_) << "-> MPC muon1 frame 0 MSBs              = 0x " << std::hex << h16_mpc1_frame0_msbs_              << std::endl;
            (*MyOutput_) << "-> MPC muon1 frame 1 MSBs              = 0x " << std::hex << h16_mpc1_frame1_msbs_              << std::endl;
            (*MyOutput_) << "-> MPC muon accept response            = 0x " << std::hex << h16_mpc_accept_                    << std::endl;
            (*MyOutput_) << "-> CLCT halfstrip pretrigger threshold = 0x " << std::hex << h16_clct_halfstrip_pretrig_thresh_ << std::endl;
            (*MyOutput_) << "-> CLCT distrip pretrigger threshold   = 0x " << std::hex << h16_clct_distrip_pretrig_thresh_   << std::endl;
            //
            (*MyOutput_) << "Header 17:" << std::endl;  
            (*MyOutput_) << "-> Write buffer is ready           = 0x " << std::hex << h17_write_buffer_ready_     << std::endl;
            (*MyOutput_) << "-> Tbin address for pretrig        = 0x " << std::hex << h17_pretrig_tbin_           << std::endl;
            (*MyOutput_) << "-> write buffer address            = 0x " << std::hex << h17_write_buffer_address_   << std::endl;
            (*MyOutput_) << "-> pretrig arrived, no buffer free = 0x " << std::hex << h17_pretrig_no_free_buffer_ << std::endl;
            (*MyOutput_) << "-> buffer full                     = 0x " << std::hex << h17_buffer_full_            << std::endl;
            (*MyOutput_) << "-> buffer almost full              = 0x " << std::hex << h17_buffer_almost_full_     << std::endl;
            (*MyOutput_) << "-> buffer half full                = 0x " << std::hex << h17_buffer_half_full_       << std::endl;
            (*MyOutput_) << "-> buffer empty                    = 0x " << std::hex << h17_buffer_empty_           << std::endl;
            //
            (*MyOutput_) << "Header 18:" << std::hex << std::endl;  
            (*MyOutput_) << "-> Number of buffers busy = 0x " << std::hex << h18_nbuf_busy_          << std::endl;
            (*MyOutput_) << "-> List of busy buffers   = 0x " << std::hex << h18_buf_busy_           << std::endl;
            (*MyOutput_) << "-> L1A stack overflow     = 0x " << std::hex << h18_l1a_stack_overflow_ << std::endl;
            //
            (*MyOutput_) << "Header 19:" << std::endl;  
            (*MyOutput_) << "-> TMB response                                             = 0x " << std::hex << h19_tmb_trig_pulse_         << std::endl;
            (*MyOutput_) << "-> Only ALCT triggered                                      = 0x " << std::hex << h19_tmb_alct_only_          << std::endl;
            (*MyOutput_) << "-> Only CLCT triggered                                      = 0x " << std::hex << h19_tmb_clct_only_          << std::endl;
            (*MyOutput_) << "-> ALCT*CLCT triggered                                      = 0x " << std::hex << h19_tmb_match_              << std::endl;
            (*MyOutput_) << "-> Write buffer ready at pretrig                            = 0x " << std::hex << h19_write_buffer_ready_     << std::endl;
            (*MyOutput_) << "-> write buffer either (ready -or- not required) at pretrig = 0x " << std::hex << h19_write_buffer_available_ << std::endl;
            (*MyOutput_) << "-> Tbin address at pretrig                                  = 0x " << std::hex << h19_write_tbin_address_     << std::endl;
            (*MyOutput_) << "-> Address of write buffer at pretrig                       = 0x " << std::hex << h19_write_buffer_address_   << std::endl;
            //
            (*MyOutput_) << "Header 20:" << std::endl;  
            (*MyOutput_) << "-> pretrig but no write buffer available = 0x " << std::hex << h20_discard_no_write_buf_available_ << std::endl;
            (*MyOutput_) << "-> invalid pattern after drift           = 0x " << std::hex << h20_discard_invalid_pattern_        << std::endl;
            (*MyOutput_) << "-> TMB rejected event                    = 0x " << std::hex << h20_discard_tmb_reject_             << std::endl;
            (*MyOutput_) << "-> timeout with no TMB trig pulse        = 0x " << std::hex << h20_timeout_no_tmb_trig_pulse_      << std::endl;
            (*MyOutput_) << "-> timeout with no mpc_frame_ff          = 0x " << std::hex << h20_timeout_no_mpc_frame_           << std::endl;
            (*MyOutput_) << "-> timeout with no mpc_response_ff       = 0x " << std::hex << h20_timeout_no_mpc_response_        << std::endl;
            //
            (*MyOutput_) << "Header 21:" << std::endl;  
            (*MyOutput_) << "-> setting of ALCT delay for match window = 0x " << std::hex << h21_match_trig_alct_delay_   << std::endl;
            (*MyOutput_) << "-> setting of match window width          = 0x " << std::hex << h21_match_trig_window_width_ << std::endl;
            (*MyOutput_) << "-> setting of MPC transmit delay          = 0x " << std::hex << h21_mpc_tx_delay_            << std::endl;
            //
            (*MyOutput_) << "Header 22:" << std::endl;  
            (*MyOutput_) << "-> RPCs connected to this TMB            = 0x " << std::hex << h22_rpc_exist_       << std::endl;
            (*MyOutput_) << "-> RPCs included in readout              = 0x " << std::hex << h22_rpc_list_        << std::endl;
            (*MyOutput_) << "-> Number of RPCs in readout             = 0x " << std::hex << h22_nrpc_            << std::endl;
            (*MyOutput_) << "-> RPC readout enabled                   = 0x " << std::hex << h22_rpc_read_enable_ << std::endl;
            (*MyOutput_) << "-> Number of layers hit on layer trigger = 0x " << std::hex << h22_nlayers_hit_     << std::endl;
            (*MyOutput_) << "-> Position of L1A in window             = 0x " << std::hex << h22_l1a_in_window_   << std::endl;
            //
            (*MyOutput_) << "Header 23:" << std::endl;  
            (*MyOutput_) << "-> Board status = 0x " << std::hex << h23_board_status_ << std::endl;
            //
            (*MyOutput_) << "Header 24:" << std::endl;  
            (*MyOutput_) << "-> seconds since last hard reset = 0x " << std::hex << h24_time_since_hard_reset_ << std::endl;
            //
            (*MyOutput_) << "Header 25:" << std::endl;  
            (*MyOutput_) << "-> Firmware version date code = 0x " << std::hex << h25_firmware_version_date_code_ << std::endl;
            //
            return;
        }
        //
        void TMB::init_alct(int choice)
        {
            //start(1);
            if ( choice ==1 ){
                printf(" Closing ALCT-TMB Input \n") ;
                sndbuf[0]=0x00;
                sndbuf[1]=0x59;
            }
            if ( choice ==2 ){
                printf(" Opening ALCT-TMB Input \n") ;
                sndbuf[0]=0x00;
                sndbuf[1]=0x58;
            }
            tmb_vme(VME_WRITE,0x32,sndbuf,rcvbuf,NOW);
            if ( choice ==1 ){
                printf(" Closing CFEB-TMB Input \n") ;
                sndbuf[0]=0x7c;
                sndbuf[1]=0x00;
            }
            if ( choice ==2 ){
                printf(" Opening CFEB-TMB Input \n") ;
                sndbuf[0]=0x7c;
                sndbuf[1]=0x1f;
            }
            tmb_vme(VME_WRITE,0x42,sndbuf,rcvbuf,NOW);
            if ( choice ==1 ){
                printf(" Closing CCB-TMB Input \n") ;
                sndbuf[0]=0x00;
                sndbuf[1]=0x3b;
            }
            if ( choice ==2 ){
                printf(" Opening CCB-TMB Input \n") ;
                sndbuf[0]=0x00;
                sndbuf[1]=0x38;
            }
            tmb_vme(VME_WRITE,0x2a,sndbuf,rcvbuf,NOW);
            end() ;
        }


        void TMB::load_cscid()
        {
            int i;
            if ( theSlot <=12) {
                i=(theSlot/2)&0x000f;
            } else {
                i=(theSlot/2-1)&0x000f;
            }
            //  printf(" I am in CSC Slot %d \n",theSlot);
            sndbuf[0]=0;
            sndbuf[1]=0;
            tmb_vme(VME_READ,0x6e,sndbuf,rcvbuf,NOW);
            //  printf(" read CSC %02x %02x from TMB\n",rcvbuf[0]&0x00ff,rcvbuf[1]&0x00ff );

            sndbuf[0]=( (rcvbuf[0]&0x00fe) | ((i>>3)&0x1)) & 0x00ff;
            sndbuf[1]=( (rcvbuf[1]&0x001f) | ((i<<5)&0xe0)) & 0x00ff;
            //  printf(" write CSC ID %02x %02x to TMB\n",sndbuf[0]&0x00ff,sndbuf[1]&0x00ff);
            tmb_vme(VME_WRITE,0x6e,sndbuf,rcvbuf,NOW);

            tmb_vme(VME_READ,0x6e,sndbuf,rcvbuf,NOW);
            //  printf(" read %02x %02x CSC from TMB \n",rcvbuf[0]&0x00ff,rcvbuf[1]&0x00ff );
        }


        void TMB::lvl1_delay(unsigned short int time)
        {
            tmb_vme(VME_READ,seq_l1a_adr,sndbuf,rcvbuf,NOW);
            sndbuf[0]=  (rcvbuf[0]&0xff);
            sndbuf[1]=  (time&0x00ff);
            tmb_vme(VME_WRITE,seq_l1a_adr,sndbuf,rcvbuf,NOW);
        }

        void TMB::alct_vpf_delay(unsigned short int time)
        {
            tmb_vme(VME_READ,tmbtim_adr,sndbuf,rcvbuf,NOW);
            sndbuf[0]=  rcvbuf[0];
            sndbuf[1]=  (time&0xf) | (rcvbuf[1]&0xf0);
            tmb_vme(VME_WRITE,tmbtim_adr,sndbuf,rcvbuf,NOW);
        }

        void TMB::mpc_delay(unsigned short int time)
        {
            // Read Trigger conf
            tmb_vme(VME_READ,tmb_trig_adr,sndbuf,rcvbuf,NOW); // Trigger conf
            //
            printf("*** Inside.MPC delay %d \n", time);
            //
            printf("Reading address 0x86 to %x %x\n",rcvbuf[0]&0xff,rcvbuf[1]&0xff);
            sndbuf[0] = (rcvbuf[0] & 0xfe | (time & 0x8)>>3) & 0xff;
            sndbuf[1] = (rcvbuf[1] & 0x1f | (time & 0x7)<<5) & 0xff;
            printf("Setting address 0x86 to %x %x\n",sndbuf[0]&0xff,sndbuf[1]&0xff);
            tmb_vme(VME_WRITE,tmb_trig_adr,sndbuf,rcvbuf,NOW); // Write Trigger conf
            //
        }
        //
        int TMB::GetWordCount(){
            //
            tmb_vme(VME_READ,dmb_wdcnt_adr,sndbuf,rcvbuf,NOW);
            //
            return ( rcvbuf[1]&0xff | (rcvbuf[0]&0xf)>>8);
            //
        }
        //
        void TMB::SetALCTPatternTrigger(){
            //
            tmb_vme(VME_READ, seq_trig_en_adr, sndbuf,rcvbuf,NOW);
            sndbuf[0] =   rcvbuf[0]&0xff ;
            sndbuf[1] =  (rcvbuf[1]&0xff) | (0x2) ;
            tmb_vme(VME_WRITE, seq_trig_en_adr, sndbuf,rcvbuf,NOW);
            //
        }
        //
        void TMB::SetCLCTPatternTrigger(){
            //
            tmb_vme(VME_READ, seq_trig_en_adr, sndbuf,rcvbuf,NOW);
            sndbuf[0] =   rcvbuf[0]&0xff ;
            sndbuf[1] =  (rcvbuf[1]&0xff) | (0x1) ;
            tmb_vme(VME_WRITE, seq_trig_en_adr, sndbuf,rcvbuf,NOW);
            //
        }
        //
        int TMB::GetALCTWordCount(){
            //
            const int maximum_number_of_allowed_busies = 20;
            //
            if (!CheckAlctFIFOBusy(maximum_number_of_allowed_busies)) {
                std::cout << "TMB:  At beginning of GetALCTWordCount(),  ALCT FIFO Busy " << maximum_number_of_allowed_busies << " times... " << std::endl;
                std::cout << "..... aborting" << std::endl;
                return 0;
            }
            //  
            ReadRegister(alct_fifo_adr);
            //
            return GetReadAlctRawWordCount();
            //
        }
        //
        void TMB::ForceScopeTrigger(){
            //
            sndbuf[0]=0;
            sndbuf[1]=0;
            tmb_vme(VME_READ,scp_ctrl_adr,sndbuf,rcvbuf,NOW);
            //
            sndbuf[0]=rcvbuf[0] | 0x2 ;
            sndbuf[1]=rcvbuf[1];
            tmb_vme(VME_WRITE,scp_ctrl_adr,sndbuf,rcvbuf,NOW);
            //
            sndbuf[0]=rcvbuf[0] ;
            sndbuf[1]=rcvbuf[1];
            tmb_vme(VME_WRITE,scp_ctrl_adr,sndbuf,rcvbuf,NOW);
            //
        }
        //
        void TMB::read_delays()
        {
            printf(" read delay registers \n");
            sndbuf[0]=0;
            sndbuf[1]=0;
            tmb_vme(VME_READ,0x1A,sndbuf,rcvbuf,NOW);
            printf(" delay register is: %02x%02x \n",rcvbuf[0]&0xff,rcvbuf[1]&0xff);
        }

        //
        void TMB::DumpAddress(int address){
            //
            tmb_vme(VME_READ,address,sndbuf,rcvbuf,NOW);
            //
            printf(" TMB.Dump %x %x \n",rcvbuf[0]&0xff,rcvbuf[1]&0xff);
            //
        }
        //
        void TMB::toggle_l1req() {
            //
            tmb_vme(VME_READ,0x2c,sndbuf,rcvbuf,NOW);
            //  printf("\n   current TMB adr 0x2c setting:  0x%02x%02x\n",rcvbuf[0]&0xff,rcvbuf[1]&0xff);
            sndbuf[0]=rcvbuf[0];
            if((rcvbuf[1]&0x07)==0){
                sndbuf[1]=(rcvbuf[1]|0x04);
                printf("   set TMB sequencer L1req to ON!\n");
            }
            else{
                sndbuf[1]=(rcvbuf[1]&0xf8);
                printf("   set all TMB L1req to OFF!\n");
            }

            printf("     send to TMB adr 0x2c: 0x%02x%02x\n",sndbuf[0]&0xff,sndbuf[1]&0xff);
            tmb_vme(VME_WRITE,0x2c,sndbuf,rcvbuf,NOW);


            tmb_vme(VME_READ,0x72,sndbuf,rcvbuf,NOW);
            printf("\n   current TMB adr 0x72 setting:  0x%02x%02x\n",rcvbuf[0]&0xff,rcvbuf[1]&0xff);
            // [12:8] = #FIFO time bins before pretrigger
            // [7:3] =  #FIFO time bins to read out
            // [2:0] =  FIFO mode:
            //           0=NoDump/1=FullDump/2=LocalDump/3=NoDumpShortHdr/4=NoDumpNoHdr
        }
        //
        void TMB::firmwareVersion()
        {
            sndbuf[0]=0x00;
            sndbuf[1]=0x00;
            tmb_vme(VME_READ,vme_idreg0_adr,sndbuf,rcvbuf,NOW);
            printf(" TMB Version %02x%02x \n", rcvbuf[0]&0xff, rcvbuf[1]&0xff);
            sndbuf[0]=0x00;
            sndbuf[1]=0x00;
            tmb_vme(VME_READ,vme_idreg1_adr,sndbuf,rcvbuf,NOW);
            printf(" TMB month/date %02x/%02x \n", rcvbuf[0]&0xff, rcvbuf[1]&0xff);
            sndbuf[0]=0x00;
            sndbuf[1]=0x00;
            tmb_vme(VME_READ,vme_idreg2_adr,sndbuf,rcvbuf,NOW);
            printf(" TMB year %02x%02x \n", rcvbuf[0]&0xff, rcvbuf[1]&0xff);
            sndbuf[0]=0x00;
            sndbuf[1]=0x00;
            tmb_vme(VME_READ,vme_idreg3_adr,sndbuf,rcvbuf,NOW);
            printf(" TMB revision %02x%02x \n", rcvbuf[0]&0xff, rcvbuf[1]&0xff);
        }
        //
        void TMB::setLogicAnalyzerToDataStream(bool yesorno) {
            //Enable/Disable Logic Analyzer in data stream
            sndbuf[0]=0x00;
            sndbuf[1] = yesorno ? 0x38 : 0x18;
            tmb_vme(VME_WRITE,scp_ctrl_adr,sndbuf,rcvbuf,NOW); // Scope Readout
        }

        void TMB::tmb_vme(char fcn, char vme, const char *snd,char *rcv, int wrt) {
            //
            start(1);
            do_vme(fcn, vme, snd, rcv, wrt);
        }
        //
        void TMB::tmb_vme_new(char fcn, unsigned vme, unsigned short data, char *rcv, int when) {
            //
            //  std::cout << "GetTMBFillVmeWriteVecs() = " << GetTMBFillVmeWriteVecs()
            //  	    << ", OkTMBVmeWriteVme(" << std::hex << vme << ") = " << OkTMBVmeWrite(vme)
            //  	    << ", fcn = " << (int) fcn << std::endl;
            //
            if (GetTMBFillVmeWriteVecs() &&    // Are you filling up the vectors to write to the userPROM?
                    OkTMBVmeWrite(vme)       &&    // Are you allowed to write to this register?
                    fcn == VME_WRITE      ) {     // Are you performing a "write" command?
                //
                //    std::cout << "CTL address, data = " << std::hex 
                //    	      << vme                  << " " 
                //    	      << (int)( (data>>12) & 0xf )
                //    	      << (int)( (data>> 8) & 0xf )
                //    	      << (int)( (data>> 4) & 0xf )
                //    	      << (int)(  data      & 0xf ) 
                //	      << std::endl;
                //
                tmb_write_vme_address_.push_back( vme );
                tmb_write_data_lsb_.push_back( (data & 0xff) );
                tmb_write_data_msb_.push_back( ((data>>8) & 0xff) );
                //    ::sleep(1);
            }
            //
            start(1);
            //  std::cout << "new_vme " << std::hex << vme << " with " << data << "... " << std::endl;
            new_vme(fcn, vme, data, rcv, when);
        }
        //
        void TMB::start() {
            //
            //(*MyOutput_) << "starting to talk to TMB, device " << ucla_ldev << std::endl;
            //
            // send the first signal
            SetupJtag();
            VMEModule::start();
            theController->initDevice(ucla_ldev);
            theController->goToScanLevel();
        }
        //
        void TMB::start(int idev,int JtagSource) {
            //
            VMEModule::SetJtagSource(JtagSource);
            //
            if(idev != ucla_ldev) {
                endDevice();
                ucla_ldev = idev;
            }
            //theController->start(this);
            start();
            //
        }
        //
        void TMB::end() {
#ifdef debugV
            (*MyOutput_) << "Ending TMB device " << ucla_ldev << std::endl;
#endif
            char rcvx[2];
            char sndx[2];
            if(ucla_ldev==1){
                tmb_vme(0xff,0x00,sndx,rcvx,1);
                theController->release_plev();
            }else{
                theController->send_last();
            }
            VMEModule::end();
        }
        //
        int TMB::tmb_get_id(struct tmb_id_regs* tmb_id) {
            //
            unsigned short int value;
            //
            tmb_get_reg(vme_idreg0_adr, &value);
            tmb_id->fw_type = value & 0x000f;
            tmb_id->fw_version = (value >> 4) & 0x000f;
            tmb_id->brd_geo_addr = (value >> 8) & 0x000f;
            //
            tmb_get_reg(vme_idreg1_adr, &value);
            tmb_id->fw_day = value & 0x00ff;
            tmb_id->fw_month = (value >> 8) & 0x00ff;
            //
            tmb_get_reg(vme_idreg2_adr, &value);
            tmb_id->fw_year = value & 0xffff;
            //
            tmb_get_reg(vme_idreg3_adr, &value);
            tmb_id->fpga_type = value & 0xffff;

            return 0;
        }
        //
        int TMB::tmb_set_jtag_src(unsigned short int jtag_src) { 
            //
            unsigned short int value;
            //
            tmb_get_boot_reg(&value);
            //printf("0x%04x\n", value);
            value = (value & ~TMB_JTAG_SRC) | ((jtag_src & 0x01) << 7); // JTAG Source selection bit at position 7
            //printf("0x%04x\n", value);
            // tmb_set_boot_reg(value);
            //
            return 0;
        } 
        //
        int TMB::tmb_get_jtag_src(unsigned short int* jtag_src) {
            //
            unsigned short int value = 0;
            //
            tmb_get_boot_reg(&value);
            *jtag_src = ((value & TMB_JTAG_SRC) > 0) ? JTAG_HARD_SRC : JTAG_SOFT_SRC; 
            //
            return 0;
        }
        //
        int TMB::tmb_set_jtag_chain(unsigned int jchain) {
            //
            unsigned short int chain;
            unsigned short int jtag_src = 0;

            tmb_get_jtag_src(&jtag_src);

            if (jtag_src == JTAG_SOFT_SRC) {
                tmb_get_reg(vme_usr_jtag_adr, &chain);
                chain = (chain & 0xff0f) | ((jchain & 0x0f) << 4);
                tmb_set_reg(vme_usr_jtag_adr, chain);
            } else {
                tmb_get_boot_reg(&chain);
                chain = (chain & 0xff87) | ( (jchain & 0x0f) << 3);
                tmb_set_boot_reg(chain);
            }
            //
            return 0;
        }
        //
        int TMB::tmb_set_reg(unsigned int vmereg, unsigned short int value ) {
            //
            char sndbuf[2];
            char rcvbuf[2];
            sndbuf[0]=value & 0xff;
            sndbuf[1]=(value >> 8) & 0xff;
            tmb_vme(VME_WRITE, vmereg, sndbuf, rcvbuf, NOW );
            return 0;	
        }
        //
        int TMB::tmb_get_reg(unsigned int vmereg, unsigned short int* value )
        {
            char sndbuf[2];
            char rcvbuf[2];
            sndbuf[0]=0;
            sndbuf[1]=0;
            tmb_vme(VME_READ, vmereg, sndbuf, rcvbuf, NOW );
            *value = (rcvbuf[1]&0xff) | (rcvbuf[0]<<8);
            return 0;
        }  
        //
        int TMB::tmb_vme_reg(unsigned int vmereg, unsigned short int* value) {
            //
            tmb_set_reg(vmereg, *value);
            tmb_get_reg(vmereg, value);
            return 0;
        }
        //
        int TMB::tmb_get_boot_reg(unsigned short int* value) {
            //
            //char sndbuf[2];
            //char rcvbuf[2];
            //
            tmb_vme(VME_READ | VME_BOOT_REG, 0, sndbuf, rcvbuf, NOW ); // Send read request
            //
            //tmb_vme(VME_READ, 4, sndbuf, rcvbuf, NOW );
            //tmb_vme(VME_READ, 4, sndbuf, rcvbuf, NOW );
            //tmb_vme(VME_READ, 4, sndbuf, rcvbuf, NOW );
            //
            *value = (rcvbuf[1]&0xff) | (rcvbuf[0]<<8);
            //printf("get_boot.%02x %02x \n",rcvbuf[0]&0xff,rcvbuf[1]&0xff);
            //
            DecodeBootRegister_(*value);
            //
            return 0;
            //
        }
        //
        int TMB::tmb_set_boot_reg(unsigned short int value) {
            //
            sndbuf[0]=(value >> 8) & 0xff;
            sndbuf[1]=value & 0xff;
            //
            tmb_vme(VME_WRITE | VME_BOOT_REG, 0, sndbuf, rcvbuf, NOW );
            //
            return 0;   
        }
        //
        void TMB::UnjamFPGA() {
            //
            std::cout << "Unjam TMB JTAG chains..." << std::endl;
            //
            const int tck_up = 0x0004;
            const int tck_dn = 0x0000;
            //
            const int tms_up = 0x0002;
            const int tms_dn = 0x0000;
            //
            // Pick the chain according to bits [6:3].  Use the bootstrap register (bit[7]=1)
            const int tmb_mezz_chain  = 0x00a0;
            const int alct_jtag_chain = 0x0080;
            const int tmb_user_chain  = 0x00c0;
            const int tmb_fpga_chain  = 0x00e0;
            //
            // clear TMB boot register
            tmb_set_boot_reg(0);
            sleep(1);
            //
            // Bring the Test Access Port (TAP) state to Run-Test-Idle for each JTAG chain
            for (int chain=0; chain<4; chain++) {
                int data_word;
                int chain_address = 0;
                //
                if (chain == 0) {
                    chain_address = tmb_mezz_chain;
                } else if (chain == 1) {
                    chain_address = alct_jtag_chain;
                } else if (chain == 2) {
                    chain_address = tmb_user_chain;
                } else if (chain == 3) {
                    chain_address = tmb_fpga_chain;
                }
                //
                data_word = chain_address | tms_up | tck_dn;
                tmb_set_boot_reg(data_word);     
                data_word = chain_address | tms_up | tck_up;
                tmb_set_boot_reg(data_word);     
                data_word = chain_address | tms_up | tck_dn;
                tmb_set_boot_reg(data_word);     
                //
                data_word = chain_address | tms_up | tck_dn;
                tmb_set_boot_reg(data_word);     
                data_word = chain_address | tms_up | tck_up;
                tmb_set_boot_reg(data_word);     
                data_word = chain_address | tms_up | tck_dn;
                tmb_set_boot_reg(data_word);     
                //
                data_word = chain_address | tms_up | tck_dn;
                tmb_set_boot_reg(data_word);     
                data_word = chain_address | tms_up | tck_up;
                tmb_set_boot_reg(data_word);     
                data_word = chain_address | tms_up | tck_dn;
                tmb_set_boot_reg(data_word);     
                //
                data_word = chain_address | tms_up | tck_dn;
                tmb_set_boot_reg(data_word);     
                data_word = chain_address | tms_up | tck_up;
                tmb_set_boot_reg(data_word);     
                data_word = chain_address | tms_up | tck_dn;
                tmb_set_boot_reg(data_word);     
                //
                data_word = chain_address | tms_up | tck_dn;
                tmb_set_boot_reg(data_word);     
                data_word = chain_address | tms_up | tck_up;
                tmb_set_boot_reg(data_word);     
                data_word = chain_address | tms_up | tck_dn;
                tmb_set_boot_reg(data_word);     
                //
                data_word = chain_address | tms_dn | tck_dn;
                tmb_set_boot_reg(data_word);     
                data_word = chain_address | tms_dn | tck_up;
                tmb_set_boot_reg(data_word);     
                data_word = chain_address | tms_dn | tck_dn;
                tmb_set_boot_reg(data_word);     
                //
            }
            //
            //give the JTAG chain back to the FPGA 
            tmb_set_boot_reg(0);     
            //
            return;
        }
        //
        //
        int TMB::tmb_hard_reset_alct_fpga() {
            //
            unsigned short int value = 0;
            tmb_get_boot_reg(&value);
            value &= ~ALCT_HARD_RESET & 0xffff;
            tmb_set_boot_reg(value);
            value |= ALCT_HARD_RESET;
            tmb_set_boot_reg(value);
            value &= ~ALCT_HARD_RESET & 0xffff;
            tmb_set_boot_reg(value);
            return 0;
        }
        //
        int TMB::tmb_hard_reset_tmb_fpga() {
            //
            unsigned short int value = 0;
            tmb_get_boot_reg(&value);
            value &= ~TMB_HARD_RESET & 0xffff;
            tmb_set_boot_reg(value);
            value |= TMB_HARD_RESET;
            tmb_set_boot_reg(value);
            value &= ~TMB_HARD_RESET & 0xffff;
            tmb_set_boot_reg(value);
            return 0;
        }
        //
        int TMB::tmb_enable_alct_hard_reset(int flag_enable) {
            //
            unsigned short int value = 0;
            tmb_get_boot_reg(&value);
            if(flag_enable>0)
            { value |= TMB_ENABLE_ALCT_RESET;}
            else 
            { value &= ~TMB_ENABLE_ALCT_RESET & 0xffff; }
            tmb_set_boot_reg(value);
            return 0;
        }
        //
        int TMB::tmb_enable_vme_commands(int flag_enable) {
            //
            unsigned short int value = 0;
            tmb_get_boot_reg(&value);
            if(flag_enable>0) 
            { value |= TMB_ENABLE_VME;}
            else
            { value &= ~TMB_ENABLE_VME & 0xffff;} 
            tmb_set_boot_reg(value);
            return 0;
        }
        //
        std::ostream & operator<<(std::ostream & os, TMB & tmb) {
            //
            os << std::dec << "TMB: crate " << tmb.theCrate_
                << " slot " << tmb.theSlot << std::endl
                << std::hex 
                << "  cfeb delays (hex) " << tmb.cfeb0_tof_delay_ << " " 
                << tmb.cfeb1_tof_delay_ << " " << tmb.cfeb2_tof_delay_ << " " 
                << tmb.cfeb3_tof_delay_ << " " << tmb.cfeb4_tof_delay_ << std::endl
                << " rx, tx clock delays " << tmb.alct_rx_clock_delay_ 
                << " " << tmb.alct_tx_clock_delay_ << std::endl
                << "l1a window size " << tmb.l1a_window_size_ << std::endl
                << "l1a delay " << tmb.l1adelay_ << std::endl
                << "match window size " << tmb.alct_match_window_size_ << std::endl
                << "alct vpf delay " << tmb.alct_vpf_delay_  << std::endl
                << "mpc rx delay  " << tmb.mpc_rx_delay_ << std::endl
                << "enable_alct_rx " << tmb.enable_alct_rx_ << std::endl
                << "rpc_exists " << tmb.rpc_exists_ << std::endl
                << "fifo_mode  " << tmb.fifo_mode_ << std::endl
                << "fifo_tbins " << tmb.fifo_tbins_ << std::endl
                << "fifo_pretrig " << tmb.fifo_pretrig_ << std::endl
                << "alct_clear " << tmb.alct_clear_ << std::endl
                << "mpc_tx_delay " << tmb.mpc_tx_delay_ << std::endl
                << "l1a_offset " << tmb.l1a_offset_ << std::endl
                << "disableCLCTInputs " << tmb.disableCLCTInputs_ << std::endl
                << "enableCLCTInputs " << tmb.enableCLCTInputs_ << std::endl
                << "alctController_ " << tmb.alctController_ << std::endl
                << "rat_ " << tmb.rat_ << std::endl
                << "bxn_offset_ " << tmb.bxn_offset_ << std::endl
                << "trgmode_ " << tmb.trgmode_ << std::endl
                << "rpc_bxn_offset_ " << tmb.rpc_bxn_offset_ << std::endl
                << "shift_rpc_ " << tmb.shift_rpc_ << std::endl
                << "request_l1a_ " << tmb.request_l1a_ << std::endl
                << "hit_thresh_ " << tmb.hit_thresh_ << std::endl
                << "min_hits_pattern_ " << tmb.min_hits_pattern_ << std::endl
                << "dmb_tx_delay_ " << tmb.dmb_tx_delay_ << std::endl
                << "rat_tmb_delay_ " << tmb.rat_tmb_delay_ << std::endl
                << "rpc0_rat_delay_ " << tmb.rpc0_rat_delay_ << std::endl
                << std::dec << std::endl;
            return os;
        }
        //
        //
        void TMB::tmb_clk_delays(unsigned short int time,int cfeb_id) {
            //
            new_clk_delays(time, cfeb_id);
            //
        }
        //
        void TMB::DiStripHCMask(int DiStrip) {
            //
            // Only enables specific Distrp channels
            //
            printf("Enabling DiStrip %d \n",DiStrip);
            //
            sndbuf[0] = (0x1<<(DiStrip+1))&0xff;
            sndbuf[1] = (0x1<<(DiStrip))&0xff;
            //
            printf(" %x %x \n",sndbuf[0],sndbuf[1]);
            //
            tmb_vme(VME_WRITE, hcm001_adr,sndbuf,rcvbuf,NOW);
            tmb_vme(VME_WRITE, hcm023_adr,sndbuf,rcvbuf,NOW);
            tmb_vme(VME_WRITE, hcm045_adr,sndbuf,rcvbuf,NOW);
            //
            tmb_vme(VME_WRITE, hcm101_adr,sndbuf,rcvbuf,NOW);
            tmb_vme(VME_WRITE, hcm123_adr,sndbuf,rcvbuf,NOW);
            tmb_vme(VME_WRITE, hcm145_adr,sndbuf,rcvbuf,NOW);
            //
            tmb_vme(VME_WRITE, hcm201_adr,sndbuf,rcvbuf,NOW);
            tmb_vme(VME_WRITE, hcm223_adr,sndbuf,rcvbuf,NOW);
            tmb_vme(VME_WRITE, hcm245_adr,sndbuf,rcvbuf,NOW);
            /*
               tmb_vme(VME_WRITE, hcm301_adr,sndbuf,rcvbuf,NOW);
               tmb_vme(VME_WRITE, hcm323_adr,sndbuf,rcvbuf,NOW);
               tmb_vme(VME_WRITE, hcm345_adr,sndbuf,rcvbuf,NOW);
               tmb_vme(VME_WRITE, hcm401_adr,sndbuf,rcvbuf,NOW);
               tmb_vme(VME_WRITE, hcm423_adr,sndbuf,rcvbuf,NOW);
               tmb_vme(VME_WRITE, hcm445_adr,sndbuf,rcvbuf,NOW);
               */
        }
        //
        //
        void TMB::disableAllClocks(){
            /// Disable all clocks to cfeb and alct. Should be used when updating the ALCT firmware
            //
            // Reading in broadcast mode does not work.  Comment the next few lines out...
            //  tmb_vme(VME_READ, vme_step_adr,sndbuf,rcvbuf,NOW);  
            //  sndbuf[0]=rcvbuf[0] & 0x1f;
            //  sndbuf[1]=rcvbuf[1] & 0xf8;
            sndbuf[0]= 0x1f;
            sndbuf[1]= 0xf8;
            tmb_vme(VME_WRITE, vme_step_adr, sndbuf,rcvbuf,NOW);
        }
        //
        void TMB::enableAllClocks(){
            /// Enable all clocks to cfeb and alct. Should be used after updating the ALCT firmware to get the TMB back in default mode.
            //
            // Reading in broadcast mode does not work.  Comment the next few lines out...
            //  tmb_vme(VME_READ, vme_step_adr,sndbuf,rcvbuf,NOW);   
            //  sndbuf[0]=rcvbuf[0] | 0xe0;
            //  sndbuf[1]=rcvbuf[1] | 0x07;
            sndbuf[0] = 0xe0;
            sndbuf[1] = 0x07;
            tmb_vme(VME_WRITE, vme_step_adr, sndbuf,rcvbuf,NOW);
        }

        //------------------------------------------------------------------------------
        // Trigger Tests 
        //------------------------------------------------------------------------------

        bool interactive=false; 
        bool rat_injector_sync=false;
        bool rat_injector_enable=true;
        int nclcts_inject=1;
        int nalcts_inject=1;
        int triad_1st_tdbin[6]={0};
        int l1a_delay=119;  // hits 0th l1a window bx
        int pat_ram[32][3][5] = {{{ 0 }}}; 

        std::string marker="AOXOMOXOA";
        std::string sfmm_state[5]={ "Startup", "Resync ", "Stop   ", "WaitBXO", "Run    "};
        bool fire_injector=false;
        bool err_check=true;
        int lookback_triad_hits[6]={0};
        int cfeb_en[6]={0};

        /*
         ** void TMB::TriggerTestInjectALCT(){
         **   //
         **   // Turn off CCB backplane inputs, turn on L1A emulator
         **   DisableExternalCCB();
         **   EnableInternalL1aEmulator();
         **   //
         **   // Enable sequencer trigger, set internal l1a delay
         **   tmb_vme(VME_READ, ccb_trig_adr, sndbuf,rcvbuf,NOW);
         **   sndbuf[0] = rcvbuf[0];
         **   sndbuf[1] = 0x4;
         **   tmb_vme(VME_WRITE, ccb_trig_adr, sndbuf,rcvbuf,NOW);
         **   //
         **   // Turn off ALCT cable inputs, disable synchronized alct+clct triggers
         **   DisableALCTInputs();
         **   DisableALCTCLCTSync();
         **   //
         **   // Turn off CLCT cable inputs
         **   DisableCLCTInputs();
         **   //
         **   // Turn off internal level 1 accept for sequencer
         **   DisableInternalL1aSequencer();
         **   //
         **   // Select ALCT pattern trigger
         **   SetALCTPatternTrigger();
         **   //
         **   // Set start_trigger state then bx0 for FMM
         **   StartTTC();
         **   //
         **   // Arm scope trigger
         **   scope(1,0,0);
         **   //
         **   // Clear previous inject
         **   ClearALCTInjector();
         **   //  
         **   // Fire ALCT injector
         **   FireALCTInjector();
         **   //
         **   // Clear previous inject
         **   ClearALCTInjector();
         **   //
         **   // Check scintillator veto is set
         **   tmb_vme(VME_READ, seqmod_adr, sndbuf,rcvbuf,NOW);
         **   int scint_veto = ((rcvbuf[0]&0xff)>>5&0x1);
         **   if(scint_veto != 1) {
         **     (*MyOutput_) << "scint veto failed to set" << std::endl;
         **     return;
         **   }
         **   //
         **   // Clear scintillator veto
         **   ClearScintillatorVeto();
         **   tmb_vme(VME_READ, seqmod_adr, sndbuf,rcvbuf,NOW);
         **   scint_veto = ((sndbuf[0]&0xff)>>5)&0x1;
         **   if(scint_veto != 0) {
         **     (*MyOutput_) << "scint veto failed to clear" << std::endl;
         **   }
         **   //
         **   // Read back embedded scope data
         **   scope(0,1);
         **   //
         ** }
         **/

        /*
         ** void TMB::TriggerTestInjectCLCT(){
         **   //
         **   // Turn off CCB backplane inputs, turn on L1A emulator
         **   DisableExternalCCB();
         **   EnableInternalL1aEmulator();
         **   //
         **   // Enable sequencer trigger, turn off dmb trigger, set internal l1a delay
         **   tmb_vme(VME_READ, ccb_trig_adr, sndbuf,rcvbuf,NOW);
         **   sndbuf[0] = rcvbuf[0];
         **   sndbuf[1] = 0x4;
         **   tmb_vme(VME_WRITE, ccb_trig_adr, sndbuf,rcvbuf,NOW);
         **   //
         **   // Turn off ALCT cable inputs, disable synchronized alct+clct triggers
         **   DisableALCTInputs();
         **   DisableALCTCLCTSync();
         **   //
         **   // Turn off CLCT cable inputs
         **   DisableCLCTInputs();
         **   //
         **   // Turn off internal level 1 accept for sequencer
         **   DisableInternalL1aSequencer();
         **   //
         **   // Select pattern trigger
         **   SetCLCTPatternTrigger();
         **   //
         **   // Set start_trigger state then bx0 for FMM
         **   StartTTC();
         **   //
         **   // Arm scope trigger
         **   scope(1,0,0);
         **   //
         **   // Clear previous CLCT inject
         **   ClearCLCTInjector();
         **   //  
         **   // Fire CLCT injector
         **   FireCLCTInjector();
         **   //
         **   // Clear previous inject
         **   ClearCLCTInjector();
         **   //  
         **   // Check scintillator veto is set
         **   tmb_vme(VME_READ, seqmod_adr, sndbuf,rcvbuf,NOW);
         **   int scint_veto = ((rcvbuf[0]&0xff)>>5&0x1);
         **   if(scint_veto != 1) {
         **     (*MyOutput_) << "scint veto failed to set" << std::endl;
         **     return;
         **   }
         **   //
         **   // Clear scintillator veto
         **   ClearScintillatorVeto();
         **   tmb_vme(VME_READ, seqmod_adr, sndbuf,rcvbuf,NOW);
         **   scint_veto = ((sndbuf[0]&0xff)>>5)&0x1;
         **   if(scint_veto != 0) {
         **     (*MyOutput_) << "scint veto failed to clear" << std::endl;
         **   }
         **   //
         **   // Read back embedded scope data
         **   scope(0,1);
         **   //
         ** }
         */

        //------------------------------------------------------------------------------
        //  Inject ALCT
        //------------------------------------------------------------------------------
        void TMB::TriggerTestInjectALCT() {
            ifunc = 1;              // turn on/off bang mode
            nalcts_inject=1;        // number of ALCTs to Inject
            inquirb("Global", "rdscope", rdscope);

            // Turn off CCB backplane inputs, turn on L1A emulator
            adr     = ccb_cfg_adr;
            wr_data = 0x003D;
            status  = vme_write(adr,wr_data);

            // Enable sequencer trigger, set internal l1a delay
            adr     = ccb_trig_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFF00;
            wr_data = wr_data | 0x0004;
            //  wr_data = wr_data | (114<<8);
            status = vme_write(adr,wr_data);

            // Turn off ALCT cable inputs, disable synchronized alct+clct triggers
            adr     = alct_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x0000;
            wr_data = wr_data | 0x0001;
            wr_data = wr_data | (alct_injector_delay << 5); // post-rat firmware
            status  = vme_write(adr,wr_data);

            // Turn off CLCT cable inputs
            adr     = cfeb_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFE0;
            status  = vme_write(adr,wr_data);

            // Turn on CFEB enables to over-ride mask_all
            adr     = seq_trig_en_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x03FF;     // clear old cfeb_en and source
            wr_data = wr_data | 0x7C00;     // ceb_en_source=0,cfeb_en=1F
            status  = vme_write(adr,wr_data);

            // Turn off internal level 1 accept for sequencer
            adr     = seq_l1a_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x0FFF;
            status  = vme_write(adr,wr_data);

            // Select ALCT pattern trigger
            adr     = seq_trig_en_adr;
            status  = vme_read(adr,rd_data);
            rd_data = rd_data & 0xFF00;
            wr_data = rd_data | 0x0002;
            status  = vme_write(adr,wr_data);

            // Set start_trigger state for FMM
            ttc_cmd = 6;            // start_trigger
            adr     = ccb_cmd_adr;
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);
            wr_data = 0x0003 | (ttc_cmd << 8);
            status  = vme_write(adr,wr_data);
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);

            ttc_cmd = 1;            // bx0
            wr_data = 0x0003 | (ttc_cmd << 8);
            status  = vme_write(adr,wr_data);
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);

            // Arm scope trigger
            scp_arm        = true;
            scp_readout    = false;
            scp_raw_decode = false;
            scp_silent     = false;
            scp_playback   = false;
            if (rdscope)
                scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);
            
            // Set ALCT first muon to inject:
            if (nalcts_inject >= 1) 
            {
                inquire("InjectALCT", "alct0_vpf_inj",  minv= 0, maxv=  1,   radix=10, alct0_vpf_inj) ;     // Valid pattern flag
                inquire("InjectALCT", "alct0_qual_inj", minv= 0, maxv=  3,   radix=10, alct0_qual_inj);     // Pattern Quality
                inquire("InjectALCT", "alct0_amu_inj",  minv= 0, maxv=  1,   radix=10, alct0_amu_inj) ;     // Accelerator muon
                inquire("InjectALCT", "alct0_key_inj",  minv= 0, maxv=  127, radix=10, alct0_key_inj) ;     // Wire group ID Number
                inquire("InjectALCT", "alct0_bxn_inj",  minv= 0, maxv=  3,   radix=10, alct0_bxn_inj) ;     // Bunch crossing number
            }
            else {                                                                                          //  No 1st alct muon
                alct0_vpf_inj   = 0;                                                                        //  Valid pattern flag
                alct0_qual_inj  = 0;                                                                        //  Pattern quality
                alct0_amu_inj   = 0;                                                                        //  Accelerator muon
                alct0_key_inj   = 0;                                                                        //  Wire group ID number (just some offset wrt clct key for now)
                alct0_bxn_inj   = 0;                                                                        //  Bunch crossing number
            }

            alct0_inj_wr    = (alct0_vpf_inj  <<  0);
            alct0_inj_wr    = (alct0_qual_inj <<  1) | alct0_inj_wr;
            alct0_inj_wr    = (alct0_amu_inj  <<  3) | alct0_inj_wr;
            alct0_inj_wr    = (alct0_key_inj  <<  4) | alct0_inj_wr;
            alct0_inj_wr    = (alct0_bxn_inj  << 11) | alct0_inj_wr;

            wr_data = alct0_inj_wr;
            adr     = alct0_inj_adr;
            status  = vme_write(adr,wr_data);

            (*MyOutput_) << "alct0_inj_wr=" << alct0_inj_wr << std::endl;

            // Set ALCT second muon to inject:
            if (nalcts_inject == 2) 
            {
                inquire("InjectALCT", "alct1_vpf_inj",  minv= 0, maxv=  1,   radix=10, alct1_vpf_inj) ;     // Valid pattern flag
                inquire("InjectALCT", "alct1_qual_inj", minv= 0, maxv=  3,   radix=10, alct1_qual_inj);     // Pattern quality
                inquire("InjectALCT", "alct1_amu_inj",  minv= 0, maxv=  1,   radix=10, alct1_amu_inj) ;     // Accelerator muon
                inquire("InjectALCT", "alct1_key_inj",  minv= 0, maxv=  127, radix=10, alct1_key_inj) ;     // Wire group ID Number
                inquire("InjectALCT", "alct1_bxn_inj",  minv= 0, maxv=  3,   radix=10, alct1_bxn_inj) ;     // Bunch crossing number
            }
            else 
            {                                                                                               //  No 2nd alct muon
                alct1_vpf_inj   = 0;                                                                        //  Valid pattern flag
                alct1_qual_inj  = 0;                                                                        //  Pattern quality
                alct1_amu_inj   = 0;                                                                        //  Accelerator muon
                alct1_key_inj   = 0;                                                                        //  Wire group ID number
                alct1_bxn_inj   = 0;                                                                        //  Bunch crossing number
            }

            alct1_inj_wr    = (alct1_vpf_inj  <<  0);
            alct1_inj_wr    = (alct1_qual_inj <<  1) | alct1_inj_wr;
            alct1_inj_wr    = (alct1_amu_inj  <<  3) | alct1_inj_wr;
            alct1_inj_wr    = (alct1_key_inj  <<  4) | alct1_inj_wr;
            alct1_inj_wr    = (alct1_bxn_inj  << 11) | alct1_inj_wr;

            wr_data = alct1_inj_wr; 
            adr     = alct1_inj_adr;
            status  = vme_write(adr,wr_data);

            (*MyOutput_) << "alct1_inj_wr=" << alct1_inj_wr << std::endl;

            // Clear previous inject
            adr     = alct_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFFD;
            status  = vme_write(adr,wr_data);

            // Fire ALCT injector
            wr_data = wr_data | 0x0002; // Fire ALCT inject
            status  = vme_write(adr,wr_data);

            // Clear previous inject
            wr_data = rd_data & 0xFFFD;     
            status  = vme_write(adr,wr_data);

            // Check for blue flash
            adr    = vme_led_adr;
            status = vme_read(adr,rd_data);
            blue_flash = rd_data & 0x1;

            if (ifunc>0) {
                if (blue_flash==0) 
                    (*MyOutput_) << ("\nNO BLUE FLASH. Rats =:-(\n");
                if (blue_flash==1) 
                    (*MyOutput_) << ("\nBlue flash. Cool\n");
            }

            // Check scintillator veto is set
            adr    = seqmod_adr;
            status = vme_read(adr,rd_data);
            scint_veto = (rd_data>>13) & 0x1;
            if (scint_veto!=1) pause("scint veto failed to set");

            // Clear scintillator veto
            wr_data = rd_data | (1<<12);
            status  = vme_write(adr,wr_data);
            wr_data = wr_data ^ (1<<12);
            status  = vme_write(adr,wr_data);
            status  = vme_read(adr,rd_data);
            scint_veto = (rd_data>>12) & 0x1;
            if (scint_veto!=0) pause("scint veto failed to clear");

            // Read ALCT data wot triggered
            adr    = alct_alct0_adr;
            status = vme_read(adr,rd_data);
            alct0_inj_rd = rd_data;

            adr    = alct_alct1_adr;
            status = vme_read(adr,rd_data);
            alct1_inj_rd = rd_data;

            // Read injector generated ALCT data
            adr    = alct0_inj_adr;
            status = vme_read(adr,rd_data);
            alct0_inj_wr = rd_data;

            adr    = alct1_inj_adr;
            status = vme_read(adr,rd_data);
            alct1_inj_wr = rd_data;

            // Compare injected ALCT readback with generated ALCT
            ck("alct0_inj  ",alct0_inj_wr,alct0_inj_rd);
            ck("alct1_inj  ",alct1_inj_wr,alct1_inj_rd);

            // Decompose injected ALCT
            alct0_vpf   = (alct0_inj_rd >> 0) & 0x0001; // Valid pattern flag
            alct0_qual  = (alct0_inj_rd >> 1) & 0x0003; // Pattern quality
            alct0_amu   = (alct0_inj_rd >> 3) & 0x0001; // Accelerator muon
            alct0_key   = (alct0_inj_rd >> 4) & 0x007F; // Wire group ID number
            alct0_bxn   = (alct0_inj_rd >>11) & 0x0003; // Bunch crossing number

            alct1_vpf   = (alct1_inj_rd >> 0) & 0x0001; // Valid pattern flag
            alct1_qual  = (alct1_inj_rd >> 1) & 0x0003; // Pattern quality
            alct1_amu   = (alct1_inj_rd >> 3) & 0x0001; // Accelerator muon
            alct1_key   = (alct1_inj_rd >> 4) & 0x007F; // Wire group ID number
            alct1_bxn   = (alct1_inj_rd >>11) & 0x0003; // Bunch crossing number

            // Display ALCTs found
            if (ifunc>0) {
                (*MyOutput_) << ("Expect:ALCT0:Key7 Q3 Bxn1 ALCT1:Key61 Q2 Bxn1\n");

                (*MyOutput_) << "ALCT0: ";
                (*MyOutput_) << "vpf = " << alct0_vpf ;
                (*MyOutput_) << "qual= " << alct0_qual;
                (*MyOutput_) << "amu = " << alct0_amu ;
                (*MyOutput_) << "key = " << alct0_key ;
                (*MyOutput_) << "bxn = " << alct0_bxn ;
                (*MyOutput_) << "\n";

                (*MyOutput_) << "ALCT1: "; 
                (*MyOutput_) << "vpf = " << alct1_vpf ;
                (*MyOutput_) << "qual= " << alct1_qual;
                (*MyOutput_) << "amu = " << alct1_amu ;
                (*MyOutput_) << "key = " << alct1_key ;
                (*MyOutput_) << "bxn = " << alct1_bxn ;
                (*MyOutput_) << "\n";
            }

            // Read back embedded scope data
            scp_arm        = false;
            scp_readout    = true;
            scp_raw_decode = false;
            scp_silent     = true;
            scp_playback   = false;
            if (rdscope)
                scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

        } // End InjectALCT()

        //------------------------------------------------------------------------------
        //  Inject CLCT
        //------------------------------------------------------------------------------
        void TMB::TriggerTestInjectCLCT() {
            ifunc = 1;
            inquirb("Global", "rdscope", rdscope);

            // Turn off CCB backplane inputs, turn on L1A emulator
            adr     = ccb_cfg_adr;
            wr_data = 0x003D;
            status  = vme_write(adr,wr_data);

            // Enable sequencer trigger, turn off dmb trigger, set internal l1a delay
            adr     = ccb_trig_adr;
            wr_data = 0x0004;
            wr_data = wr_data | (114 << 8);
            status  = vme_write(adr,wr_data);

            // Turn off ALCT cable inputs, disable synchronized alct+clct triggers
            adr     = alct_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x0000;
            wr_data = wr_data | 0x0001;
            wr_data = wr_data | (alct_injector_delay << 5);
            status  = vme_write(adr,wr_data);

            // Turn off CLCT cable inputs
            adr     = cfeb_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFE0;
            status  = vme_write(adr,wr_data);

            // Turn on CFEB enables to over-ride mask_all
            adr     = seq_trig_en_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x03FF; // clear old cfeb_en and source
            wr_data = wr_data | 0x7C00; // ceb_en_source=0,cfeb_en=1F
            status  = vme_write(adr,wr_data);

            // Turn off internal level 1 accept for sequencer
            adr     = seq_l1a_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x0FFF;
            status  = vme_write(adr,wr_data);

            // Select pattern trigger
            adr     = seq_trig_en_adr;
            status  = vme_read(adr,rd_data);
            rd_data = rd_data & 0xFF00;
            wr_data = rd_data | 0x0001;
            status  = vme_write(adr,wr_data);

            // Clear previous ALCT inject
            adr     = alct_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFFD;
            status  = vme_write(adr,wr_data);

            // Set start_trigger state for FMM
            ttc_cmd = 6;            // start_trigger
            adr     = ccb_cmd_adr;
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);
            wr_data = 0x0003 | (ttc_cmd << 8);
            status  = vme_write(adr,wr_data);
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);

            ttc_cmd = 1;            // bx0
            wr_data = 0x0003 | (ttc_cmd << 8);
            status  = vme_write(adr,wr_data);
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);

            // Arm scope trigger
            scp_arm        = true;
            scp_readout    = false;
            scp_raw_decode = false;
            scp_silent     = false;
            scp_playback   = false;
            if (rdscope)
                scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

            // Clear previous  CLCT inject
            adr     = cfeb_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x7FFF;
            status  = vme_write(adr,wr_data);

            // Fire CLCT Injector
            wr_data = wr_data | 0x8000;
            status  = vme_write(adr,wr_data);

            // Clear previous inject    
            wr_data = rd_data & 0x7FFF; 
            status  = vme_write(adr,wr_data);

            // Check scintillator veto is set
            adr    = seqmod_adr;
            status = vme_read(adr,rd_data);
            scint_veto = (rd_data >> 13) & 0x0001;
            if (scint_veto!=1) pause ("scint veto failed to set");

            // Clear scintillator veto
            wr_data = rd_data | (1 << 12);
            status  = vme_write(adr,wr_data);
            wr_data = wr_data ^ (1 << 12);
            status  = vme_write(adr,wr_data);
            status  = vme_read (adr,rd_data);
            scint_veto = (rd_data >> 12) & 0x1;
            if (scint_veto!=0) pause ("scint veto failed to clear");

            // Read back embedded scope data
            scp_arm        = false;
            scp_readout    = true;
            scp_raw_decode = false;
            scp_silent     = true;
            scp_playback   = false;
            if (rdscope)
                scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);
        } // close InjectCLCT()

        //------------------------------------------------------------------------------
        //  Inject ALCT+CLCT
        //------------------------------------------------------------------------------
        void TMB::TriggerTestInjectALCTCLCT() {
            ifunc = 1;
            inquirb("Global", "rdscope", rdscope);

            // Turn off CCB backplane inputs, turn on L1A emulator
            adr     = ccb_cfg_adr;
            wr_data = 0x003D;
            status  = vme_write(adr,wr_data);

            // Enable sequencer trigger, turn off dmb trigger, set internal l1a delay
            adr     = ccb_trig_adr;
            wr_data = 0x0004;
            wr_data = wr_data | (114<<8);
            status  = vme_write(adr,wr_data);

            // Turn off ALCT cable inputs, enable synchronized alct+clct triggers
            adr     = alct_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x0000;
            wr_data = wr_data | 0x0005;
            wr_data = wr_data | (alct_injector_delay << 5);
            status  = vme_write(adr,wr_data);

            // Set ALCT delay for TMB matching
            adr     = tmbtim_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFF0;
            wr_data = wr_data | 0x0003;
            status  = vme_write(adr,wr_data);

            // Turn off CLCT cable inputs
            adr     = cfeb_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFE0;
            status  = vme_write(adr,wr_data);

            // Turn on CFEB enables to over-ride mask_all
            adr     = seq_trig_en_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x03FF;     // clear old cfeb_en and source
            wr_data = wr_data | 0x7C00;     // ceb_en_source=0,cfeb_en=1F
            status  = vme_write(adr,wr_data);

            // Turn off internal level 1 accept for sequencer
            adr     = seq_l1a_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x0FFF;
            status  = vme_write(adr,wr_data);

            // Select pattern trigger
            adr     = seq_trig_en_adr;
            status  = vme_read(adr,rd_data);
            rd_data = rd_data & 0xFF00;
            wr_data = rd_data | 0x0001;
            status  = vme_write(adr,wr_data);

            // Clear previous ALCT inject
            adr     = alct_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFFD;
            status  = vme_write(adr,wr_data);

            // Set start_trigger state for FMM
            ttc_cmd = 6;            // start_trigger
            adr     = ccb_cmd_adr;
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);
            wr_data = 0x0003 | (ttc_cmd << 8);
            status  = vme_write(adr,wr_data);
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);

            ttc_cmd = 1;            // bx0
            wr_data = 0x0003 | (ttc_cmd << 8);
            status  = vme_write(adr,wr_data);
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);

            // Arm scope trigger
            scp_arm        = true;
            scp_readout    = false;
            scp_raw_decode = false;
            scp_silent     = false;
            scp_playback   = false;
            if (rdscope)
                scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

            // Clear previous  CLCT inject
            adr     = cfeb_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x7FFF;
            status  = vme_write(adr,wr_data);

            // Fire CLCT Injector
            wr_data = wr_data | 0x8000;
            status  = vme_write(adr,wr_data);

            // Clear previous inject    
            wr_data = rd_data & 0x7FFF;
            status  = vme_write(adr,wr_data);

            // Check scintillator veto is set
            adr    = seqmod_adr;
            status = vme_read(adr,rd_data);
            scint_veto = (rd_data>>13) & 0x1;
            if (scint_veto!=1) pause("scint veto failed to set");

            // Clear scintillator veto
            wr_data = rd_data | (1<<12);
            status  = vme_write(adr,wr_data);
            wr_data = wr_data ^ (1<<12);
            status  = vme_write(adr,wr_data);
            status  = vme_read(adr,rd_data);
            scint_veto = (rd_data>>12) & 0x1;
            if (scint_veto!=0) pause("scint veto failed to clear");

            // Read back embedded scope data
            scp_arm        = false;
            scp_readout    = true;
            scp_raw_decode = false;
            scp_silent     = true;
            scp_playback   = false;
            if (rdscope)
                scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);
        } // close InjectALCTCLCT()

        //------------------------------------------------------------------------------
        //  Inject ALCT+CLCT then readout raw hits
        //------------------------------------------------------------------------------
        int TMB::TriggerTestInjectALCTCLCT_Readout () {
            ifunc =1; 
            inquirb("Global", "rdscope", rdscope);

            if (ifunc<0) 
                rdscope = false;
            else         
                rdscope = true;

            // Turn off CCB backplane inputs, turn on L1A emulator
            adr     = ccb_cfg_adr;
            wr_data = 0x003D;
            status  = vme_write(adr,wr_data);

            // Enable sequencer trigger, turn off dmb trigger, set internal l1a delay
            adr     = ccb_trig_adr;
            wr_data = 0x0004;
            wr_data = wr_data | (l1a_delay << 8);
            status  = vme_write(adr,wr_data);

            // Turn off ALCT cable inputs, enable synchronized alct+clct triggers
            adr     = alct_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x0000;
            wr_data = wr_data | 0x0005;
            wr_data = wr_data | (alct_injector_delay << 5);
            status  = vme_write(adr,wr_data);

            // Set ALCT delay for TMB matching
            adr     = tmbtim_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFF0;
            wr_data = wr_data | 0x0003;
            status  = vme_write(adr,wr_data);

            // Turn off CLCT cable inputs
            adr     = cfeb_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFE0;
            status  = vme_write(adr,wr_data);

            // Turn on CFEB enables to over-ride mask_all
            adr     = seq_trig_en_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x03FF;     // clear old cfeb_en and source
            wr_data = wr_data | 0x7C00;     // ceb_en_source=0,cfeb_en=1F
            status  = vme_write(adr,wr_data);

            // Turn off internal level 1 accept for sequencer, set l1a window width
            adr     = seq_l1a_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x00FF;
            wr_data = wr_data | 0x0300;     // l1a window width
            status  = vme_write(adr,wr_data);

            // Take RAT out of sync mode
            adr     = vme_ratctrl_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFFE;
            status  = vme_write(adr,wr_data);

            // Enable RPC injector
            adr     = rpc_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFF80; // clear out old bits
            wr_data = wr_data | 0x0001; // rpc_mask_all 1=enable inputs from RPC

            if (rat_injector_sync) wr_data=wr_data | 0x0002;    // 1=enable RAT board injector
            else                   wr_data=wr_data | 0x0004;    // 1=enable RPC RAM internal injector

            rat_injector_delay=6;
            wr_data = wr_data | (rat_injector_delay << 3); // delay CLCT injector to wait for RAT
            status  = vme_write(adr,wr_data);

            // Select pattern trigger
            adr     = seq_trig_en_adr;
            status  = vme_read(adr,rd_data);
            rd_data = rd_data & 0xFF00;
            wr_data = rd_data | 0x0001;
            status  = vme_write(adr,wr_data);
            // Clear previous ALCT inject
            adr     = alct_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFFD;
            status  = vme_write(adr,wr_data);

            // Set start_trigger state for FMM
            ttc_cmd = 6;            // start_trigger
            adr     = ccb_cmd_adr;
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);
            wr_data = 0x0003 | (ttc_cmd << 8);
            status  = vme_write(adr,wr_data);
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);

            ttc_cmd = 1;            // bx0
            wr_data = 0x0003 | (ttc_cmd << 8);
            status  = vme_write(adr,wr_data);
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);

            // Clear DMB RAM write-address
            adr     = dmb_ram_adr;
            wr_data = 0x2000;   //reset RAM write address
            status  = vme_write(adr,wr_data);
            wr_data = 0x0000;   // unreset
            status  = vme_write(adr,wr_data);

            // Arm scope trigger
            scp_arm        = true;
            scp_readout    = false;
            scp_raw_decode = false;
            scp_silent     = false;
            scp_playback   = false;
            if (rdscope)
                scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

            // Fire CLCT+ALCT Injectors
            adr     = cfeb_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data | 0x8000; // fire injector
            status  = vme_write(adr,wr_data);
            wr_data = rd_data & 0x7FFF; // unfire
            status  = vme_write(adr,wr_data);

            // Read back embedded scope data
            scp_arm        = false;
            scp_readout    = true;
            scp_raw_decode = false;
            scp_silent     = true;
            scp_playback   = false;
            if (rdscope)
                scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

            // Get DMB RAM word count and busy bit
            adr       = dmb_wdcnt_adr;
            status    = vme_read(adr,rd_data);
            dmb_wdcnt = rd_data & 0x0FFF;
            dmb_busy  = (rd_data >> 14) & 0x0001;

            (*MyOutput_) << "dmb word count = " << dmb_wdcnt;
            (*MyOutput_) << "dmb busy       = " << dmb_busy;

            if (dmb_busy!=0) {
                pause ("Can not read RAM: dmb reports busy");
                return EXIT_FAILURE; 
            }

            if (dmb_wdcnt<=0) {
                pause ("Can not read RAM: dmb reports word count <=0");
                return EXIT_FAILURE; 
            }

            (*MyOutput_) << "\nProcessing Dump\n"; 

            // Write RAM read address to TMB
            for (iadr=0; iadr<=dmb_wdcnt-1; ++iadr) {
                adr     = dmb_ram_adr;
                wr_data = iadr & 0xFFFF;
                status  = vme_write(adr,wr_data);

                // Read RAM data from TMB
                adr    = dmb_rdata_adr;
                status = vme_read(adr,rd_data);         // read lsbs
                dmb_rdata_lsb=rd_data;

                adr    = dmb_wdcnt_adr;
                status = vme_read(adr,rd_data);         // read msbs
                dmb_rdata_msb = (rd_data >> 12) & 0x3;  // rdata msbs

                dmb_rdata = dmb_rdata_lsb | (dmb_rdata_msb << 16);

                std::cout << "\tAdr=" << iadr << " Data=" << std::hex << dmb_rdata << std::endl;

            }   // close iadr

            // Clear RAM address for next event
            adr     = dmb_ram_adr;
            wr_data = 0x2000;   // reset RAM write address
            status  = vme_write(adr,wr_data);
            wr_data = 0x0000;   // unreset
            status  = vme_write(adr,wr_data);
            return 0; 
        } // close InjectALCTCLCT_Readout()

        //------------------------------------------------------------------------------
        //  Fire L1A to ALCT for timing-in clock + read
        //  (Fire ext_trig + L1A to ALCT + readout ALCT RAM)
        //------------------------------------------------------------------------------
        int TMB::TriggerTestFire_L1A_to_ALCT () {
            ifunc=1;
            inquirb("Global", "rdscope", rdscope);
            //L16500:
            (*MyOutput_) << "ALCT test started" << std::endl;

            // Turn off CCB inputs to zero alct_adb_sync and ext_trig
            adr     = ccb_cfg_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFBF;         // Clear previous l1a
            wr_data = wr_data | 0x1;            // Turn off CCB backplane
            status  = vme_write(adr,wr_data);

            // Enable ALCT cable ports
            adr     = vme_loopbk_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data | 0x000C;         // alct_rxoe=txoe=1
            status  = vme_write(adr,wr_data);

            // Clear last event
            adr     = alctfifo1_adr;
            wr_data = 1;                        // reset word counter
            status  = vme_write(adr,wr_data);
            wr_data = 0;                        // enable word counter
            status  = vme_write(adr,wr_data);

            // Make sure alct fifo went unbusy
            adr    = alct_fifo_adr;
            status = vme_read(adr,rd_data);
            alct_raw_busy = (rd_data >> 0) & 0x0001;
            alct_raw_done = (rd_data >> 1) & 0x0001;
            if (alct_raw_busy==1) 
                pause("alct fifo failed to clear");

            // Fire ext_trig to ALCT board
            //L16510:
            adr     = alct_cfg_adr;
            status  = vme_read(adr,rd_data);    // get current state
            wr_data = rd_data & 0xFFF0;         // clear bits[3:0] alct ext trig
            wr_data = wr_data | 0x0004;         // fire alct ext trig
            //  wr_data = wr_data | 0x0008;         // or fire alct ext inject
            status  = vme_write(adr,wr_data);
            wr_data = rd_data & 0xFFF0;         // clear bits[3:0] alct ext trig
            status  = vme_write(adr,wr_data);

            // Read ALCT trigger words
            adr    = alct_alct0_adr;
            status = vme_read(adr,rd_data);     // get current state
            alct0_rd = rd_data;

            adr    = alct_alct1_adr;
            status = vme_read(adr,rd_data);     // get current state
            alct1_rd = rd_data;

            if (ifunc>0)
            {
                (*MyOutput_) << "\tALCT0=" << std::hex << alct0_rd << std::endl;
                (*MyOutput_) << "\tALCT1=" << std::hex << alct1_rd << std::endl;
                if (alct0_rd==alct0_prev) 
                    (*MyOutput_) << "\tALCT LCT0 unchanged\n";
                if (alct1_rd==alct1_prev) 
                    (*MyOutput_) << "\tALCT LCT1 unchanged\n";
            }
            alct0_prev = alct0_rd;
            alct1_prev = alct1_rd;

            // Fire CCB L1A oneshot to ALCT
            adr     = ccb_cfg_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFBF;         // Clear previous l1a
            wr_data = wr_data | 0x1;            // Turn off CCB backplane
            wr_data = wr_data | 0x0040;         // Fire ccb L1A oneshot
            status  = vme_write(adr,wr_data);
            wr_data = wr_data & 0xFFBF;         // Clear previous l1a   
            status  = vme_write(adr,wr_data);

            // Check alct fifo status
            for (i=1; i<=100; ++i)              // cheap readout delay 
            {
                adr    = alct_fifo_adr;
                status = vme_read(adr,rd_data);
                alct_raw_busy = (rd_data >> 0) & 0x0001;
                alct_raw_done = (rd_data >> 1) & 0x0001;
                if (alct_raw_busy==0) 
                    break; 
            }
            pause("alct fifo stuck busy");

            //L16520:
            (*MyOutput_) << "\tALCT L1A alct_raw_done waits=" << i << std::endl;
            if (alct_raw_done!=1) pause("alct fifo not done");

            // Get alct word count
            adr    = alct_fifo_adr;    // alct word count
            status = vme_read(adr,rd_data);
            alct_raw_nwords = (rd_data >> 2) & 0x07FF;
            (*MyOutput_) << "alct_raw_nwords=" << alct_raw_nwords << std::endl;

            // Read alct fifo data
            for (i=0; i<=std::max(alct_raw_nwords-1,0); ++i) {
                //  for (i=1; i<=alct_raw_nwords; ++i) 
                adr     = alctfifo1_adr;
                wr_data = (i<<1);                   // ram read address
                status  = vme_write(adr,wr_data);

                adr     = alctfifo2_adr;   // alct raw data lsbs
                status  = vme_read(adr,rd_data);
                alct_raw_data = rd_data;
                (*MyOutput_) << "adr=4i alct raw lsbs=" << std::hex << rd_data << std::endl;

                adr     = alct_fifo_adr;   // alct raw data msbs
                status  = vme_read(adr,rd_data);
                (*MyOutput_) << "adr=4i alct raw msbs=" << std::hex << rd_data << std::endl;
                rd_data = (rd_data>>13) & 0x0003;
                alct_raw_data = alct_raw_data | (rd_data<<16);

                if (i<mxframe) vf_data[i] = alct_raw_data;
                if (i<=3 || i>=alct_raw_nwords-4)
                    (*MyOutput_) << "\t" << i << " " << std::hex << alct_raw_data << std::endl;
            }

            // calculate CRC for data stream
            dmb_wdcnt = alct_raw_nwords;
            if (dmb_wdcnt<5) {
                (*MyOutput_) << "Raw hits dump too short for crc calc dmb_wdcnt=" << dmb_wdcnt << std::endl;
                pause("<cr> to resume");
                return EXIT_FAILURE; 
            }

            for (iframe=0; iframe<=dmb_wdcnt-1-4; ++iframe) // dont include last 4 frames
            {
                din = vf_data[iframe];
                if (iframe==0) crc22a(din,crc,1);               // reset crc
                else           crc22a(din,crc,0);
            }

            // compare our computed CRC to what TMB computed
            tmb_crc_lsb = vf_data[dmb_wdcnt-1-3] & 0x07FF;  // 11 crc bits per frame
            tmb_crc_msb = vf_data[dmb_wdcnt-1-2] & 0x07FF;  // 11 crc bits per frame
            tmb_crc     = tmb_crc_lsb | (tmb_crc_msb<<11);  // full 22 bit crc
            crc_match   = crc==tmb_crc;

            (*MyOutput_) <<  "calc_crc=" << std::hex << crc << " alct_crc=" << std::hex << tmb_crc << "match=" << logical(crc_match) << std::endl;

            if (!crc_match) pause("ALCT crc error, WTF!");
            return EXIT_FAILURE; 
        } // close void Fire_L1A_to_ALCT ()

        //------------------------------------------------------------------------------
        //  Fire CLCT ext trig linked with ALCT ext trig
        //------------------------------------------------------------------------------
        void TMB::TriggerTestFire_CLCT_ext_trig_with_ALCT () {
            ifunc=1;
            inquirb("Global", "rdscope", rdscope);
            while(true) {
                //L16600:
                adr     = ccb_trig_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFFEF;         // Clear previous trigger
                status  = vme_write(adr,wr_data);
                wr_data = wr_data | 0x0030;         // Fire CLCT ext trig linked with ALCT ext trig
                status  = vme_write(adr,wr_data);
                wr_data = rd_data & 0xFFEF;         // Clear previous trigger   
                status  = vme_write(adr,wr_data);
                if (ifunc<0) break; 
            }
        } //close fire_CLCT_ext_trig_with_ALCT ()

        //------------------------------------------------------------------------------
        //  Inject walking CLCT muon check CLCT0 1/2strip
        //  (Fire CLCT Pattern Injector, Check CLCT0)
        //------------------------------------------------------------------------------
        void TMB::TriggerTestInject_walking_CLCT() {
            ifunc=1;
            inquirb("Global", "rdscope", rdscope);
            first_event = true;
            first_scn   = true;

            if (ifunc<0) rdscope = false;
            else         rdscope = true;

            // Get csc_id
            adr    = seq_id_adr;
            status = vme_read(adr,rd_data);
            csc_id = (rd_data >> 5) & 0x1F;

            // Get current thresholds
            adr    = seq_clct_adr;
            status = vme_read(adr,rd_data);
            triad_persist       = (rd_data >>  0) & 0xF;    // 4 bits
            hit_thresh_pretrig  = (rd_data >>  4) & 0x7;    // 3 bits
            dmb_thresh_pretrig  = (rd_data >>  7) & 0x7;    // 3 bits
            hit_thresh_postdrift= (rd_data >> 10) & 0x7;    // 3 bits
            drift_delay         = (rd_data >> 13) & 0x3;    // 2 bits

            adr    = pattern_find_pretrg_adr;
            status = vme_read(adr,rd_data);
            pid_thresh_pretrig  = (rd_data >> 2) & 0xF;     // 4 bits
            pid_thresh_postdrift= (rd_data >> 6) & 0xF;     // 4 bits

            adr    = layer_trg_mode_adr;
            status = vme_read(adr,rd_data);
            lyr_thresh_pretrig = (rd_data >> 1) & 0xF;      // 4 bits

            // Get current adjacent cfeb separation
            adr    = pattern_find_pretrg_adr;
            status = vme_read(adr,rd_data);
            adjcfeb_dist=(rd_data >> 10) & 0x3F;

            // Get current CLCT separation
            adr    = clct_separation_adr;
            status = vme_read(adr,rd_data);
            clct_sep = (rd_data >> 8) & 0xFF;

            // Get current active_feb_list source
            adr    = seqmod_adr;
            status = vme_read(adr,rd_data);
            active_feb_src=(rd_data >> 14) & 0x1;

            // Get current cfeb tbins
            adr    = seq_fifo_adr;
            status = vme_read(adr,rd_data);

            fifo_mode       = (rd_data >>  0) & 0x07;   // 3 bits
            fifo_tbins      = (rd_data >>  3) & 0x1F;   // 5 bits
            fifo_pretrig    = (rd_data >>  8) & 0x1F;   // 5 bits
            bcb_read_enable = (rd_data >> 15) & 0x1;    // 1 bit
            bcb_read_enable = 1;    //! set to 1 manually until it becomes the default
            if (fifo_tbins==0) fifo_tbins=32;

            // Get current match parameters
            adr    = tmbtim_adr;
            status = vme_read(adr,rd_data);

            alct_delay      = (rd_data >> 0) & 0xF;     // 4 bits
            clct_width      = (rd_data >> 4) & 0xF;     // 4 bits

            // Get current tmb_match mode
            adr    = tmb_trig_adr;
            status = vme_read(adr,rd_data);

            tmb_allow_alct  = (rd_data >> 2) & 0x1;     // 1 bit
            tmb_allow_clct  = (rd_data >> 3) & 0x1;     // 1 bit
            tmb_allow_match = (rd_data >> 4) & 0x1;     // 1 bit

            // Get current tmb_match mode for ME1AB
            adr    = non_trig_readout_adr;
            status = vme_read(adr,rd_data);

            tmb_allow_alct_ro   = (rd_data >> 0) & 0x1; // 1=Allow ALCT-only non-triggering readout
            tmb_allow_clct_ro   = (rd_data >> 1) & 0x1; // 1=Allow CLCT-only non-triggering readout
            tmb_allow_match_ro  = (rd_data >> 2) & 0x1; // 1=Allow ALCT*CLCT non-triggering readout
            mpc_me1a_block      = (rd_data >> 3) & 0x1; // Block ME1A LCTs from MPC, still queue for readout

            // Get current alct injector delay
            adr    = alct_inj_adr;
            status = vme_read(adr,rd_data);
            alct_injector_delay=(rd_data >> 5) & 0x1F;  // 5 bits

            // Get current alct bx0 enable
            adr    = bx0_delay_adr;
            status = vme_read(adr,rd_data);
            alct_bx0_en=(rd_data >> 8) & 0x1;           // 1 bit

            // Get current rat injector delay and data=address mode
            adr    = rpc_inj_adr;
            status = vme_read(adr,rd_data);
            inj_delay_rat  = (rd_data >>  3) & 0xF;     // 4 bits
            rpc_tbins_test = (rd_data >> 15) & 0x1;     // 1bit

            // Get current RPC readout list
            adr    = rpc_cfg_adr;
            status = vme_read(adr,rd_data);
            rpc_exists=(rd_data >> 0) & 0x3;            // 2 bits

            // Get current RPC tbins
            adr    = rpc_tbins_adr;
            status = vme_read(adr,rd_data);

            fifo_tbins_rpc  = (rd_data >> 0) & 0x1F;    // 5 bits
            fifo_pretrig_rpc= (rd_data >> 5) & 0x1F;    // 5 bits
            rpc_decouple    = (rd_data >>10) & 0x1F;    // 5 bits
            if (fifo_tbins_rpc==0) fifo_tbins_rpc=32;

            // Get scope-in-readout
            adr    = scp_ctrl_adr;
            status = vme_read(adr,rd_data);
            scp_auto   =(rd_data >> 3) & 0x1;           // 1 bit
            scp_nowrite=(rd_data >> 4) & 0x1;           // 1 bit
            scp_tbins  =(rd_data >> 5) & 0x7;           // 3 bits

            // Get miniscope-in-readout
            adr    = miniscope_adr;
            status = vme_read(adr,rd_data);
            mini_read_enable    =(rd_data >> 0) & 0x1;  // 1 bit
            mini_test           =(rd_data >> 1) & 0x1;  // 1 bit
            mini_tbins_word     =(rd_data >> 2) & 0x1;  // 1 bit
            fifo_tbins_mini     =(rd_data >> 3) & 0x1F; // 5 bits
            fifo_pretrig_mini   =(rd_data >> 8) & 0x1F; // 5 bits

            // Get L1A delay
            adr     = ccb_trig_adr;
            status  = vme_read(adr,rd_data);
            l1a_delay = (rd_data >> 8) & 0xFF;

            if (first_event)l1a_delay=119;              // hits 0th l1a window bx, override TMB default

            // Get L1A lookback
            adr    = l1a_lookback_adr;
            status = vme_read(adr,rd_data);
            l1a_lookback = (rd_data & 0x07FF);

            // Get sync error forced
            adr    = sync_err_control_adr;
            status = vme_read(adr,rd_data);
            sync_err_force = (rd_data>>15) & 0x1;

            // Inquire
            cprr           = true;
            cprr_ignore    = false;
            layer_mode     = false;
            pause_on_fail  = false;
            rpcs_in_rdout  = true;
            rrhd           = true;
            mcl            = mxclcts-1;
            vme_bx0_emu_en = vme_bx0_emu_en_default;
            send_emulator_to_tmb     = true;
            load_clct_injector_image = false;

            for (iclct=0; iclct<mxclcts; ++iclct)
            {
                clct_key_inject[iclct] = -1;
                clct_pid_inject[iclct] = 0xA;
                clct_hit_inject[iclct] = 0;
                clct_blanked[iclct]    = false;
                loop_keys[iclct]       = false;
                loop_pids[iclct]       = false;
                clct_hit_inject_clip[iclct] = 0;
            }

            inquirb("WalkingCLCT", "cprr", 						cprr);
            inquire("WalkingCLCT", "vme_bx0_emu_en", 			minv= 0, maxv=  1, radix=10, vme_bx0_emu_en);
            inquire("WalkingCLCT", "sync_err_force", 			minv= 0, maxv=  1, radix=10, sync_err_force);
            inquire("WalkingCLCT", "csc_id", 					minv= 0, maxv= 31, radix=10, csc_id);
            inquirb("WalkingCLCT", "layer_mode", 				layer_mode);

            if (layer_mode)
                inquire("WalkingCLCT", "lyr_thresh_pretrig", minv= 0, maxv= 7, radix=10, lyr_thresh_pretrig);

            inquire("WalkingCLCT", "hit_thresh_pretrig", 		minv= 0, maxv=  7, radix=10, hit_thresh_pretrig);
            inquire("WalkingCLCT", "pid_thresh_pretrig", 		minv= 0, maxv= 15, radix=16, pid_thresh_pretrig);
            inquire("WalkingCLCT", "dmb_thresh_pretrig", 		minv= 0, maxv=  7, radix=10, dmb_thresh_pretrig);
            inquire("WalkingCLCT", "hit_thresh_postdrift", 		minv= 0, maxv=  7, radix=10, hit_thresh_postdrift);
            inquire("WalkingCLCT", "pid_thresh_postdrift", 		minv= 0, maxv= 15, radix=16, pid_thresh_postdrift);
            inquire("WalkingCLCT", "adjcfeb_dist", 				minv= 0, maxv= 63, radix=10, adjcfeb_dist);
            inquire("WalkingCLCT", "active_feb_src", 			minv= 0, maxv=  1, radix=10, active_feb_src);
            inquire("WalkingCLCT", "triad_persist", 			minv= 0, maxv= 15, radix=10, triad_persist);
            inquire("WalkingCLCT", "drift_delay", 				minv= 0, maxv=  3, radix=10, drift_delay);
            inquire("WalkingCLCT", "clct_width", 				minv= 0, maxv= 15, radix=10, clct_width);
            inquire("WalkingCLCT", "alct_delay", 				minv= 0, maxv= 15, radix=10, alct_delay);
            inquire("WalkingCLCT", "alct_injector_delay", 		minv= 0, maxv= 15, radix=10, alct_injector_delay);
            inquire("WalkingCLCT", "alct_bx0_en", 				minv= 0, maxv=  2, radix=10, alct_bx0_en);
            inquirb("WalkingCLCT", "send_emulator_to_tmb", 		send_emulator_to_tmb);
            inquire("WalkingCLCT", "mpc_me1a_block", 			minv= 0, maxv=mcl, radix=10, mpc_me1a_block);
            inquire("WalkingCLCT", "clct_sep", 					minv= 0, maxv=255, radix=10, clct_sep);
            inquirb("WalkingCLCT", "load_clct_injector_image", 	load_clct_injector_image);
            inquire("WalkingCLCT", "nalcts_inject", 			minv= 0, maxv=  2, radix=10, nalcts_inject);
            inquire("WalkingCLCT", "nclcts_inject", 			minv= 0, maxv=mcl, radix=10, nclcts_inject);

            for (iclct=0; iclct<nclcts_inject; ++iclct) {
                if (nclcts_inject>=mxclcts) 
                    stop("nclcts_inject>=mxclct");

                if (iclct==0) {
                    clct_hit_inject[iclct] = 6;
                    inquire("WalkingCLCT", "clct0_key_inject", minv=-1, maxv=159, radix=10, clct_key_inject[iclct]);
                    inquire("WalkingCLCT", "clct0_pid_inject", minv=-1, maxv=0xA, radix=16, clct_pid_inject[iclct]);
                    inquire("WalkingCLCT", "clct0_hit_inject", minv= 0, maxv=6,   radix=10, clct_hit_inject[iclct]);
                }
                if (iclct==1) {
                    clct_hit_inject[iclct] = 5;
                    inquire("WalkingCLCT", "clct1_key_inject", minv=-1, maxv=159, radix=10, clct_key_inject[iclct]);
                    inquire("WalkingCLCT", "clct1_pid_inject", minv=-1, maxv=0xA, radix=16, clct_pid_inject[iclct]);
                    inquire("WalkingCLCT", "clct1_hit_inject", minv= 0, maxv=6,   radix=10, clct_hit_inject[iclct]);
                }
                if (iclct>=2) {
                    clct_hit_inject[iclct] = 4;
                    inquire("WalkingCLCT", "clct2_key_inject", minv=-1, maxv=159, radix=10, clct_key_inject[iclct]);
                    inquire("WalkingCLCT", "clct2_pid_inject", minv=-1, maxv=0xA, radix=16, clct_pid_inject[iclct]);
                    inquire("WalkingCLCT", "clct2_hit_inject", minv= 0, maxv=6,   radix=10, clct_hit_inject[iclct]);
                }
            }   // close for iclct


            inquire("WalkingCLCT", "triad_1st_tbin_0", 		minv= 0, maxv=  1, radix=10, triad_1st_tbin[0]);
            inquire("WalkingCLCT", "triad_1st_tbin_1", 		minv= 0, maxv=  1, radix=10, triad_1st_tbin[1]);
            inquire("WalkingCLCT", "triad_1st_tbin_2", 		minv= 0, maxv=  1, radix=10, triad_1st_tbin[2]);
            inquire("WalkingCLCT", "triad_1st_tbin_3", 		minv= 0, maxv=  1, radix=10, triad_1st_tbin[3]);
            inquire("WalkingCLCT", "triad_1st_tbin_4", 		minv= 0, maxv=  1, radix=10, triad_1st_tbin[4]);
            inquire("WalkingCLCT", "triad_1st_tbin_5", 		minv= 0, maxv=  1, radix=10, triad_1st_tbin[5]);

            inquire("WalkingCLCT", "tmb_allow_match",  		minv= 0, maxv=  1, radix=10, tmb_allow_match);
            inquire("WalkingCLCT", "tmb_allow_alct",   		minv= 0, maxv=  1, radix=10, tmb_allow_alct);
            inquire("WalkingCLCT", "tmb_allow_clct",   		minv= 0, maxv=  1, radix=10, tmb_allow_clct);
            inquire("WalkingCLCT", "tmb_allow_match_ro",	minv= 0, maxv=  1, radix=10, tmb_allow_match_ro);
            inquire("WalkingCLCT", "tmb_allow_alct_ro",		minv= 0, maxv=  1, radix=10, tmb_allow_alct_ro);
            inquire("WalkingCLCT", "tmb_allow_clct_ro",		minv= 0, maxv=  1, radix=10, tmb_allow_clct_ro);
            inquirb("WalkingCLCT", "rrhd",                 	rrhd);
            inquire("WalkingCLCT", "fifo_tbins",        	minv= 0, maxv= 31, radix=10, fifo_tbins);
            inquire("WalkingCLCT", "fifo_pretrig",      	minv= 0, maxv= 31, radix=10, fifo_pretrig);
            inquire("WalkingCLCT", "fifo_mode",         	minv= 0, maxv=  7, radix=10, fifo_mode);
            inquire("WalkingCLCT", "bcb_read_enable",   	minv= 0, maxv=  1, radix=10, bcb_read_enable);
            inquire("WalkingCLCT", "l1a_delay",         	minv= 0, maxv=256, radix=10, l1a_delay);
            inquire("WalkingCLCT", "l1a_lookback",      	minv= 0, maxv=256, radix=10, l1a_lookback);

            inquirb("WalkingCLCT", "rat_injector_sync",		rat_injector_sync);
            inquirb("WalkingCLCT", "rat_injector_enable", 	rat_injector_enable); 
            inquire("FireL1AEvent", "rat_sync_mode", 		minv= 0, maxv=1,   radix=10, rat_sync_mode);		//update this
            inquire("WalkingCLCT", "inj_delay_rat", 		minv= 0, maxv=256, radix=10, inj_delay_rat);
            inquire("WalkingCLCT", "rpc_tbins_test",		minv= 0, maxv=  1, radix=10, rpc_tbins_test);
            inquirb("WalkingCLCT", "rpcs_in_rdout", 		rpcs_in_rdout);

            int rpc0_exists;
            int rpc1_exists;
            inquire("FireL1AEvent", "rpc0_exists", 		minv= 0, maxv=1,   radix=10, rpc0_exists);
            inquire("FireL1AEvent", "rpc1_exists", 		minv= 0, maxv=1,   radix=10, rpc1_exists);
            if (n!=0) rpc_exists= (rpc1_exists<<1) | rpc0_exists; 


            inquire("WalkingCLCT", "rpc_decouple", 			minv= 0, maxv=  1, radix=10, rpc_decouple);
            inquire("WalkingCLCT", "fifo_tbins_rpc", 		minv= 0, maxv= 31, radix=10, fifo_tbins_rpc);
            inquire("WalkingCLCT", "fifo_pretrig_rpc", 		minv= 0, maxv= 31, radix=10, fifo_pretrig_rpc);
            inquire("WalkingCLCT", "scp_auto", 				minv= 0, maxv=  1, radix=10, scp_auto);
            inquire("WalkingCLCT", "scp_tbins", 			minv= 0, maxv= 31, radix=10, scp_tbins);
            inquire("WalkingCLCT", "scp_nowrite", 			minv= 0, maxv=  1, radix=10, scp_nowrite);    // nowrite=1 uses tmb scope ram initial test pattern
            inquire("WalkingCLCT", "mini_read_enable", 		minv= 0, maxv= 31, radix=10, mini_read_enable);

            if (mini_read_enable==1) {
                inquire("WalkingCLCT", "mini_test", 		minv= 0, maxv= 31, radix=10, mini_test);
                inquire("WalkingCLCT", "mini_tbins_word", 	minv= 0, maxv= 31, radix=10, mini_tbins_word);
                inquire("WalkingCLCT", "fifo_tbins_mini", 	minv= 0, maxv= 31, radix=10, fifo_tbins_mini);
                inquire("WalkingCLCT", "fifo_pretrig_mini", minv= 0, maxv= 31, radix=10, fifo_pretrig_mini);
            }

            inquirb("WalkingCLCT", "pause_on_fail", 		pause_on_fail);


            // Turn off CFEB cable inputs
            while(true) {  //CLCT Bang Mode loop
                adr       = cfeb_inj_adr;
                mask_all  = 0x00;   // 5'b00000 disables cfeb inputs
                febsel    = 0x00;   // Injector RAM select
                mask_cfeb = 0x00;   // Injector RAMs to fire
                inj_trig  = 0;      // Injector fire bit       
                wr_data   = (mask_all  << 0)  |
                    (febsel    << 5)  |
                    (mask_cfeb << 10) |
                    (inj_trig  << 15);
                status    = vme_write(adr,wr_data);

                // Turn off GTX optical receiver inputs
                adr     = adr_virtex6_gtx_rx_all;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFFFE;     // Turn of enable_all bt
                status  = vme_write(adr,wr_data);

                // Turn off ALCT cable inputs, enable synchronized alct+clct triggers
                adr     = alct_inj_adr;
                status  = vme_read(adr,rd_data);

                alct_injector_delay=13;

                wr_data = rd_data & 0x0000;
                wr_data = wr_data | 0x0005;
                wr_data = wr_data | (alct_injector_delay << 5);
                status  = vme_write(adr,wr_data);

                // Turn on CFEB enables to over-ride mask_all
                adr     = seq_trig_en_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0x03FF;                 // clear old cfeb_en and source
                wr_data = wr_data | 0x7C00;                 // ceb_en_source=0,cfeb_en=1F
                status  = vme_write(adr,wr_data);

                // Reset bad bits
                adr     = cfeb_badbits_ctrl_adr;   // CFEB  Bad Bit Control/Status
                status  = vme_read(adr,rd_data);            // read current
                rd_data = rd_data & 0xFFE0;                 // clean out old reset bits
                wr_data = rd_data | 0x001F;                 // assert reset[4:0]
                status  = vme_write(adr,wr_data);           // write reset
                wr_data = rd_data;                          // retrieve original register contents
                status  = vme_write(adr,wr_data);           // restore register with resets off

                // Enable sequencer trigger, turn off dmb trigger, set internal l1a delay
                adr     = ccb_trig_adr;
                wr_data = 0x0004;
                wr_data = wr_data | (l1a_delay << 8);
                status  = vme_write(adr,wr_data);

                // Set csc_id
                adr    = seq_id_adr;
                status = vme_read(adr,rd_data);
                wr_data = rd_data & ~(0x1F << 5);           // clear old csc_id
                wr_data = wr_data | (csc_id << 5);          // new csc_id
                status  = vme_write(adr,wr_data);

                // Set L1A lookback
                adr     = l1a_lookback_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & ~0x07FF;
                wr_data = wr_data | (l1a_lookback << 0);
                status  = vme_write(adr,wr_data);

                // Turn off CCB backplane inputs, turn on L1A emulator, do this after turning off cfeb and alct cable inputs
                adr     = ccb_cfg_adr;
                wr_data = 0x0000;
                wr_data = wr_data | 0x0001; // ccb_ignore_rx
                wr_data = wr_data | 0x0004; // ccb_int_l1a_en
                wr_data = wr_data | 0x0008; // ccb_status_oe_vme
                wr_data = wr_data | 0x0010; // alct_status_en
                wr_data = wr_data | 0x0020; // clct_status_en
                wr_data = wr_data | (vme_bx0_emu_en << 15); // bx0 emualtor
                status  = vme_write(adr,wr_data);

                vme_bx0_emu_en_default = vme_bx0_emu_en;    // update default so u dont have to keep entering

                // Set ALCT delay for TMB matching
                adr     = tmbtim_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFF00;
                wr_data = wr_data | (alct_delay << 0);
                wr_data = wr_data | (clct_width << 4);
                status  = vme_write(adr,wr_data);

                // Set tmb_match mode
                adr     = tmb_trig_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFFE7;     // clear bits 4,3
                wr_data = wr_data | (tmb_allow_alct  << 2);
                wr_data = wr_data | (tmb_allow_clct  << 3);
                wr_data = wr_data | (tmb_allow_match << 4);
                status  = vme_write(adr,wr_data);

                // Set tmb_match mode for ME1AB
                adr     = non_trig_readout_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFFF0;
                wr_data = wr_data | (tmb_allow_alct_ro  << 0);  // 1=Allow ALCT-only non-triggering readout
                wr_data = wr_data | (tmb_allow_clct_ro  << 1);  // 1=Allow CLCT-only non-triggering readout
                wr_data = wr_data | (tmb_allow_match_ro << 2);  // 1=Allow ALCT*CLCT non-triggering readout
                wr_data = wr_data | (mpc_me1a_block     << 3);  // Block ME1A LCTs from MPC, still queue for readout
                status  = vme_write(adr,wr_data);

                // Set alct bx0 enable
                adr     = bx0_delay_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & ~(1 << 8);
                wr_data = wr_data | (alct_bx0_en << 8);
                status  = vme_write(adr,wr_data);

                // Turn on layer trigger mode if its selected
                layer_trig_en=0;
                if (layer_mode) layer_trig_en=1;
                adr     = layer_trg_mode_adr;
                wr_data = layer_trig_en | (lyr_thresh_pretrig << 1);
                status  = vme_write(adr,wr_data);

                // Turn off internal level 1 accept for sequencer, set l1a window width
                adr     = seq_l1a_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0x00FF;
                wr_data = wr_data | 0x0300;         //  l1a window width
                status  = vme_write(adr,wr_data);

                // Set fifo tbins
                adr     = seq_fifo_adr;
                status  = vme_read(adr,rd_data);    // get current
                wr_data = rd_data & 0xF000;         // clear lower bits

                wr_data=wr_data
                    | ((fifo_mode       & 0x7 ) <<  0)  // [2:0]
                    | ((fifo_tbins      & 0x1F) <<  3)  // [7:3]
                    | ((fifo_pretrig    & 0x1F) <<  8)  // [12:8]
                    | ((bcb_read_enable & 0x1 ) << 15); // [15]

                status = vme_write(adr,wr_data);

                // Set pid_thresh_pretrig, pid_thresh_postdrift
                adr    = pattern_find_pretrg_adr;
                status = vme_read(adr,rd_data);

                wr_data=rd_data & 0xFC03;
                wr_data=wr_data | (pid_thresh_pretrig   << 2);  // 4 bits
                wr_data=wr_data | (pid_thresh_postdrift << 6);  // 4 bits

                status = vme_write(adr,wr_data);

                // Set adjcfeb_dist
                adr     = pattern_find_pretrg_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0x03FF;         // adjcfeb_dist[5:0] is in [15:10]
                wr_data = wr_data | (adjcfeb_dist << 10);
                status  = vme_write(adr,wr_data);

                // Set CLCT separation
                adr     = clct_separation_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0x00FF;
                wr_data = wr_data | (clct_sep << 8);
                status  = vme_write(adr,wr_data);

                // Set active_feb_list source
                adr     = seqmod_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & ~(1 << 14);
                wr_data = wr_data | (active_feb_src << 14);
                status  = vme_write(adr,wr_data);

                // Set RAT out of sync mode
                adr     = vme_ratctrl_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFFFE;
                wr_data = wr_data | rat_sync_mode;
                status  = vme_write(adr,wr_data);

                // Set miniscope
                adr     = miniscope_adr;
                wr_data = 0;
                wr_data = wr_data | (mini_read_enable  << 0);   // 1 bit
                wr_data = wr_data | (mini_test         << 1);   // 1 bit
                wr_data = wr_data | (mini_tbins_word   << 2);   // 1 bit
                wr_data = wr_data | (fifo_tbins_mini   << 3);   // 5 bits
                wr_data = wr_data | (fifo_pretrig_mini << 8);   // 5 bits
                status  = vme_write(adr,wr_data);

                // Include RPCs in readout
                adr     = rpc_cfg_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFFEC;                     //  Turn off bits4,1,0
                wr_data = wr_data | (rpc_exists & 0x3);         //  Turn on existing RPCs
                if (rpcs_in_rdout) wr_data=wr_data | (1 << 4);  //  Turn on bit 4 to enable
                status  = vme_write(adr,wr_data);

                // Set RPC tbins
                adr     = rpc_tbins_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xF800;                     // Clear out old values
                wr_data = wr_data | (fifo_tbins_rpc     <<  0); // 5 bits
                wr_data = wr_data | (fifo_pretrig_rpc   <<  5); // 5 bits
                wr_data = wr_data | (rpc_decouple       << 10); // 5 bits
                status  = vme_write(adr,wr_data);

                // Enable RPC injector
                adr     = rpc_inj_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFF80;                 // Clear out old bits
                wr_data = wr_data | 0x0001;                 // rpc_mask_all 1=enable inputs from RPC
                if (rat_injector_enable) {
                    if (rat_injector_sync  ) {
                        wr_data = wr_data | 0x0002; }               // 1=enable RAT board injector
                    else {
                        wr_data = wr_data & 0xFFFE;                 // Turn off bit[0], masks RPC signals from RAT
                        wr_data = wr_data | 0x0004;                 // 1=enable TMBs RPC RAM internal injector
                        (*MyOutput_) << "\tUsing TMBs RPC Injector RAM, RAT disconnected.\n";
                    }}

                //  rat_injector_delay=7;
                wr_data = wr_data | (inj_delay_rat  <<  3); // delay CLCT injector to wait for RAT
                wr_data = wr_data | (rpc_tbins_test << 15); // Data=daddress mode
                status  = vme_write(adr,wr_data);

                // Load RPC injector RAM
                if (rat_injector_enable && !rat_injector_sync) {

                    adr     = rpc_inj_adr;             // Get current injector control
                    status  = vme_read(adr,rd_data);
                    wr_data = rd_data & 0x807F;                 // Clear injector data, set inj_sel=0 to point to pad rams
                    status  = vme_write(adr,wr_data);

                    for (irpc=0; irpc<=1;   ++irpc) {           // Create rpc pad+bxn image
                        for (ibxn=0; ibxn<=255; ++ibxn) {

                            if (ibxn <= 255) {
                                if (irpc==0) rpc_pad=ibxn | (0xAB << 8);    // rpc0 pads AB00-ABFF
                                if (irpc==1) rpc_pad=ibxn | (0xCD << 8);    // rpc1 pads CD00-CDFF
                                rpc_inj_bxn=7-ibxn;
                                rpc_inj_image[ibxn][irpc]=rpc_pad | (rpc_inj_bxn << 16);}
                            else {
                                rpc_inj_image[ibxn][irpc]=0;                // zero the rest of the ram
                            }   // close if ibxn
                        }   // close do ibxn
                    }   // close do irpc

                    for (irpc=0; irpc<=1;   ++ irpc) {
                        for (ibxn=0; ibxn<=255; ++ ibxn) {
                            std::cout << "rpc_inj_image writing " << ibxn << " " << irpc << " " << std::hex << rpc_inj_image[ibxn][irpc] << std::endl;
                            adr     = rpc_inj_wdata_adr;       // pad data to write to ram
                            wr_data = rpc_inj_image[ibxn][irpc] & 0x0000FFFF;
                            status  = vme_write(adr,wr_data);

                            adr     = rpc_inj_adr;             // get current injector control
                            status  = vme_read(adr,rd_data);
                            wr_data = rd_data & 0x807F;                 // clear bxn data
                            rpc_inj_bxn=(rpc_inj_image[ibxn][irpc] >> 16) & 0x7;
                            wr_data = wr_data | (rpc_inj_bxn << 8);     // new bxn
                            wr_data = wr_data | (1           << 7);     // set inj_sel=1
                            status  = vme_write(adr,wr_data);

                            adr     = adr_rpc_inj_adr;         // ram write strobes
                            rpc_inj_wen   = (1 << irpc);                // select this ram
                            rpc_inj_ren   = 0;
                            rpc_inj_rwadr = ibxn;                       // at this address
                            wr_data = rpc_inj_wen | (rpc_inj_ren << 4) | (rpc_inj_rwadr << 8) | (rpc_tbins_test << 15);     // set wen=1
                            status  = vme_write(adr,wr_data);
                            rpc_inj_wen=0;
                            wr_data = rpc_inj_wen | (rpc_inj_ren << 4) | (rpc_inj_rwadr << 8) | (rpc_tbins_test << 15);     // set wen=0
                            status  = vme_write(adr,wr_data);
                        }   // close for ibxn
                    }   // close for irpc
                }   // if (rat_injector_enable

                // Verify RPC injector RAM
                if (rat_injector_enable & !rat_injector_sync) {

                    for (irpc=0; irpc<=1; ++irpc) {
                        for (ibxn=0; ibxn<=7; ++ibxn) {
                            adr = adr_rpc_inj_adr;         // ram read strobes
                            rpc_inj_wen   = 0;                      // select this ram
                            rpc_inj_ren   = (1 << irpc);
                            rpc_inj_rwadr = ibxn;                   // at this address
                            wr_data = rpc_inj_wen | (rpc_inj_ren << 4) | (rpc_inj_rwadr << 8) | (rpc_tbins_test << 15);     // set ren=1
                            status  = vme_write(adr,wr_data);

                            adr    = rpc_inj_rdata_adr;    // read pad data
                            status = vme_read(adr,rd_data);
                            rpc_inj_data=rd_data;

                            adr    = rpc_inj_adr;          // read bxn data
                            status = vme_read(adr,rd_data);
                            rpc_inj_bxn = (rd_data >> 11) & 0x7;
                            rpc_inj_data = rpc_inj_data | (rpc_inj_bxn << 16);

                            adr = adr_rpc_inj_adr;         // ram read strobes
                            rpc_inj_ren=0;
                            wr_data = rpc_inj_wen | (rpc_inj_ren << 4) | (rpc_inj_rwadr << 8) | (rpc_tbins_test << 15);     // set ren=0
                            status  = vme_write(adr,wr_data);

                            std::cout << "rpc_inj_data reading " << ibxn << " " << irpc << " " << std::hex << rpc_inj_data << std::endl;

                            if (rpc_inj_data != rpc_inj_image[ibxn][irpc])
                                (*MyOutput_) << "RPC injector RAM error at adr=" << rpc_inj_rwadr << " expect= " << std::hex << rpc_inj_image[ibxn][irpc] << " read=" << std::hex << rpc_inj_data << std::endl;

                        }   // close for ibxn
                    }   // close for irpc
                }   // if (rat_injector_enable

                // Select clct pattern trigger
                adr     = seq_trig_en_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFF00;
                wr_data = wr_data | 0x0001;
                //  if (!layer_mode) wr_data=wr_data |0x0001;   //  TURN OFF PATTERN TRIGGER IN LAYER MODE TEMPORARY!!!
                status  = vme_write(adr,wr_data);

                // Set start_trigger state for FMM
                adr     = ccb_cmd_adr;

                ttc_cmd = 3;            // ttc_resync
                wr_data = 0x0003 | (ttc_cmd << 8);
                status  = vme_write(adr,wr_data);
                wr_data = 0x0001;
                status  = vme_write(adr,wr_data);

                ttc_cmd = 6;            // start_trigger
                wr_data = 0x0003 | (ttc_cmd << 8);
                status  = vme_write(adr,wr_data);
                wr_data = 0x0001;
                status  = vme_write(adr,wr_data);

                ttc_cmd = 1;            // bx0
                wr_data = 0x0003 | (ttc_cmd << 8);
                status  = vme_write(adr,wr_data);
                wr_data =0x0001;
                status  = vme_write(adr,wr_data);

                // Force a sync error if requested
                adr     = sync_err_control_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & ~(1<<15);       // clear old
                wr_data = rd_data |  (sync_err_force<<15);
                status  = vme_write(adr,wr_data);   // set new

                // Clear sync error if bx0 emulator is turned on
                if (vme_bx0_emu_en==1)
                {
                    adr     = sync_err_control_adr;
                    status  = vme_read(adr,rd_data);
                    wr_data = rd_data |  0x1;   // assert clear
                    status  = vme_write(adr,wr_data);
                    wr_data = rd_data & ~0x1;   // deassert
                    status  = vme_write(adr,wr_data);

                    status  = vme_read(adr,rd_data);
                    sync_err             = (rd_data >>  9) & 0x1; 
                    clct_bx0_sync_err    = (rd_data >> 10) & 0x1; 
                    alct_ecc_rx_err_ff   = (rd_data >> 11) & 0x1; 
                    alct_ecc_tx_err_ff   = (rd_data >> 12) & 0x1; 
                    bx0_match_err_ff     = (rd_data >> 13) & 0x1; 
                    sync_err_force       = (rd_data >> 15) & 0x1;

                    if (sync_err==0 && sync_err_force==1) 
                        (*MyOutput_) << "ERR: TMB failed to force sync_err, sync_err=" << sync_err << " sync_err_force=" << sync_err_force << std::endl; 
                    if (sync_err==1 && vme_bx0_emu_en==1) 
                        (*MyOutput_) << "ERR: TMB failed to clear sync_err, sync_err=" << sync_err << " vme_bx0_emu_en=" << vme_bx0_emu_en << std::endl;
                }

                // Loop key and pid modes
                for (iclct=0; iclct<nclcts_inject; ++iclct)
                {
                    if (clct_key_inject[0]==-1) loop_keys[iclct]=true;
                    else                        loop_keys[iclct]=false;

                    if (clct_pid_inject[0]==-1) loop_pids[iclct]=true;
                    else                        loop_pids[iclct]=false;
                }

                // CLCT: Key hs range to span in event loop
                iclct=0;

                if (loop_keys[iclct])               // clct0 hits all keys 0 to 159
                {
                    ikey_min = 0;
                    ikey_max = 159;
                }   
                else                                // hit only 1 key
                {
                    ikey_min = clct_key_inject[iclct];
                    ikey_max = clct_key_inject[iclct];
                }

                // CLCT: Pattern ID range to span in event loop
                if (loop_pids[iclct])               // do all pattern IDs
                {
                    ipid_min = 2;
                    ipid_max = 10;
                }               
                else                                // just do 1 pid
                {
                    ipid_min = clct_pid_inject[iclct];
                    ipid_max = clct_pid_inject[iclct];
                }

                if (loop_pids[iclct]) {             // do all pattern IDs
                    if (hit_thresh_pretrig   > 3) 
                        (*MyOutput_) << "hit_thresh_pretrig   too high to trigger edge keys\n";
                    if (hit_thresh_postdrift > 3) 
                        (*MyOutput_) << "hit_thresh_postdrift too high to trigger edge keys\n";
                }

                // Loop over trigger events: clct0 keys and clct0 pids
                for (ikeylp=ikey_min; ikeylp<=ikey_max; ++ikeylp)
                {
                    for (ipidlp=ipid_min; ipidlp<=ipid_max; ++ipidlp)
                    {

                        // Clear clct 1/2-strip image for this event
                        for (layer=0; layer<=5; ++layer) {
                            for (key=0;   key<=159; ++key  ) {
                                ihs[layer][key]=0;
                            }}

                        // Loop over clcts to inject for this event
                        ipid  = 0;
                        ikey  = 0;
                        icfeb = 0;

                        for (iclct=0; iclct<nclcts_inject; ++iclct)
                        {
                            // Construct current key and pid for this clct
                            ikey = clct_key_inject[iclct];
                            ipid = clct_pid_inject[iclct];
                            clct_blanked[iclct] = false;

                            if (iclct==0 && loop_keys[iclct]) {
                                ipid = ipidlp;
                                ikey = ikeylp;
                            }

                            if (iclct==1) {
                                if (loop_keys[1]) ikey = 159-ikeylp;        // clct1 uses clct0 159-key if clct0 is looping over keys
                                if (loop_pids[1]) ipid = flip_pid(ipidlp);  // clct1 uses clct0 flipped pid if clct0 is looping over pids
                            }

                            clct_key_inject[iclct] = ikey;
                            clct_pid_inject[iclct] = ipid;

                            if (debug_) {
                                std::cout << "dbg: clct_key_inject" << iclct << "=" << clct_key_inject[iclct] << std::endl;
                                std::cout << "dbg: clct_pid_inject" << iclct << "=" << std::hex << clct_pid_inject[iclct] << std::endl;
                            }

                            if (iclct==1 && loop_keys[1]) {
                                ikey_sep = abs(clct_key_inject[0]-clct_key_inject[1]);
                                if (ikey_sep<=1) {
                                    clct_blanked[1]    = true;
                                }
                                if (debug_)
                                    std::cout << "dbg: key=" << ikeylp << " clct1 key separation ikey_sep=" << ikey_sep << " clct_blanked[1]=" << logical(clct_blanked[1]) << std::endl;
                            }
                            if (clct_blanked[iclct]) continue;  // skip this clct if its blanked 

                            // Insert pattern image for this clcts key and pid + stagger hits 
                            ihitp = 0;
                            icfeb = ikey/32;
                            clct_hit_expect[iclct] = 0;
                            clct_key_expect[iclct] = ikey;
                            clct_pid_expect[iclct] = ipid;

                            for (layer=0; layer<=5;  ++layer) {
                                for (icell=0; icell<=10; ++icell) {

                                    key=ikey+icell-5;                               // ikey -5,-4,-3,-2,-1,0,+1,+2,+3,+4,+5 cell hits
                                    if (stagger_hs_csc==1 && (layer%2)!=0  ) key++; // Type A stagger odd layers if key is on ly2
                                    if (stagger_hs_csc==1 && reverse_hs_csc) key--; // Tybe B shift 1hs beco csc is facing backwards

                                    ids     = key/4;                                // Distrip for this key
                                    ihs_min = ids*4;                                // First hs on this ds
                                    ihs_max = ihs_min+3;                            // Last  hs on this ds
                                    ihs_hit = 0;                                    // Number of hs hits on this ds must be 0 or 1, comparators can only encode 1 of 4 hs

                                    for (ihs_ds=ihs_min; ihs_ds<=ihs_max; ++ihs_ds){// Loop over the 4 hs on this ds
                                        if (ihs_ds>=0 && ihs_ds<=159) {                 // Bugfix 12/13/2010
                                            if (ihs[layer][ihs_ds]==1) ihs_hit++;           // Hs that were already set on this ds
                                        }}
                                    ihit  = pattern_image[ipid][layer][icell];      // Extract pattern hits

                                    if (ihit==1   ) ihitp++;                        // Count primary pattern hits
                                    if (ihit==1 && ihs_hit>=1) 
                                        (*MyOutput_) << "ERRx: Hs collision at ikey=" << ikey << " ly=" << layer << " icell=" << icell << std::endl;
                                    if (ihs_hit>=1) ihit = 0;                       // Do not hit same distrip twice, comparators can only encode 1 of 4 hs
                                    if (ihitp>clct_hit_inject[iclct]) ihit = 0;     // Limit clct[n] hs hits to user-set

                                    if (key>=0 && key<=159 && ihit==1) {            // Set hs hit
                                        ihs[layer][key]=1; 
                                        clct_hit_expect[iclct]++;
                                    }

                                }   // close icell
                            }   // close layer

                            (*MyOutput_) << "CLCT" << iclct << ": " << "Key=" << ikey << " " << "Pattern=" << std::hex << ipid << " " << "primary hits=" << ihitp << " " << "expected hits=" << clct_hit_expect[iclct] << std::endl;

                            if (ihitp!=6)
                                pause("clct error in primary hit count, expected 6 hits.");

                            // Close loops for this event
                        }   // close for iclct

                        // Display 1/2-strip image
                        //img_file=log_file;
                        //  img_file=sum_file;

                        (*MyOutput_) << "1/2-Strip Image:\n";
                        for (layer=0; layer<=5; ++layer) {
                            nstag=((layer+1)%2)*stagger_hs_csc;             // stagger even layers
                            (*MyOutput_) << layer << ": ";             // layer number
                            for (i=1; i<=nstag; ++i) 
                                (*MyOutput_) << " ";  // insert 1 or 2 spaces for staggering
                            (*MyOutput_) << "|";
                            for (icfebg=0; icfebg<=4; ++icfebg) {           // cfeb groups horizontally
                                for (i=0; i<=31; ++i) 
                                    (*MyOutput_) << ihs[layer][i+32*icfebg];
                                (*MyOutput_) << "|";}
                                (*MyOutput_) << "\n";
                        }

                        // Clear triad image
                        for (layer=0;    layer    < mxly;    ++layer   ) {
                            for (idistrip=0; idistrip < mxdsabs; ++idistrip) {
                                for (itbin=0;    itbin    < mxtbins;  ++itbin  ) {
                                    itriad[itbin][idistrip][layer]=0;
                                }}}

                        // Convert key 1/2-strips to triads
                        itbin0=0;   // first tbin, default is 0

                        for (layer=0; layer<=5; ++layer) {
                            itbin0=triad_1st_tbin[layer];
                            for (key=0; key<=159; ++key) {

                                idistrip=key/4;
                                ihstrip =key%4;

                                if (ihs[layer][key]==1) {
                                    itriad[itbin0+0][idistrip][layer] = 1;
                                    itriad[itbin0+1][idistrip][layer] = ihstrip/2 & 0x0001;
                                    itriad[itbin0+2][idistrip][layer] = ihstrip   & 0x0001;
                                }   // close if ihs
                            }   // close for key
                        }   // close for layer

                        // Load CLCT injector pattern RAM triads from an image file, format="0  0 |00000000|00000000|00000000|00000000|00000000|"
                        if (load_clct_injector_image)
                        {
                            inquirs("WalkingCLCT","ram_file",ram_file_name);
                            (*MyOutput_) << "\n\tOpening CLCT injector RAM image file " << ram_file_name.c_str();

                            ram_file      = fopen(ram_file_name.c_str(),"r");
                            if (ram_file==NULL) {pause("Unable to open CLCT injector RAM image file"); return;}

                            fgets(line,81,ram_file);                                    // Skip comment lines
                            fgets(line,81,ram_file);
                            fgets(line,81,ram_file);

                            for (itbin=0; itbin<mxtbins; ++itbin)
                            {
                                if  (feof(ram_file)) break;                             // Hit end of file
                                fgets(line,81,ram_file);                                // Get a new line
                                sscanf(line,     "%1i%3i |%8X|%8X|%8X|%8X|%8X|",            &layer,&itbin,&dscfeb[0],&dscfeb[1],&dscfeb[2],&dscfeb[3],&dscfeb[4]);
                                (*MyOutput_) << &layer << &itbin << " |" << layer << "|" << itbin << "|" << HEX8(dscfeb[0]) << "|" << HEX8(dscfeb[1]) << "|" << HEX8(dscfeb[2]) << "|" << HEX8(dscfeb[3]) << "|" << HEX8(dscfeb[4]) << "|\n";

                                if (layer<0 || layer>5       ) stop("layer out of range in clct injector image file");
                                if (itbin<0 || itbin>=mxtbins) stop("itbin out of range in clct injector image file");

                                for (icfeblp =0; icfeblp <=4;   ++icfeblp) {
                                    for (idistrip=0; idistrip<=39; ++idistrip) {
                                        icfeblp = idistrip/8;
                                        ids     = idistrip%8;
                                        ibit    = (dscfeb[icfeblp] >> 4*(7-ids)) & 0x1;
                                        itriad[itbin][idistrip][layer] = ibit;
                                    }}

                            }   // close for itbin
                            fclose(ram_file);
                        }   // close if load

                        // Check for multiple hstrip hits that could not be conveted to triads, cfeb hardware can only fire one hs per ds
                        for (layer=0; layer<=5; ++layer) {
                            for (key=0; key<=159; key=key+4) {          // distrip steps
                                nhits=0;
                                for (i=0; i<=3; ++i) {                      // count hs bits hit
                                    nhits=nhits+ihs[layer][key+i];
                                }
                                if (nhits>1) {
                                    (*MyOutput_) << "Unable to Encode all hs hits" << std::endl;
                                    (*MyOutput_) << "Multi triad hits=" << nhits << " at ly=" << layer << " key=" << key << std::endl;
                                    pause (" "); }
                            }
                        }

                        // Display Triads
                        (*MyOutput_) << "\nbegin triad for key" << ikeylp; 
                        for(i=0;i<nclcts_inject;++i) 
                            (*MyOutput_) << "  clct"<<i<<": key" << clct_key_expect[i] << " hit" <<clct_hit_expect[i] << " pid" << std::hex << clct_pid_expect[i];
                        (*MyOutput_) << "\n";

                        for (layer=0; layer<=5; ++layer) {
                            for (itbin=0; itbin<=2; ++itbin) {
                                for (icfebg  =0; icfebg  <=4; ++icfebg  ) {
                                    for (idistrip=0; idistrip<=7; ++idistrip) {
                                        (*MyOutput_) << itriad[itbin][idistrip+8*icfebg][layer]; 
                                    } //close idistrip
                                    (*MyOutput_) << " ";
                                } //close icfebg
                                (*MyOutput_) << "\n";
                            } //close itbin
                            (*MyOutput_) << "\n";
                        } //close layer

                        // Pack triads into pattern RAM
                        wr_data=0;

                        for (layer=0; layer<=5; layer=layer+2) {
                            iram=layer/2;
                            for (itbin=0; itbin<=31; ++itbin) {
                                for (idistrip=0; idistrip<=39; ++idistrip) {
                                    icfeblp=idistrip/8;
                                    idslocal=idistrip%8;
                                    if (idslocal==0) wr_data=0;         // clear for each cfeb

                                    ibit=itriad[itbin][idistrip][layer];
                                    wr_data=wr_data | (ibit << idslocal);

                                    ibit=itriad[itbin][idistrip][layer+1];
                                    wr_data=wr_data | (ibit << (idslocal+8));

                                    pat_ram[itbin][iram][icfeblp]=wr_data;
                                    if (debug_)
                                        std::cout << "pat_ram tbin=" << itbin << " ram=" << iram << " wr_data=" << std::hex << wr_data << std::endl;
                                }
                            }
                        }

                        // Write muon data to Injector
                        adr     = l1a_lookback_adr;
                        status  = vme_read(adr,rd_data);                // Read lookback register
                        l1a_lookback_data = rd_data & ~(0x3 << 11);     // Clear out injector RAM data [17:16] in [12:11]

                        for (icfeblp=0; icfeblp<=4;  ++icfeblp) {
                            for (iram   =0; iram   <=2;  ++iram   ) {
                                for (itbin  =0; itbin  <=31; ++itbin  ) {

                                    wr_data_mem = pat_ram[itbin][iram][icfeblp];    // RAM data to write at this cfeb and tbin
                                    wr_data_lsb = (wr_data_mem >>  0) & 0x0FFFF;    // RAM write data [15:0]
                                    wr_data_msb = (wr_data_mem >> 16) & 0x3;        // RAM write data [17:16];
                                    wadr        = itbin;

                                    adr    = cfeb_inj_adr;                 // Select injector RAM
                                    status = vme_read(adr,rd_data);                 // Get current data

                                    wr_data = rd_data & 0xFC1F;                     // Zero   CFEB select
                                    febsel  = (1 << icfeblp);                       // Select CFEB
                                    wr_data = wr_data | (febsel << 5) | 0x7C00;     // Set febsel, enable injectors
                                    status  = vme_write(adr,wr_data);               // Select CFEB

                                    adr     = cfeb_inj_adr_adr;
                                    ren     = 0;
                                    wen     = 0;
                                    wr_data = wen | (ren << 3) | (wadr << 6);
                                    status  = vme_write(adr,wr_data);               // Set RAM Address + No write

                                    adr     = cfeb_inj_wdata_adr;
                                    wr_data = wr_data_lsb;
                                    status  = vme_write(adr,wr_data);               // Store RAM Data lsb [15:0]

                                    adr     = l1a_lookback_adr;
                                    wr_data = l1a_lookback_data | (wr_data_msb << 11);
                                    status  = vme_write(adr,wr_data);               // Store RAM Data msb [17:16]

                                    adr     = cfeb_inj_adr_adr;
                                    wen     = (1 << iram);
                                    wr_data = wen | (ren << 3) | (wadr << 6);
                                    status  = vme_write(adr,wr_data);               // Set RAM Address + Assert write

                                    wen     = 0;
                                    wr_data = wen | (ren << 3) | (wadr << 6);
                                    status  = vme_write(adr,wr_data);               // Set RAM Address + No write

                                    ren     = (1 << iram);
                                    wr_data = wen | (ren << 3) | (wadr << 6);
                                    status  = vme_write(adr,wr_data);               // Set RAM Address + Read enable

                                    adr     = cfeb_inj_rdata_adr;
                                    status  = vme_read(adr,rd_data);                // Read RAM data lsbs [15:0]
                                    rd_data_lsb = rd_data;

                                    adr     = l1a_lookback_adr;
                                    status  = vme_read(adr,rd_data);                // Read RAM data msbs [17:16]
                                    rd_data_msb = (rd_data >> 13) & 0x3;
                                    rd_data_mem = rd_data_lsb | (rd_data_msb << 16); 

                                    if (cprr && !cprr_ignore && (rd_data_mem != wr_data_mem)){
                                        (*MyOutput_) << "\tInjector Verify Err: "
                                            << " cfeb " << icfeblp
                                            << " key" << ikey
                                            << " RAM" << iram
                                            << " Tbin" << itbin
                                            << " wr=" << std::hex << wr_data_mem
                                            << " rd=" << std::hex << rd_data_mem << std::endl;

                                        //printf("\tSkip, Continue <cr> ");
                                        //fgets(line, 80, stdin);
                                        //n=strlen(line);
                                        //sscanf(line,"%d",&i);
                                        //if (n==1 && (i=='S' || i=='s')) cprr_ignore=true;
                                    }

                                }   // close itbin
                            }   // close iram
                        }   // close icfebl

                        // Set ALCT first muon to inject:
                        if (nalcts_inject >= 1) {
                            alct0_vpf_inj   = 1;            //  Valid pattern flag
                            alct0_qual_inj  = 3;            //  Pattern quality
                            alct0_amu_inj   = 0;            //  Accelerator muon
                            alct0_key_inj   = (ikey+5)%128; //  Wire group ID number (just some offset wrt clct key for now)
                            alct0_bxn_inj   = 1;            //  Bunch crossing number
                        }
                        else {                          //  No 1st alct muon
                            alct0_vpf_inj   = 0;            //  Valid pattern flag
                            alct0_qual_inj  = 0;            //  Pattern quality
                            alct0_amu_inj   = 0;            //  Accelerator muon
                            alct0_key_inj   = 0;            //  Wire group ID number (just some offset wrt clct key for now)
                            alct0_bxn_inj   = 0;            //  Bunch crossing number
                        }

                        alct0_inj_wr    = (alct0_vpf_inj  <<  0);
                        alct0_inj_wr    = (alct0_qual_inj <<  1) | alct0_inj_wr;
                        alct0_inj_wr    = (alct0_amu_inj  <<  3) | alct0_inj_wr;
                        alct0_inj_wr    = (alct0_key_inj  <<  4) | alct0_inj_wr;
                        alct0_inj_wr    = (alct0_bxn_inj  << 11) | alct0_inj_wr;

                        wr_data = alct0_inj_wr;
                        adr     = alct0_inj_adr;
                        status  = vme_write(adr,wr_data);

                        (*MyOutput_) << "alct0_inj_wr=" << std::hex << alct0_inj_wr << std::endl;

                        // Set ALCT second muon to inject:
                        if (nalcts_inject == 2) {
                            alct1_vpf_inj   = 1;            //  Valid pattern flag
                            alct1_qual_inj  = 2;            //  Pattern quality
                            alct1_amu_inj   = 0;            //  Accelerator muon
                            alct1_key_inj   = (ikey+9)%128; //  Wire group ID number (just some offset wrt clct key for now)
                            alct1_bxn_inj   = 3;            //  Bunch crossing number
                        }
                        else {                      //  No 2nd alct muon
                            alct1_vpf_inj   = 0;            //  Valid pattern flag
                            alct1_qual_inj  = 0;            //  Pattern quality
                            alct1_amu_inj   = 0;            //  Accelerator muon
                            alct1_key_inj   = 0;            //  Wire group ID number
                            alct1_bxn_inj   = 0;            //  Bunch crossing number
                        }

                        alct1_inj_wr    = (alct1_vpf_inj  <<  0);
                        alct1_inj_wr    = (alct1_qual_inj <<  1) | alct1_inj_wr;
                        alct1_inj_wr    = (alct1_amu_inj  <<  3) | alct1_inj_wr;
                        alct1_inj_wr    = (alct1_key_inj  <<  4) | alct1_inj_wr;
                        alct1_inj_wr    = (alct1_bxn_inj  << 11) | alct1_inj_wr;

                        wr_data = alct1_inj_wr; 
                        adr     = alct1_inj_adr;
                        status  = vme_write(adr,wr_data);

                        (*MyOutput_) << "alct1_inj_wr=" << std::hex << alct1_inj_wr << std::endl;

                        // Lower pattern threshold temporarily so edge key 1/2-strips will trigger, set it back later
                        if (loop_keys[0] && (ikey<=4 || ikey>=154))
                        {
                            hit_thresh_pretrig_temp   = clct_hit_expect[0];
                            hit_thresh_postdrift_temp = clct_hit_expect[0];

                            if (nclcts_inject==2) {
                                hit_thresh_pretrig_temp   = std::min(clct_hit_expect[0],clct_hit_expect[1]);
                                hit_thresh_postdrift_temp = std::min(clct_hit_expect[0],clct_hit_expect[1]);}
                        }
                        else
                        {
                            hit_thresh_pretrig_temp   = hit_thresh_pretrig;
                            hit_thresh_postdrift_temp = hit_thresh_postdrift;
                        }

                        adr    = seq_clct_adr;
                        status = vme_read(adr,rd_data);

                        wr_data = rd_data & 0x8000; // clear hit_thresh,nph_pattern,drift
                        wr_data = wr_data | (triad_persist             <<  0);
                        wr_data = wr_data | (hit_thresh_pretrig_temp   <<  4);
                        wr_data = wr_data | (dmb_thresh_pretrig        <<  7);
                        wr_data = wr_data | (hit_thresh_postdrift_temp << 10);
                        wr_data = wr_data | (drift_delay               << 13);
                        status  = vme_write(adr,wr_data);

                        // Clear previous event aff, clct, mpc registers
                        adr     = seqmod_adr;
                        status  = vme_read(adr,rd_data);
                        wr_data = rd_data |  (1<<15);       // clear   = set bit 15
                        status  = vme_write(adr,wr_data);
                        wr_data = rd_data & ~(1<<15);       // unclear = clr bit 15
                        status  = vme_write(adr,wr_data);

                        // Set scope-in-readout
                        adr     = scp_ctrl_adr;
                        status  = vme_read(adr,rd_data);
                        wr_data = rd_data & 0xFF07;  // clear bits 3,4,5,6,7
                        wr_data = wr_data | (scp_auto    << 3);
                        wr_data = wr_data | (scp_nowrite << 4);
                        wr_data = wr_data | (scp_tbins   << 5);
                        status  = vme_write(adr,wr_data);

                        // Arm scope trigger
                        scp_arm        = true;
                        scp_readout    = false;
                        scp_raw_decode = false;
                        scp_silent     = false;
                        scp_playback   = false;
                        if (rdscope)
                            scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

                        // Fire CLCT+ALCT Injectors
                        adr     = cfeb_inj_adr;
                        status  = vme_read(adr,rd_data);
                        wr_data = rd_data | 0x8000;     // fire injector
                        status  = vme_write(adr,wr_data);
                        wr_data = rd_data & 0x7FFF;     // unfire
                        status  = vme_write(adr,wr_data);

                        // Wait for injector to complete
                        for (i=0; i<=10; ++i) {
                            adr      = cfeb_inj_adr;
                            status   = vme_read(adr,rd_data);
                            inj_busy = (rd_data >> 15) & 0x1;
                            if (inj_busy==0) break;
                            if (i==10) pause("CFEB injector RAM failed to go unbusy after 10 VME reads");
                        }

                        // CLCTemu: Predict expected clct pattern-finder results for these 1/2-strip hits
                        engage_pattern_finder=true;
                        //inquire("Global", "csc_type", minv= 0, maxv=  16, radix=10, csc_type);
                        csc_type=0xA;
                        (*MyOutput_) << "\ncsc_type=" << csc_type << std::endl; 

                        if (engage_pattern_finder)
                        {
                            pattern_finder
                                (
                                 ihs,               // inputs
                                 csc_type, 
                                 clct_sep, 
                                 adjcfeb_dist,
                                 layer_trig_en,
                                 cfeb_en,

                                 hit_thresh_pretrig,
                                 pid_thresh_pretrig,
                                 dmb_thresh_pretrig,
                                 lyr_thresh_pretrig,

                                 cfeb_active_emu,   // outputs
                                 nlayers_hit_emu,
                                 layer_trig_emu,

                                 hs_key_1st_emu,    
                                 hs_pid_1st_emu,
                                 hs_hit_1st_emu,

                                 hs_key_2nd_emu,
                                 hs_pid_2nd_emu,
                                 hs_hit_2nd_emu
                                     );
                        }
                        else
                        {
                            hs_key_1st_emu = 0;
                            hs_pid_1st_emu = 0;
                            hs_hit_1st_emu = 0;

                            hs_key_2nd_emu = 0;
                            hs_pid_2nd_emu = 0;
                            hs_hit_2nd_emu = 0;

                            nlayers_hit_emu = 0;
                            layer_trig_emu = 0;

                            cfeb_active_emu[0]=0;
                            cfeb_active_emu[1]=0;
                            cfeb_active_emu[2]=0;
                            cfeb_active_emu[3]=0;
                            cfeb_active_emu[4]=0;
                        }

                        (*MyOutput_) << "\n";
                        (*MyOutput_) << "CLCTemu hs_key_1st_emu=" << hs_key_1st_emu << " hs_pid_1st_emu=" << std::hex << hs_pid_1st_emu << " hs_hit_1st_emu=" << std::hex << hs_hit_1st_emu << std::endl;
                        (*MyOutput_) << "CLCTemu hs_key_2nd_emu=" << hs_key_2nd_emu << " hs_pid_2nd_emu=" << std::hex << hs_pid_2nd_emu << " hs_hit_2nd_emu=" << std::hex << hs_hit_2nd_emu << std::endl;
                        (*MyOutput_) << "CLCTemu layer_trig_emu=" << layer_trig_emu << " nlayers_hit_emu=" << nlayers_hit_emu << std::endl;
                        (*MyOutput_) << "CLCTemu cfeb_active_emu[4:0]=";
                        for(i=4;i>=0;--i)
                            (*MyOutput_) << cfeb_active_emu[i]; 
                        (*MyOutput_) << "\n";

                        // CLCTemu: Latch pattern finder emulator results
                        emulator_pretrig     = (hs_hit_1st_emu>=hit_thresh_pretrig_temp   && hs_pid_1st_emu>=pid_thresh_pretrig  );
                        emulator_latch_clct0 = (hs_hit_1st_emu>=hit_thresh_postdrift_temp && hs_pid_1st_emu>=pid_thresh_postdrift) && emulator_pretrig;
                        emulator_latch_clct1 = (hs_hit_2nd_emu>=hit_thresh_postdrift_temp && hs_pid_2nd_emu>=pid_thresh_postdrift) && emulator_latch_clct0;

                        if (emulator_latch_clct0) {
                            clct0_vpf_emu   = 1;                        //  Valid pattern flag
                            clct0_hit_emu   = hs_hit_1st_emu;           //  Hits on pattern
                            clct0_pid_emu   = hs_pid_1st_emu;           //  Pattern number
                            clct0_key_emu   = hs_key_1st_emu;           //  1/2-strip ID number
                            clct0_cfeb_emu  = hs_key_1st_emu>>5;        //  CFEB ID
                            clctc_sync_emu  = ~vme_bx0_emu_en & 0x1;}   //  Sync error
                        else {
                            clct0_vpf_emu   = 0;
                            clct0_hit_emu   = 0;
                            clct0_pid_emu   = 0;
                            clct0_key_emu   = 0;
                            clct0_cfeb_emu  = 0;
                            clctc_sync_emu  = 0;}

                            if (emulator_latch_clct1) {
                                clct1_vpf_emu   = 1;                        //  Valid pattern flag
                                clct1_hit_emu   = hs_hit_2nd_emu;           //  Hits on pattern
                                clct1_pid_emu   = hs_pid_2nd_emu;           //  Pattern number
                                clct1_key_emu   = hs_key_2nd_emu;           //  1/2-strip ID number
                                clct1_cfeb_emu  = hs_key_2nd_emu>>5;}       //  CFEB ID
                            else {
                                clct1_vpf_emu   = 0;
                                clct1_hit_emu   = 0;
                                clct1_pid_emu   = 0;
                                clct1_key_emu   = 0;
                                clct1_cfeb_emu  = 0;}

                                // CLCTvme: Get VME latched CLCT words
                                adr    = seq_clct0_adr;
                                status = vme_read(adr,rd_data);
                                clct0_vme = rd_data;

                                adr    = seq_clct1_adr;
                                status = vme_read(adr,rd_data);
                                clct1_vme = rd_data;

                                adr    = seq_clctm_adr;
                                status = vme_read(adr,rd_data);
                                clctc_vme = (rd_data >> 0) & 0x0007;

                                (*MyOutput_) << "clct0_vme=" << std::hex << clct0_vme << std::endl; 
                                (*MyOutput_) << "clct1_vme=" << std::hex << clct1_vme << std::endl; 
                                (*MyOutput_) << "clctm_vme=" << std::hex << rd_data << std::endl; 

                                // CLCTvme: Get VME clct bxn stored at pretrigger
                                adr    = bxn_clct_adr;
                                status = vme_read(adr,rd_data);
                                clct_bxn_expect = rd_data & 0x3;
                                (*MyOutput_) << " CLCT pretrigger bxn=" << std::hex << rd_data << " truncated=" << std::hex << clct_bxn_expect << std::endl;

                                // CLCTvme: Get VME  number of layers hit
                                adr    = layer_trg_mode_adr;
                                status = vme_read(adr,rd_data);
                                nlayers_hit = (rd_data >> 4) & 0x7;

                                (*MyOutput_) << "nlayers_hit=" << nlayers_hit << std::endl;

                                // CLCTvme: Get VME active CFEB list
                                adr    = seq_clctm_adr;
                                status = vme_read(adr,rd_data);
                                active_feb_list = (rd_data >> 3) & 0x1F;

                                // CLCTvme: Decompose VME CLCTs
                                clct0_vpf_vme   = (clct0_vme >>  0) & 0x0001;   //  Valid pattern flag
                                clct0_hit_vme   = (clct0_vme >>  1) & 0x0007;   //  Hits on pattern
                                clct0_pid_vme   = (clct0_vme >>  4) & 0x000F;   //  Pattern number
                                clct0_key_vme   = (clct0_vme >>  8) & 0x00FF;   //  1/2-strip ID number
                                clct0_cfeb_vme  = (clct0_vme >> 13) & 0x0007;   //  CFEB ID

                                clct1_vpf_vme   = (clct1_vme >>  0) & 0x0001;   //  Valid pattern flag
                                clct1_hit_vme   = (clct1_vme >>  1) & 0x0007;   //  Hits on pattern
                                clct1_pid_vme   = (clct1_vme >>  4) & 0x000F;   //  Pattern number
                                clct1_key_vme   = (clct1_vme >>  8) & 0x00FF;   //  1/2-strip ID number
                                clct1_cfeb_vme  = (clct1_vme >> 13) & 0x0007;   //  CFEB ID

                                clctc_bxn_vme   = (clctc_vme >>  0) & 0x0003;   //  Bunch crossing number
                                clctc_sync_vme  = (clctc_vme >>  2) & 0x0001;   //  Sync error

                                // CLCTemu+vme: Compare VME CLCTs to emulator CLCTs
                                ck("clct0_vpf  read vme.expect emulator", clct0_vpf_vme,    clct0_vpf_emu );
                                ck("clct0_hit  read vme.expect emulator", clct0_hit_vme,    clct0_hit_emu );
                                ck("clct0_pid  read vme.expect emulator", clct0_pid_vme,    clct0_pid_emu );
                                ck("clct0_key  read vme.expect emulator", clct0_key_vme,    clct0_key_emu );
                                ck("clct0_cfeb read vme.expect emulator", clct0_cfeb_vme,   clct0_cfeb_emu);

                                ck("clct1_vpf  read vme.expect emulator", clct1_vpf_vme,    clct1_vpf_emu );
                                ck("clct1_hit  read vme.expect emulator", clct1_hit_vme,    clct1_hit_emu );
                                ck("clct1_pid  read vme.expect emulator", clct1_pid_vme,    clct1_pid_emu );
                                ck("clct1_key  read vme.expect emulator", clct1_key_vme,    clct1_key_emu );
                                ck("clct1_cfeb read vme.expect emulator", clct1_cfeb_vme,   clct1_cfeb_emu);

                                ck("clctc_sync read vme.expect emulator", clctc_sync_vme,   clctc_sync_emu);

                                // CLCTinj: Predict number of hits on injected CLCTs due to staggering losses at CSC edges
                                for (i=0; i<nclcts_inject; ++i)
                                {
                                    clct_hit_inject_clip[i]=clct_hit_inject[i];         // no edge clipping

                                    if ((csc_type==0xA && clct_key_inject[i]==159) ||   // Normal   CSC
                                            (csc_type==0xB && clct_key_inject[i]==0  ))     // Reversed CSC
                                    {
                                        if (clct_hit_inject[i]==6) clct_hit_inject_clip[i]=clct_hit_inject[i]-3;    // hit ly0,1,2,3,4,5 clipped ly1,3,5    
                                        if (clct_hit_inject[i]==5) clct_hit_inject_clip[i]=clct_hit_inject[i]-2;    // hit ly0,1,2,3,4   clipped ly1,3  
                                        if (clct_hit_inject[i]==4) clct_hit_inject_clip[i]=clct_hit_inject[i]-2;    // hit ly0,1,2,3     clipped ly1,3  
                                        if (clct_hit_inject[i]==3) clct_hit_inject_clip[i]=clct_hit_inject[i]-1;    // hit ly0,1,2       clipped ly1    
                                        if (clct_hit_inject[i]==2) clct_hit_inject_clip[i]=clct_hit_inject[i]-1;    // hit ly0,1         clipped ly1    
                                        if (clct_hit_inject[i]==1) clct_hit_inject_clip[i]=clct_hit_inject[i]-0;    // hit ly0           clipped none   

                                        (*MyOutput_) 
                                            << "clct_hit_inject[" << i
                                            << "] clipped from " << clct_hit_inject[i]
                                            << " hits to " << clct_hit_inject_clip[i]
                                            << "hits at csc edge due to staggering\n";

                                    }
                                    (*MyOutput_) 
                                        << "clct_hit_inject[" << i << "]=" << clct_hit_inject[i] << " "
                                        << "clct_hit_inject_clip[" << i << "]=" << clct_hit_inject_clip[i] << std::endl;

                                }   // close for i

                                // CLCTinj: Find expected clct0 from the injector
                                clct_hit_inj_expect[0] = 0;
                                clct_key_inj_expect[0] = 0;
                                clct_pid_inj_expect[0] = 0;
                                clct_pat_inj_expect[0] = 0;

                                for (i=0; i<nclcts_inject; ++i) {
                                    clct_pat_inject[i] = (clct_hit_inject_clip[i]<<4) | clct_pid_inject[i];

                                    if ((clct_pat_inject[i] >  clct_pat_inj_expect[0]) ||       // found a better pattern
                                            ((clct_pat_inject[i] == clct_pat_inj_expect[0]) &&      // found an equal pattern 
                                             (clct_key_inject[i] <  clct_key_inj_expect[0])))       // take the equal pattern at the lower key hs
                                    {
                                        clct_hit_inj_expect[0] = clct_hit_inject_clip[i];
                                        clct_key_inj_expect[0] = clct_key_inject[i];
                                        clct_pid_inj_expect[0] = clct_pid_inject[i];
                                        clct_pat_inj_expect[0] = clct_pat_inject[i];
                                    }
                                }

                                (*MyOutput_) << "clct_hit_inj_expect[0]=" << clct_hit_inj_expect[0] << std::endl;
                                (*MyOutput_) << "clct_key_inj_expect[0]=" << clct_key_inj_expect[0] << std::endl;
                                (*MyOutput_) << "clct_pid_inj_expect[0]=" << std::hex << clct_pid_inj_expect[0] << std::endl;
                                (*MyOutput_) << "clct_pat_inj_expect[0]=" << std::hex << clct_pat_inj_expect[0] << std::endl;

                                // CLCTinj: Create key 1/2-strip blanking region around clct0 from injector
                                nspan = clct_sep;
                                pspan = clct_sep;

                                key_inj = clct_key_inj_expect[0];
                                clct0_is_on_me1a = (key_inj>=128);

                                int	busy_min;
                                int	busy_max;

                                if (csc_type==0xA || csc_type==0xB)     // CSC Type A or B limit busy list to range 0-159
                                {
                                    busy_max = (key_inj <= 159-pspan) ? key_inj+pspan : 159;    // Limit busy list to range 0-159
                                    busy_min = (key_inj >= nspan    ) ? key_inj-nspan : 0;
                                }

                                else if (csc_type==0xC || csc_type==0xD)                    // CSC Type C or D delimiters for excluding 2nd clct span ME1B hs0-127  ME1A hs128-159
                                {
                                    if (clct0_is_on_me1a) {     // CLCT0 is on ME1A cfeb4, limit blanking region to 128-159
                                        busy_max = (key_inj <= 159-pspan) ? key_inj+pspan : 159;
                                        busy_min = (key_inj >= 128+nspan) ? key_inj-nspan : 128;
                                    }
                                    else {                      // CLCT0 is on ME1B cfeb0-cfeb3, limit blanking region to 0-127
                                        busy_max = (key_inj <= 127-pspan) ? key_inj+pspan : 127;
                                        busy_min = (key_inj >=     nspan) ? key_inj-nspan : 0;
                                    }
                                }

                                for (i=0; i<160; ++i) {
                                    busy_key_inj[i] = (i>=busy_min && i<=busy_max);
                                }

                                (*MyOutput_) << "busy_key_inj="; 
                                for (i=0; i<160; ++i) 
                                    (*MyOutput_) << busy_key_inj[i]; 
                                (*MyOutput_) << "\n";

                                // CLCTinj: Find expected clct1 from the injector
                                clct_hit_inj_expect[1] = 0;
                                clct_key_inj_expect[1] = 0;
                                clct_pid_inj_expect[1] = 0;
                                clct_pat_inj_expect[1] = 0;

                                for (i=0; i<nclcts_inject; ++i) {
                                    if (nclcts_inject<=1) break;
                                    if (clct_blanked[i] ) continue;

                                    if ((clct_pat_inject[i] >  clct_pat_inj_expect[1]) ||       // found a better pattern
                                            ((clct_pat_inject[i] == clct_pat_inj_expect[1]) &&      // found an equal pattern 
                                             (clct_key_inject[i] <  clct_key_inj_expect[1])))       // take the equal pattern at the lower key hs
                                    {
                                        key_inj = clct_key_inject[i];
                                        if (debug_) {
                                            std::cout << "dbg: key_inj=" << key_inj << std::endl;
                                            std::cout << "dbg: busy_key[key_inj]=" << busy_key_inj[key_inj] << std::endl; 
                                        }

                                        if (busy_key_inj[key_inj]==0)                           // accept only non-busy keys far enough away from clct0
                                        {
                                            clct_hit_inj_expect[1] = clct_hit_inject_clip[i];
                                            clct_key_inj_expect[1] = clct_key_inject[i];
                                            clct_pid_inj_expect[1] = clct_pid_inject[i];
                                            clct_pat_inj_expect[1] = clct_pat_inject[i];
                                        }
                                    }
                                }

                                (*MyOutput_) << "clct_hit_inj_expect[1]=" << clct_hit_inj_expect[1] << std::endl;
                                (*MyOutput_) << "clct_key_inj_expect[1]=" << clct_key_inj_expect[1] << std::endl;
                                (*MyOutput_) << "clct_pid_inj_expect[1]=" << std::hex << clct_pid_inj_expect[1] << std::endl;
                                (*MyOutput_) << "clct_pat_inj_expect[1]=" << std::hex << clct_pat_inj_expect[1] << std::endl;

                                // CLCTinj: Predict pre-trigger and post-drift behavior for injected CLCTs
                                injector_clct0_over  = false;   // clct0 over thresholds
                                injector_clct1_over  = false;   // clct1 over thresholds
                                injector_pretrig     = false;   // tmb should pretrigger
                                injector_latch_clct0 = false;   // tmb should latch clct0
                                injector_latch_clct1 = false;   // tmb should latch clct1

                                if (nclcts_inject>=1)
                                {
                                    injector_clct0_over  = (clct_hit_inj_expect[0]>=hit_thresh_pretrig_temp   && clct_pid_inj_expect[0]>=pid_thresh_pretrig);
                                    injector_clct1_over  = (clct_hit_inj_expect[1]>=hit_thresh_pretrig_temp   && clct_pid_inj_expect[1]>=pid_thresh_pretrig);
                                    injector_pretrig     = injector_clct0_over;
                                    injector_latch_clct0 = injector_pretrig && injector_clct0_over;
                                    injector_latch_clct1 = injector_pretrig && injector_clct1_over;
                                }

                                (*MyOutput_) << "injector_clct0_over =" << logical(injector_clct0_over) << std::endl;
                                (*MyOutput_) << "injector_clct1_over =" << logical(injector_clct1_over) << std::endl;
                                (*MyOutput_) << "injector_pretrig    =" << logical(injector_pretrig) << std::endl;
                                (*MyOutput_) << "injector_latch_clct0=" << logical(injector_latch_clct0) << std::endl;
                                (*MyOutput_) << "injector_latch_clct1=" << logical(injector_latch_clct1) << std::endl;

                                // CLCTinj: Latch pattern finder emulator results
                                clct0_vpf_vme_expect = 0;
                                clct0_hit_vme_expect = 0;
                                clct0_pid_vme_expect = 0;
                                clct0_key_vme_expect = 0;
                                clct0_cfeb_vme_expect= 0;
                                clctc_sync_vme_expect= 0;

                                clct1_vpf_vme_expect = 0;
                                clct1_hit_vme_expect = 0;
                                clct1_pid_vme_expect = 0;
                                clct1_key_vme_expect = 0;
                                clct1_cfeb_vme_expect= 0;

                                if (injector_latch_clct0) {
                                    clct0_vpf_vme_expect = 1;
                                    clct0_hit_vme_expect = clct_hit_inj_expect[0];
                                    clct0_pid_vme_expect = clct_pid_inj_expect[0];
                                    clct0_key_vme_expect = clct_key_inj_expect[0];
                                    clct0_cfeb_vme_expect= clct_key_inj_expect[0]/32;
                                    clctc_sync_vme_expect= ~vme_bx0_emu_en & 0x1;
                                }

                                if (injector_latch_clct1) {
                                    clct1_vpf_vme_expect = 1;
                                    clct1_hit_vme_expect = clct_hit_inj_expect[1];
                                    clct1_pid_vme_expect = clct_pid_inj_expect[1];
                                    clct1_key_vme_expect = clct_key_inj_expect[1];
                                    clct1_cfeb_vme_expect= clct_key_inj_expect[1]/32;
                                }

                                // CLCTinj: Construct expected VME CLCTs from injected CLCTs
                                key0 = clct0_key_vme_expect;
                                key1 = clct1_key_vme_expect;

                                if (injector_latch_clct0) {
                                    if (key0 <= 127 && reverse_hs_me1b == 1) {clct0_key_vme_expect  = 127- key0;        clct0_pid_vme_expect=flip_pid(clct0_pid_vme_expect);}
                                    if (key0 >= 128 && reverse_hs_me1a == 1) {clct0_key_vme_expect  = 159-(key0-128);   clct0_pid_vme_expect=flip_pid(clct0_pid_vme_expect);}
                                    if (reverse_hs_csc==1)                   {clct0_key_vme_expect  = 159- key0;        clct0_pid_vme_expect=flip_pid(clct0_pid_vme_expect);}
                                    clct0_cfeb_vme_expect = clct0_key_vme_expect/32;
                                }

                                if (injector_latch_clct1) {
                                    if (key1 <= 127 && reverse_hs_me1b == 1) {clct1_key_vme_expect  = 127- key1;        clct1_pid_vme_expect=flip_pid(clct1_pid_vme_expect);}
                                    if (key1 >= 128 && reverse_hs_me1a == 1) {clct1_key_vme_expect  = 159-(key1-128);   clct1_pid_vme_expect=flip_pid(clct1_pid_vme_expect);}
                                    if (reverse_hs_csc==1)                   {clct1_key_vme_expect  = 159- key1;        clct1_pid_vme_expect=flip_pid(clct1_pid_vme_expect);}
                                    clct1_cfeb_vme_expect = clct1_key_vme_expect/32;
                                }

                                // CLCTinj: Layer mode expects pattern 1 in 1st clct and no 2nd clct
                                if (layer_mode)
                                {
                                    clct0_vpf_vme_expect = 1;
                                    clct0_hit_vme_expect = clct0_hit_vme_expect;
                                    clct0_pid_vme_expect = 1;
                                    clct0_key_vme_expect = 0;
                                    clct0_cfeb_vme_expect= clct0_key_vme_expect/32;

                                    clct1_vpf_vme_expect = 0;
                                    clct1_hit_vme_expect = 0;
                                    clct1_pid_vme_expect = 0;
                                    clct1_key_vme_expect = 0;
                                    clct1_cfeb_vme_expect= 0;
                                }

                                // CLCTinj+vme: Compare VME CLCTs to expected VME CLCTs from injector
                                ck("clct0_vpf  read vme.expect injected", clct0_vpf_vme,    clct0_vpf_vme_expect );
                                ck("clct0_hit  read vme.expect injected", clct0_hit_vme,    clct0_hit_vme_expect );
                                ck("clct0_pid  read vme.expect injected", clct0_pid_vme,    clct0_pid_vme_expect );
                                ck("clct0_key  read vme.expect injected", clct0_key_vme,    clct0_key_vme_expect );
                                ck("clct0_cfeb read vme.expect injected", clct0_cfeb_vme,   clct0_cfeb_vme_expect);
                                ck("clctc_bxn  read vme.expect injected", clctc_bxn_vme,    clct_bxn_expect      );

                                ck("clct1_vpf  read vme.expect injected", clct1_vpf_vme,    clct1_vpf_vme_expect );
                                ck("clct1_hit  read vme.expect injected", clct1_hit_vme,    clct1_hit_vme_expect );
                                ck("clct1_pid  read vme.expect injected", clct1_pid_vme,    clct1_pid_vme_expect );
                                ck("clct1_key  read vme.expect injected", clct1_key_vme,    clct1_key_vme_expect );
                                ck("clct1_cfeb read vme.expect injected", clct1_cfeb_vme,   clct1_cfeb_vme_expect);

                                ck("clctc_sync read vme.expect injected", clctc_sync_vme,   clctc_sync_vme_expect);

                                // TMBemu: Take either the CLCT injector or emulator result for the TMB stage
                                if (send_emulator_to_tmb) {
                                    (*MyOutput_) << "CLCT: Sending emulator CLCTs to TMB checking\n";
                                    clct0_vpf_tmb  = clct0_vpf_emu;
                                    clct0_hit_tmb  = clct0_hit_emu;
                                    clct0_pid_tmb  = clct0_pid_emu;
                                    clct0_key_tmb  = clct0_key_emu;
                                    clct0_cfeb_tmb = clct0_cfeb_emu;

                                    clct1_vpf_tmb  = clct1_vpf_emu;
                                    clct1_hit_tmb  = clct1_hit_emu;
                                    clct1_pid_tmb  = clct1_pid_emu;
                                    clct1_key_tmb  = clct1_key_emu;
                                    clct1_cfeb_tmb = clct1_cfeb_emu;

                                    clctc_bxn_tmb      = clctc_bxn_vme;
                                    clctc_sync_err_tmb = ~vme_bx0_emu_en & 0x1;
                                }
                                else {
                                    (*MyOutput_) << "CLCT: Sending injector CLCTs to TMB checking\n";
                                    clct0_vpf_tmb  = clct0_vpf_vme_expect;
                                    clct0_hit_tmb  = clct0_hit_vme_expect;
                                    clct0_pid_tmb  = clct0_pid_vme_expect;
                                    clct0_key_tmb  = clct0_key_vme_expect;
                                    clct0_cfeb_tmb = clct0_cfeb_vme_expect;

                                    clct1_vpf_tmb  = clct1_vpf_vme_expect;
                                    clct1_hit_tmb  = clct1_hit_vme_expect;
                                    clct1_pid_tmb  = clct1_pid_vme_expect;
                                    clct1_key_tmb  = clct1_key_vme_expect;
                                    clct1_cfeb_tmb = clct1_cfeb_vme_expect;

                                    clctc_bxn_tmb      = clct_bxn_expect;
                                    clctc_sync_err_tmb = ~vme_bx0_emu_en & 0x1;
                                }

                                // TMBemu: Pseudo pipes for emulator
                                clct0_pipe = (clct0_vpf_tmb << 0) |
                                    (clct0_hit_tmb << 1) |
                                    (clct0_pid_tmb << 4) |
                                    (clct0_key_tmb << 8);

                                clct1_pipe = (clct1_vpf_tmb << 0) |
                                    (clct1_hit_tmb << 1) |
                                    (clct1_pid_tmb << 4) |
                                    (clct1_key_tmb << 8);

                                clctc_pipe = (clctc_bxn_tmb      << 0) |
                                    (clctc_sync_err_tmb << 2);

                                alct0_pipe = alct0_inj_wr;
                                alct1_pipe = alct1_inj_wr;

                                // TMBemu: Predict expected clct and alct duplication
                                expect_zero_alct = 0;
                                expect_zero_clct = 0;
                                expect_one_alct  = 0;
                                expect_one_clct  = 0;
                                expect_two_alct  = 0;
                                expect_two_clct  = 0;
                                expect_dupe_alct = 0;
                                expect_dupe_clct = 0;

                                if (clct0_vpf_tmb==0 && clct1_vpf_tmb==0) expect_zero_clct = 1;
                                if (clct0_vpf_tmb==1 && clct1_vpf_tmb==0) expect_one_clct  = 1;
                                if (clct0_vpf_tmb==1 && clct1_vpf_tmb==1) expect_two_clct  = 1;
                                if (clct0_vpf_tmb==0 && clct1_vpf_tmb==1) 
                                    pause("clct ranking error, wtf!?");

                                if (nalcts_inject==0) expect_zero_alct = 1;
                                if (nalcts_inject==1) expect_one_alct  = 1;
                                if (nalcts_inject==2) expect_two_alct  = 1;

                                if (expect_one_clct==1 && nalcts_inject==2) expect_dupe_clct = 1;
                                if (expect_two_clct==1 && nalcts_inject==1) expect_dupe_alct = 1;

                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "Setting expect_zero_alct = " << logical(expect_zero_alct) << std::endl; 
                                (*MyOutput_) << "Setting expect_zero_clct = " << logical(expect_zero_clct) << std::endl; 
                                (*MyOutput_) << "Setting expect_one_alct  = " << logical(expect_one_alct) << std::endl; 
                                (*MyOutput_) << "Setting expect_one_clct  = " << logical(expect_one_clct) << std::endl; 
                                (*MyOutput_) << "Setting expect_two_alct  = " << logical(expect_two_alct) << std::endl; 
                                (*MyOutput_) << "Setting expect_two_clct  = " << logical(expect_two_clct) << std::endl; 
                                (*MyOutput_) << "Setting expect_dupe_alct = " << logical(expect_dupe_alct) << std::endl; 
                                (*MyOutput_) << "Setting expect_dupe_clct = " << logical(expect_dupe_clct) << std::endl; 

                                // TMBemu: Event trigger disposition
                                clct_noalct_lost= false;
                                alct_only_trig  = (expect_zero_clct==1);

                                clct_match      = (!expect_zero_clct && !expect_zero_alct);
                                clct_noalct     = (!expect_zero_clct &&  expect_zero_alct);
                                alct_noclct     = ( expect_zero_clct && !expect_zero_alct);
                                alct_pulse      = (!expect_zero_alct);

                                clct_keep       =((clct_match && tmb_allow_match   ) || (clct_noalct &&  tmb_allow_clct    && !clct_noalct_lost));
                                alct_keep       = (clct_match && tmb_allow_match   ) || (alct_noclct &&  tmb_allow_alct);

                                clct_keep_ro    = (clct_match && tmb_allow_match_ro) || (clct_noalct &&  tmb_allow_clct_ro && !clct_noalct_lost);
                                alct_keep_ro    = (clct_match && tmb_allow_match_ro) || (alct_noclct &&  tmb_allow_alct_ro);

                                clct_discard    = (clct_match && !tmb_allow_match  ) || (clct_noalct && !tmb_allow_clct) || clct_noalct_lost;
                                alct_discard    =  alct_pulse && !alct_keep;

                                trig_pulse      = clct_match || clct_noalct || clct_noalct_lost || alct_only_trig;  // Event pulse

                                trig_keep       = (clct_keep    || alct_keep);                                      // Keep event for trigger and readout
                                non_trig_keep   = (clct_keep_ro || alct_keep_ro);                                   // Keep non-triggering event for readout only

                                alct_only       = (alct_noclct && tmb_allow_alct) && !clct_keep;                    // An alct-only trigger

                                clct_match_tr   = clct_match  && trig_keep;     // ALCT and CLCT matched in time, nontriggering event
                                alct_noclct_tr  = alct_noclct && trig_keep;     // Only ALCT triggered, nontriggering event
                                clct_noalct_tr  = clct_noalct && trig_keep;     // Only CLCT triggered, nontriggering event

                                clct_match_ro   = clct_match  && non_trig_keep; // ALCT and CLCT matched in time, nontriggering event
                                alct_noclct_ro  = alct_noclct && non_trig_keep; // Only ALCT triggered, nontriggering event
                                clct_noalct_ro  = clct_noalct && non_trig_keep; // Only CLCT triggered, nontriggering event

                                alct_only_trig  = (alct_noclct && tmb_allow_alct) || (alct_noclct_ro && tmb_allow_alct_ro);// ALCT-only triggers are allowed

                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "TMBemu: clct_match     = " << logical(clct_match    ) << std::endl;
                                (*MyOutput_) << "TMBemu: clct_noalct    = " << logical(clct_noalct   ) << std::endl;
                                (*MyOutput_) << "TMBemu: alct_noclct    = " << logical(alct_noclct   ) << std::endl;
                                (*MyOutput_) << "TMBemu: alct_pulse     = " << logical(alct_pulse    ) << std::endl;
                                (*MyOutput_) << "TMBemu: clct_keep      = " << logical(clct_keep     ) << std::endl;
                                (*MyOutput_) << "TMBemu: alct_keep      = " << logical(alct_keep     ) << std::endl;
                                (*MyOutput_) << "TMBemu: clct_keep_ro   = " << logical(clct_keep_ro  ) << std::endl;
                                (*MyOutput_) << "TMBemu: alct_keep_ro   = " << logical(alct_keep_ro  ) << std::endl;
                                (*MyOutput_) << "TMBemu: clct_discard   = " << logical(clct_discard  ) << std::endl;
                                (*MyOutput_) << "TMBemu: alct_discard   = " << logical(alct_discard  ) << std::endl;
                                (*MyOutput_) << "TMBemu: trig_pulse     = " << logical(trig_pulse    ) << std::endl;
                                (*MyOutput_) << "TMBemu: trig_keep      = " << logical(trig_keep     ) << std::endl;
                                (*MyOutput_) << "TMBemu: non_trig_keep  = " << logical(non_trig_keep ) << std::endl;
                                (*MyOutput_) << "TMBemu: alct_only      = " << logical(alct_only     ) << std::endl;
                                (*MyOutput_) << "TMBemu: clct_match_tr  = " << logical(clct_match_tr ) << std::endl;
                                (*MyOutput_) << "TMBemu: alct_noclct_tr = " << logical(alct_noclct_tr) << std::endl;
                                (*MyOutput_) << "TMBemu: clct_noalct_tr = " << logical(clct_noalct_tr) << std::endl;
                                (*MyOutput_) << "TMBemu: clct_match_ro  = " << logical(clct_match_ro ) << std::endl;
                                (*MyOutput_) << "TMBemu: alct_noclct_ro = " << logical(alct_noclct_ro) << std::endl;
                                (*MyOutput_) << "TMBemu: clct_noalct_ro = " << logical(clct_noalct_ro) << std::endl;
                                (*MyOutput_) << "TMBemu: alct_only_trig = " << logical(alct_only_trig) << std::endl;

                                // TMBemu: Latch clct match results for TMB and MPC pathways
                                tmb_trig_pulse      = trig_pulse;                           // ALCT or CLCT or both triggered
                                tmb_trig_keep_ff    = trig_keep;                            // ALCT or CLCT or both triggered, and trigger is allowed
                                tmb_non_trig_keep_ff= non_trig_keep;                        // Event did not trigger but is kept for readout

                                tmb_match           = clct_match_tr  && tmb_allow_match;    // ALCT and CLCT matched in time
                                tmb_alct_only       = alct_noclct_tr && tmb_allow_alct;     // Only ALCT triggered
                                tmb_clct_only       = clct_noalct_tr && tmb_allow_clct;     // Only CLCT triggered

                                tmb_match_ro_ff     = clct_match_ro  && tmb_allow_match_ro; // ALCT and CLCT matched in time, nontriggering event
                                tmb_alct_only_ro_ff = alct_noclct_ro && tmb_allow_alct_ro;  // Only ALCT triggered, nontriggering event
                                tmb_clct_only_ro_ff = clct_noalct_ro && tmb_allow_clct_ro;  // Only CLCT triggered, nontriggering event

                                tmb_alct_discard    = alct_discard;                         // ALCT was not used for LCT
                                tmb_clct_discard    = clct_discard;                         // CLCT was not used for LCT

                                tmb_alct0           = alct0_pipe;                           // Copy of ALCT for header
                                tmb_alct1           = alct1_pipe;

                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "TMBemu: tmb_trig_pulse       = " << logical(tmb_trig_pulse      ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_trig_keep_ff     = " << logical(tmb_trig_keep_ff    ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_non_trig_keep_ff = " << logical(tmb_non_trig_keep_ff) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_match            = " << logical(tmb_match           ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_alct_only        = " << logical(tmb_alct_only       ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_clct_only        = " << logical(tmb_clct_only       ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_match_ro_ff      = " << logical(tmb_match_ro_ff     ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_alct_only_ro_ff  = " << logical(tmb_alct_only_ro_ff ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_clct_only_ro_ff  = " << logical(tmb_clct_only_ro_ff ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_alct_discard     = " << logical(tmb_alct_discard    ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_clct_discard     = " << logical(tmb_clct_discard    ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_alct0            = " << std::hex << tmb_alct0 << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_alct1            = " << std::hex << tmb_alct1 << std::endl;

                                // TMBemu: Kill CLCTs from ME1A, TMB firmware handles this incorrectly as of 4/6/2010
                                kill_me1a_clcts = (mpc_me1a_block==1 && csc_me1ab==1);

                                clct0_exists = clct0_vpf_tmb==1;
                                clct1_exists = clct1_vpf_tmb==1;

                                clct0_cfeb4  = clct0_cfeb_tmb==4;               // CLCT0 is on CFEB4 hence ME1A
                                clct1_cfeb4  = clct1_cfeb_tmb==4;               // CLCT1 is on CFEB4 hence ME1A

                                kill_clct0   = clct0_cfeb4 && kill_me1a_clcts;  // Delete CLCT0 from ME1A
                                kill_clct1   = clct1_cfeb4 && kill_me1a_clcts;  // Delete CLCT1 from ME1A

                                kill_trig    = ((kill_clct0 && clct0_exists) && (kill_clct1 && clct1_exists))   // Kill both clcts
                                    ||             ((kill_clct0 && clct0_exists) && !clct1_exists)
                                    ||             ((kill_clct1 && clct1_exists) && !clct0_exists);

                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "TMBemu: clct0_exists         = " << logical(clct0_exists) << std::endl;
                                (*MyOutput_) << "TMBemu: clct1_exists         = " << logical(clct1_exists) << std::endl;
                                (*MyOutput_) << "TMBemu: clct0_cfeb4          = " << logical(clct0_cfeb4 ) << std::endl;
                                (*MyOutput_) << "TMBemu: clct1_cfeb4          = " << logical(clct1_cfeb4 ) << std::endl;
                                (*MyOutput_) << "TMBemu: kill_clct0           = " << logical(kill_clct0  ) << std::endl;
                                (*MyOutput_) << "TMBemu: kill_clct1           = " << logical(kill_clct1  ) << std::endl;
                                (*MyOutput_) << "TMBemu: kill_trig            = " << logical(kill_trig   ) << std::endl;

                                // TMBemu: Had to wait for kill signal to go valid
                                tmb_match_ro     = tmb_match_ro_ff     & kill_trig; // ALCT and CLCT matched in time, nontriggering event
                                tmb_alct_only_ro = tmb_alct_only_ro_ff & kill_trig; // Only ALCT triggered, nontriggering event
                                tmb_clct_only_ro = tmb_clct_only_ro_ff & kill_trig; // Only CLCT triggered, nontriggering event

                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "TMBemu: tmb_match_ro         = " << logical(tmb_match_ro    ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_alct_only_ro     = " << logical(tmb_alct_only_ro) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_clct_only_ro     = " << logical(tmb_clct_only_ro) << std::endl;

                                // TMBemu: Post FF mod trig_keep for me1a
                                tmb_trig_keep     = tmb_trig_keep_ff && (!kill_trig || tmb_alct_only);
                                tmb_non_trig_keep = tmb_non_trig_keep_ff && !tmb_trig_keep;

                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "TMBemu: tmb_trig_keep        = " << logical(tmb_trig_keep    ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_non_trig_keep    = " << logical(tmb_non_trig_keep) << std::endl;

                                // TMBemu: Pipelined CLCTs, aligned in time with trig_pulse
                                keep_clct  = trig_pulse && (trig_keep || non_trig_keep);

                                clct0_real = clct0_pipe * keep_clct;
                                clct1_real = clct1_pipe * keep_clct;
                                clctc_real = clctc_pipe * keep_clct;

                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "TMBemu: keep_clct            = " << logical(keep_clct)  << std::endl;
                                (*MyOutput_) << "TMBemu: clct0_real           = " << logical(clct0_real) << std::endl;
                                (*MyOutput_) << "TMBemu: clct1_real           = " << logical(clct1_real) << std::endl;
                                (*MyOutput_) << "TMBemu: clctc_real           = " << logical(clctc_real) << std::endl;

                                // TMBemu: Latch pipelined ALCTs, aligned in time with CLCTs because CLCTs are delayed 1bx in the SRLs
                                alct0_real = alct0_pipe;
                                alct1_real = alct1_pipe;

                                // TMBemu: Fill in missing ALCT if CLCT has 2 muons, missing CLCT if ALCT has 2 muons
                                alct0_vpf_emu = (alct0_real >> 0) & 0x1;            // Extract valid pattern flags
                                alct1_vpf_emu = (alct1_real >> 0) & 0x1;
                                clct0_vpf_emu = (clct0_real >> 0) & 0x1;
                                clct1_vpf_emu = (clct1_real >> 0) & 0x1;

                                clct_bxn_insert_emu = clctc_real & 0x3;     // CLCT bunch crossing number for events missing alct

                                tmb_no_alct_emu  = !alct0_vpf_emu;
                                tmb_no_clct_emu  = !clct0_vpf_emu;

                                tmb_one_alct_emu = alct0_vpf_emu && !alct1_vpf_emu;
                                tmb_one_clct_emu = clct0_vpf_emu && !clct1_vpf_emu;

                                tmb_two_alct_emu = alct0_vpf_emu && alct1_vpf_emu;
                                tmb_two_clct_emu = clct0_vpf_emu && clct1_vpf_emu;

                                tmb_dupe_alct_emu = tmb_one_alct_emu && tmb_two_clct_emu;   // Duplicate alct if there are 2 clcts
                                tmb_dupe_clct_emu = tmb_one_clct_emu && tmb_two_alct_emu;   // Duplicate clct if there are 2 alcts

                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "TMBemu: tmb_no_alct_emu      = " << logical(tmb_no_alct_emu  ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_no_clct_emu      = " << logical(tmb_no_clct_emu  ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_one_alct_emu     = " << logical(tmb_one_alct_emu ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_one_clct_emu     = " << logical(tmb_one_clct_emu ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_two_alct_emu     = " << logical(tmb_two_alct_emu ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_two_clct_emu     = " << logical(tmb_two_clct_emu ) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_dupe_alct_emu    = " << logical(tmb_dupe_alct_emu) << std::endl;
                                (*MyOutput_) << "TMBemu: tmb_dupe_clct_emu    = " << logical(tmb_dupe_clct_emu) << std::endl;

                                // TMBemu: Duplicate alct and clct
                                alct_dummy  = (clct_bxn_insert_emu << 11);                  // Insert clct bxn for clct-only events
                                clct_dummy  = 0;                                            // Blank  clct for alct-only events
                                clctc_dummy = 0;                                            // Blank  clct common for alct-only events

                                if       (tmb_no_clct_emu  ) {clct0_emu = clct_dummy;  clct1_emu = clct_dummy;  clctc_emu = clctc_dummy;}   // clct0 and clct1 do not exist, use dummy clct 
                                else if  (tmb_dupe_clct_emu) {clct0_emu = clct0_real;  clct1_emu = clct0_real;  clctc_emu = clctc_real; }   // clct0 exists, but clct1 does not exist, copy clct0 into clct1
                                else                         {clct0_emu = clct0_real;  clct1_emu = clct1_real;  clctc_emu = clctc_real; }   // clct0 and clct1 exist, so use them

                                if      (tmb_no_alct_emu  ) {alct0_emu = alct_dummy;  alct1_emu = alct_dummy;} // alct0 and alct1 do not exist, use dummy alct
                                else if (tmb_dupe_alct_emu) {alct0_emu = alct0_real;  alct1_emu = alct0_real;} // alct0 exists, but alct1 does not exist, copy alct0 into alct1
                                else                        {alct0_emu = alct0_real;  alct1_emu = alct1_real;} // alct0 and alct1 exist, so use them

                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "TMBemu: clct0_emu            = " << std::hex << clct0_emu << std::endl;
                                (*MyOutput_) << "TMBemu: clct1_emu            = " << std::hex << clct1_emu << std::endl;
                                (*MyOutput_) << "TMBemu: alct0_emu            = " << std::hex << alct0_emu << std::endl;
                                (*MyOutput_) << "TMBemu: alct1_emu            = " << std::hex << alct1_emu << std::endl;

                                // TMBemu: LCT valid pattern flags
                                lct0_vpf_emu    = alct0_vpf_emu || clct0_vpf_emu;   // First muon exists
                                lct1_vpf_emu    = alct1_vpf_emu || clct1_vpf_emu;   // Second muon exists

                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "TMBemu: lct0_vpf_emu         = " << std::hex << lct0_vpf_emu << std::endl;
                                (*MyOutput_) << "TMBemu: lct1_vpf_emu         = " << std::hex << lct1_vpf_emu << std::endl;

                                // TMBemu: Decompose ALCT muons
                                alct0_valid_emu     = (alct0_emu >>  0) & 0x1;      // Valid pattern flag
                                alct0_quality_emu   = (alct0_emu >>  1) & 0x3;      // Pattern quality
                                alct0_amu_emu       = (alct0_emu >>  3) & 0x1;      // Accelerator muon
                                alct0_key_emu       = (alct0_emu >>  4) & 0x7F;     // Key Wire Group
                                alct0_bxn_emu       = (alct0_emu >> 11) & 0x1;      // Bunch crossing number

                                alct1_valid_emu     = (alct1_emu >>  0) & 0x1;      // Valid pattern flag
                                alct1_quality_emu   = (alct1_emu >>  1) & 0x3;      // Pattern quality
                                alct1_amu_emu       = (alct1_emu >>  3) & 0x1;      // Accelerator muon
                                alct1_key_emu       = (alct1_emu >>  4) & 0x7F;     // Key Wire Group
                                alct1_bxn_emu       = (alct1_emu >> 11) & 0x1;      // Bunch crossing number

                                alct_bx0_emu        = alct0_bxn_emu==0;

                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "TMBemu: alct0_valid_emu      = " << std::hex << alct0_valid_emu    << std::endl;
                                (*MyOutput_) << "TMBemu: alct0_quality_emu    = " << std::hex << alct0_quality_emu  << std::endl;
                                (*MyOutput_) << "TMBemu: alct0_amu_emu        = " << std::hex << alct0_amu_emu      << std::endl;
                                (*MyOutput_) << "TMBemu: alct0_key_emu        = " << std::hex << alct0_key_emu      << std::endl;
                                (*MyOutput_) << "TMBemu: alct0_bxn_emu        = " << std::hex << alct0_bxn_emu      << std::endl;
                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "TMBemu: alct1_valid_emu      = " << std::hex << alct1_valid_emu    << std::endl;
                                (*MyOutput_) << "TMBemu: alct1_quality_emu    = " << std::hex << alct1_quality_emu  << std::endl;
                                (*MyOutput_) << "TMBemu: alct1_amu_emu        = " << std::hex << alct1_amu_emu      << std::endl;
                                (*MyOutput_) << "TMBemu: alct1_key_emu        = " << std::hex << alct1_key_emu      << std::endl;
                                (*MyOutput_) << "TMBemu: alct1_bxn_emu        = " << std::hex << alct1_bxn_emu      << std::endl;
                                (*MyOutput_) << "TMBemu: alct_bx0_emu         = " << std::hex << alct_bx0_emu       << std::endl;

                                // TMBemu: Decompose CLCT muons
                                clct0_valid_emu     = (clct0_emu >>  0) & 0x1;      // Valid pattern flag
                                clct0_hit_emu       = (clct0_emu >>  1) & 0x7;      // Hits on pattern 0-6
                                clct0_pid_emu       = (clct0_emu >>  4) & 0xF;      // Pattern shape 0-A
                                clct0_key_emu       = (clct0_emu >>  8) & 0x1F;     // 1/2-strip ID number
                                clct0_cfeb_emu      = (clct0_emu >> 13) & 0x7;      // Key CFEB ID

                                clct_bxn_emu        = (clctc_emu >>  0) & 0x3;      // Bunch crossing number
                                clct_sync_err_emu   = (clctc_emu >>  2) & 0x1;      // Bx0 disagreed with bxn counter

                                clct1_valid_emu     = (clct1_emu >>  0) & 0x1;      // Valid pattern flag
                                clct1_hit_emu       = (clct1_emu >>  1) & 0x7;      // Hits on pattern 0-6
                                clct1_pid_emu       = (clct1_emu >>  4) & 0xF;      // Pattern shape 0-A
                                clct1_key_emu       = (clct1_emu >>  8) & 0x1F;     // 1/2-strip ID number
                                clct1_cfeb_emu      = (clct1_emu >> 13) & 0x7;      // Key CFEB ID

                                clct0_bend_emu = (clct0_pid_emu >> 0) & 0x1;
                                clct1_bend_emu = (clct1_pid_emu >> 0) & 0x1;

                                csc_id_emu     = csc_id;
                                clct_bx0_emu   = clct_bxn_emu==0;

                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "TMBemu: clct0_valid_emu     = " << std::hex << clct0_valid_emu     << std::endl;
                                (*MyOutput_) << "TMBemu: clct0_hit_emu       = " << std::hex << clct0_hit_emu       << std::endl;
                                (*MyOutput_) << "TMBemu: clct0_pid_emu       = " << std::hex << clct0_pid_emu       << std::endl;
                                (*MyOutput_) << "TMBemu: clct0_key_emu       = " << std::hex << clct0_key_emu       << std::endl;
                                (*MyOutput_) << "TMBemu: clct0_cfeb_emu      = " << std::hex << clct0_cfeb_emu      << std::endl;
                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "TMBemu: clct1_valid_emu     = " << std::hex << clct1_valid_emu     << std::endl;
                                (*MyOutput_) << "TMBemu: clct1_hit_emu       = " << std::hex << clct1_hit_emu       << std::endl;
                                (*MyOutput_) << "TMBemu: clct1_pid_emu       = " << std::hex << clct1_pid_emu       << std::endl;
                                (*MyOutput_) << "TMBemu: clct1_key_emu       = " << std::hex << clct1_key_emu       << std::endl;
                                (*MyOutput_) << "TMBemu: clct1_cfeb_emu      = " << std::hex << clct1_cfeb_emu      << std::endl;
                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "TMBemu: clct0_bend_emu      = " << std::hex << clct0_bend_emu      << std::endl;
                                (*MyOutput_) << "TMBemu: clct1_bend_emu      = " << std::hex << clct1_bend_emu      << std::endl;
                                (*MyOutput_) << "TMBemu: clct_bxn_emu        = " << std::hex << clct_bxn_emu        << std::endl;
                                (*MyOutput_) << "TMBemu: clct_bx0_emu        = " << std::hex << clct_bx0_emu        << std::endl;
                                (*MyOutput_) << "TMBemu: csc_id_emu          = " << std::hex << csc_id_emu          << std::endl;
                                (*MyOutput_) << "TMBemu: clct_sync_err_emu   = " << std::hex << clct_sync_err_emu   << std::endl;
                                (*MyOutput_) << "\n";

                                // LCT Quality
                                alct0_hit_emu  = alct0_quality_emu + 3;             // Convert alct quality to number of hits
                                alct1_hit_emu  = alct1_quality_emu + 3;

                                clct0_cpat_emu = (clct0_hit_emu >= 2);
                                clct1_cpat_emu = (clct1_hit_emu >= 2);

                                ACC  = alct0_amu_emu;               // In   ALCT accelerator muon bit
                                A    = alct0_valid_emu;             // In   bit: ALCT was found
                                C    = clct0_valid_emu;             // In   bit: CLCT was found
                                A4   = alct0_hit_emu>>2 & 0x1;      // In   bit (N_A>=4), where N_A=number of ALCT layers
                                C4   = clct0_hit_emu>>2 & 0x1;      // In   bit (N_C>=4), where N_C=number of CLCT layers
                                P    = clct0_pid_emu;               // In   4-bit CLCT pattern number that is presently 1 for n-layer triggers, 2-10 for current patterns, 11-15 "for future expansion".
                                CPAT = clct0_cpat_emu;              // In   bit for cathode .pattern trigger., i.e. (P>=2 && P<=10) at present

                                lct_quality (ACC, A, C, A4, C4, P, CPAT, Q);

                                lct0_quality_emu = Q;

                                ACC  = alct1_amu_emu;               // In   ALCT accelerator muon bit
                                A    = alct1_valid_emu;             // In   bit: ALCT was found
                                C    = clct1_valid_emu;             // In   bit: CLCT was found
                                A4   = alct1_hit_emu>>2 & 0x1;      // In   bit (N_A>=4), where N_A=number of ALCT layers
                                C4   = clct1_hit_emu>>2 & 0x1;      // In   bit (N_C>=4), where N_C=number of CLCT layers
                                P    = clct1_pid_emu;               // In   4-bit CLCT pattern number that is presently 1 for n-layer triggers, 2-10 for current patterns, 11-15 "for future expansion".
                                CPAT = clct1_cpat_emu;              // In   bit for cathode .pattern trigger., i.e. (P>=2 && P<=10) at present

                                lct_quality (ACC, A, C, A4, C4, P, CPAT, Q);

                                lct1_quality_emu = Q;

                                // TMB is supposed to rank LCTs, but doesn't yet, this is a bug, should be after the mpc0_frame0_pulse section below
                                tmb_rank_err_emu = (lct0_quality_emu*lct0_vpf_emu) < (lct1_quality_emu * lct1_vpf_emu);

                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "TMBemu: tmb_rank_err_emu  = " << std::hex << tmb_rank_err_emu << std::endl;

                                // TMBemu: Format MPC output words
                                mpc0_frame0_emu =
                                    (alct0_key_emu    <<  0)    |
                                    (clct0_pid_emu    <<  7)    |
                                    (lct0_quality_emu << 11)    |
                                    (lct0_vpf_emu     << 15);

                                mpc0_frame1_emu =
                                    (clct0_cfeb_emu<<5) | clct0_key_emu|
                                    (clct0_bend_emu       <<  8)    |
                                    (clct_sync_err_emu    <<  9)    |
                                    ((alct0_bxn_emu & 0x1) << 10)   |
                                    ((clct_bx0_emu  & 0x1) << 11)   |   // bx0 gets replaced after mpc_tx_delay, keep here to mollify xst
                                    ((csc_id_emu    & 0xF) << 12);

                                mpc1_frame0_emu =
                                    (alct1_key_emu    <<  0)    |
                                    (clct1_pid_emu    <<  7)    |
                                    (lct1_quality_emu << 11)    |
                                    (lct1_vpf_emu     << 15);

                                mpc1_frame1_emu =
                                    (clct1_cfeb_emu<<5) | clct1_key_emu|
                                    (clct1_bend_emu       <<  8)    |
                                    (clct_sync_err_emu    <<  9)    |
                                    ((alct1_bxn_emu & 0x1) << 10)   |
                                    ((alct_bx0_emu  & 0x1) << 11)   |   // bx0 gets replaced after mpc_tx_delay, keep here to mollify xst
                                    ((csc_id_emu    & 0xF) << 12);

                                // TMBemu: Construct MPC output words for MPC, blanked if no muons present, except bx0 [inserted after mpc_tx_delay]
                                trig_mpc_emu  = tmb_trig_pulse && tmb_trig_keep;                // Trigger this event
                                trig_mpc0_emu = trig_mpc_emu && lct0_vpf_emu && !kill_clct0;    // LCT 0 is valid, send to mpc
                                trig_mpc1_emu = trig_mpc_emu && lct1_vpf_emu && !kill_clct1;    // LCT 1 is valid, send to mpc

                                mpc0_frame0_pulse = (trig_mpc0_emu) ? mpc0_frame0_emu : 0;
                                mpc0_frame1_pulse = (trig_mpc0_emu) ? mpc0_frame1_emu : 0;
                                mpc1_frame0_pulse = (trig_mpc1_emu) ? mpc1_frame0_emu : 0;
                                mpc1_frame1_pulse = (trig_mpc1_emu) ? mpc1_frame1_emu : 0;

                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "TMBemu: trig_mpc_emu         = " << std::hex << trig_mpc_emu  << std::endl;
                                (*MyOutput_) << "TMBemu: trig_mpc0_emu        = " << std::hex << trig_mpc0_emu << std::endl;
                                (*MyOutput_) << "TMBemu: trig_mpc1_emu        = " << std::hex << trig_mpc1_emu << std::endl;

                                (*MyOutput_) << "\n";
                                (*MyOutput_) << "TMBemu: mpc0_frame0_pulse    = " << std::hex << mpc0_frame0_pulse << std::endl;
                                (*MyOutput_) << "TMBemu: mpc0_frame1_pulse    = " << std::hex << mpc0_frame1_pulse << std::endl;
                                (*MyOutput_) << "TMBemu: mpc1_frame0_pulse    = " << std::hex << mpc1_frame0_pulse << std::endl;
                                (*MyOutput_) << "TMBemu: mpc1_frame1_pulse    = " << std::hex << mpc1_frame1_pulse << std::endl;
                                (*MyOutput_) << "\n";

                                // Read latched MPC data
                                adr    = mpc0_frame0_adr;
                                status = vme_read(adr,rd_data);
                                mpc0_frame0_vme = rd_data;

                                adr    = mpc0_frame1_adr;
                                status = vme_read(adr,rd_data);
                                mpc0_frame1_vme = rd_data;

                                adr    = mpc1_frame0_adr;
                                status = vme_read(adr,rd_data);
                                mpc1_frame0_vme = rd_data;

                                adr    = mpc1_frame1_adr;
                                status = vme_read(adr,rd_data);
                                mpc1_frame1_vme = rd_data;

                                (*MyOutput_) << "VME:    mpc0_frame0_vme      = " << std::hex << mpc0_frame0_vme << std::endl;
                                (*MyOutput_) << "VME:    mpc0_frame1_vme      = " << std::hex << mpc0_frame1_vme << std::endl;
                                (*MyOutput_) << "VME:    mpc1_frame0_vme      = " << std::hex << mpc1_frame0_vme << std::endl;
                                (*MyOutput_) << "VME:    mpc1_frame1_vme      = " << std::hex << mpc1_frame1_vme << std::endl;

                                // TMBemu: Decompose expected MPC frames
                                mpc_alct0_key_expect    =   (mpc0_frame0_pulse >>  0) & 0x007F;
                                mpc_clct0_pid_expect    =   (mpc0_frame0_pulse >>  7) & 0x000F;
                                mpc_lct0_qual_expect    =   (mpc0_frame0_pulse >> 11) & 0x000F;
                                mpc_lct0_vpf_expect     =   (mpc0_frame0_pulse >> 15) & 0x0001;

                                mpc_clct0_key_expect    =   (mpc0_frame1_pulse >>  0) & 0x00FF;
                                mpc_clct0_bend_expect   =   (mpc0_frame1_pulse >>  8) & 0x0001;
                                mpc_sync_err0_expect    =   (mpc0_frame1_pulse >>  9) & 0x0001;
                                mpc_alct0_bxn_expect    =   (mpc0_frame1_pulse >> 10) & 0x0001;
                                mpc_bx0_clct_expect     =   (mpc0_frame1_pulse >> 11) & 0x0001;
                                mpc_csc_id0_expect      =   (mpc0_frame1_pulse >> 12) & 0x000F;

                                mpc_alct1_key_expect    =   (mpc1_frame0_pulse >>  0) & 0x007F;
                                mpc_clct1_pid_expect    =   (mpc1_frame0_pulse >>  7) & 0x000F;
                                mpc_lct1_qual_expect    =   (mpc1_frame0_pulse >> 11) & 0x000F;
                                mpc_lct1_vpf_expect     =   (mpc1_frame0_pulse >> 15) & 0x0001;

                                mpc_clct1_key_expect    =   (mpc1_frame1_pulse >>  0) & 0x00FF;
                                mpc_clct1_bend_expect   =   (mpc1_frame1_pulse >>  8) & 0x0001;
                                mpc_sync_err1_expect    =   (mpc1_frame1_pulse >>  9) & 0x0001;
                                mpc_alct1_bxn_expect    =   (mpc1_frame1_pulse >> 10) & 0x0001;
                                mpc_bx0_alct_expect     =   (mpc1_frame1_pulse >> 11) & 0x0001;
                                mpc_csc_id1_expect      =   (mpc1_frame1_pulse >> 12) & 0x000F;

                                // Decompose MPC frames latched by VME
                                mpc_alct0_key_vme       =   (mpc0_frame0_vme >>  0) & 0x007F;
                                mpc_clct0_pid_vme       =   (mpc0_frame0_vme >>  7) & 0x000F;
                                mpc_lct0_qual_vme       =   (mpc0_frame0_vme >> 11) & 0x000F;
                                mpc_lct0_vpf_vme        =   (mpc0_frame0_vme >> 15) & 0x0001;

                                mpc_clct0_key_vme       =   (mpc0_frame1_vme >>  0) & 0x00FF;
                                mpc_clct0_bend_vme      =   (mpc0_frame1_vme >>  8) & 0x0001;
                                mpc_sync_err0_vme       =   (mpc0_frame1_vme >>  9) & 0x0001;
                                mpc_alct0_bxn_vme       =   (mpc0_frame1_vme >> 10) & 0x0001;
                                mpc_bx0_clct_vme        =   (mpc0_frame1_vme >> 11) & 0x0001;
                                mpc_csc_id0_vme         =   (mpc0_frame1_vme >> 12) & 0x000F;

                                mpc_alct1_key_vme       =   (mpc1_frame0_vme >>  0) & 0x007F;
                                mpc_clct1_pid_vme       =   (mpc1_frame0_vme >>  7) & 0x000F;
                                mpc_lct1_qual_vme       =   (mpc1_frame0_vme >> 11) & 0x000F;
                                mpc_lct1_vpf_vme        =   (mpc1_frame0_vme >> 15) & 0x0001;

                                mpc_clct1_key_vme       =   (mpc1_frame1_vme >>  0) & 0x00FF;
                                mpc_clct1_bend_vme      =   (mpc1_frame1_vme >>  8) & 0x0001;
                                mpc_sync_err1_vme       =   (mpc1_frame1_vme >>  9) & 0x0001;
                                mpc_alct1_bxn_vme       =   (mpc1_frame1_vme >> 10) & 0x0001;
                                mpc_bx0_alct_vme        =   (mpc1_frame1_vme >> 11) & 0x0001;
                                mpc_csc_id1_vme         =   (mpc1_frame1_vme >> 12) & 0x000F;

                                // Compare expected to found MPC frames
                                ck("mpc: mpc_alct0_key  read vme.expect tmbemu ",mpc_alct0_key_vme  ,mpc_alct0_key_expect); 
                                ck("mpc: mpc_clct0_pid  read vme.expect tmbemu ",mpc_clct0_pid_vme  ,mpc_clct0_pid_expect);
                                ck("mpc: mpc_lct0_qual  read vme.expect tmbemu ",mpc_lct0_qual_vme  ,mpc_lct0_qual_expect);
                                ck("mpc: mpc_lct0_vpf   read vme.expect tmbemu ",mpc_lct0_vpf_vme   ,mpc_lct0_vpf_expect);

                                ck("mpc: mpc_clct0_key  read vme.expect tmbemu ",mpc_clct0_key_vme  ,mpc_clct0_key_expect);
                                ck("mpc: mpc_clct0_bend read vme.expect tmbemu ",mpc_clct0_bend_vme ,mpc_clct0_bend_expect);
                                ck("mpc: mpc_sync_err0  read vme.expect tmbemu ",mpc_sync_err0_vme  ,mpc_sync_err0_expect);
                                ck("mpc: mpc_alct0_bxn  read vme.expect tmbemu ",mpc_alct0_bxn_vme  ,mpc_alct0_bxn_expect);
                                ck("mpc: mpc_bx0_clct   read vme.expect tmbemu ",mpc_bx0_clct_vme   ,0);
                                ck("mpc: mpc_csc_id0    read vme.expect tmbemu ",mpc_csc_id0_vme    ,mpc_csc_id0_expect);

                                ck("mpc: mpc_alct1_key  read vme.expect tmbemu ",mpc_alct1_key_vme  ,mpc_alct1_key_expect);
                                ck("mpc: mpc_clct1_pid  read vme.expect tmbemu ",mpc_clct1_pid_vme  ,mpc_clct1_pid_expect);
                                ck("mpc: mpc_lct1_qual  read vme.expect tmbemu ",mpc_lct1_qual_vme  ,mpc_lct1_qual_expect);
                                ck("mpc: mpc_lct1_vpf   read vme.expect tmbemu ",mpc_lct1_vpf_vme   ,mpc_lct1_vpf_expect);

                                ck("mpc: mpc_clct1_key  read vme.expect tmbemu ",mpc_clct1_key_vme  ,mpc_clct1_key_expect);
                                ck("mpc: mpc_clct1_bend read vme.expect tmbemu ",mpc_clct1_bend_vme ,mpc_clct1_bend_expect);
                                ck("mpc: mpc_sync_err1  read vme.expect tmbemu ",mpc_sync_err1_vme  ,mpc_sync_err1_expect);
                                ck("mpc: mpc_alct1_bxn  read vme.expect tmbemu ",mpc_alct1_bxn_vme  ,mpc_alct1_bxn_expect);
                                ck("mpc: mpc_bx0_alct   read vme.expect tmbemu ",mpc_bx0_alct_vme   ,0);
                                ck("mpc: mpc_csc_id1    read vme.expect tmbemu ",mpc_csc_id1_vme    ,mpc_csc_id1_expect);

                                // LCTs for display
                                lct0_vme = (mpc0_frame1_vme<<16) | mpc0_frame0_vme;
                                lct1_vme = (mpc1_frame1_vme<<16) | mpc1_frame0_vme;

                                // Marker state indicats CLCTs found by TMB match injected CLCTs for display
                                marker = "ER";

                                if (clct0_vpf_vme == clct0_vpf_vme_expect &&
                                        clct0_hit_vme == clct0_hit_vme_expect &&
                                        clct0_pid_vme == clct0_pid_vme_expect &&
                                        clct0_key_vme == clct0_key_vme_expect &&
                                        clct1_vpf_vme == clct1_vpf_vme_expect &&
                                        clct1_hit_vme == clct1_hit_vme_expect &&
                                        clct1_pid_vme == clct1_pid_vme_expect &&
                                        clct1_key_vme == clct1_key_vme_expect)
                                    marker = "OK";

                                // Display CLCTs
                                (*MyOutput_) << "\nCFEB" << icfeb << " Key=" << ikeylp << " " << marker.c_str() << "\n"; 

                                //CLCT0
                                (*MyOutput_) 
                                    << "clct0: " 
                                    << " vpf=" << clct0_vpf_tmb 
                                    << " nhit=" << clct0_hit_tmb 
                                    << " pid=" << std::hex << clct0_pid_tmb 
                                    << " key=" << clct0_key_tmb 
                                    << " cfeb=" << clct0_cfeb_tmb 
                                    << " bxn=" << clctc_bxn_tmb 
                                    << std::endl; 

                                //CLCT1
                                (*MyOutput_) 
                                    << "clct1: " 
                                    << " vpf=" << clct1_vpf_tmb 
                                    << " nhit=" << clct1_hit_tmb 
                                    << " pid=" << std::hex << clct1_pid_tmb 
                                    << " key=" << clct1_key_tmb 
                                    << " cfeb=" << clct1_cfeb_tmb 
                                    << " bxn=" << clctc_bxn_tmb
                                    << std::endl; 

                                // Display ALCTs
                                (*MyOutput_)
                                    << "alct0: vpf= "   << alct0_vpf_inj 
                                    << " qual="         << std::hex << alct0_qual_inj 
                                    << " amu="          << alct0_amu_inj 
                                    << " key="          << alct0_key_inj 
                                    << " bxn="          << alct0_bxn_inj
                                    << std::endl; 

                                (*MyOutput_)
                                    << "alct1: vpf= "   << alct1_vpf_inj 
                                    << " qual="         << std::hex << alct1_qual_inj 
                                    << " amu="          << alct1_amu_inj 
                                    << " key="          << alct1_key_inj 
                                    << " bxn="          << alct1_bxn_inj
                                    << std::endl; 

                                // Display LCTs
                                (*MyOutput_) << "lct0=" << std::hex << lct0_vme << " ";
                                (*MyOutput_) << "lct1=" << std::hex << lct1_vme << std::endl << std::endl;

                                // Display CLCT keys generated vs found
                                if (first_scn) {    // Display column heading, show 1/2 strip numbers 0-159
                                    (*MyOutput_) << "\nCLCT_sep=" << clct_sep;
                                    (*MyOutput_) << "                         ";
                                    (*MyOutput_) << "<------------------------------ CLCT key 1/2strips found by TMB ------------------------------->";
                                    //------------------------------------------------------------------------------
                                    (*MyOutput_) << "\n     "; 
                                    for (i=0; i<=159; ++i) {
                                        symbol=' '; 
                                        if (i%32<14||i%32>18) 
                                            (*MyOutput_) << symbol; 
                                        if (i%32==14) 
                                            (*MyOutput_) << "CFEB" << i/32;
                                    }  
                                    //------------------------------------------------------------------------------
                                    (*MyOutput_) << "\n     "; 
                                    for (i=0; i<=159; ++i) {
                                        symbol='-'; 
                                        if (i%32==0||i%32==31) 
                                            symbol='|'; 
                                        (*MyOutput_) << symbol;
                                    }                                   
                                    //------------------------------------------------------------------------------
                                    (*MyOutput_) << "\n     "; 
                                    for (i=0; i<=159; ++i) {
                                        symbol=' '; 
                                        if (i>=100) 
                                            symbol='0'+(i/100)%10;
                                        (*MyOutput_) << symbol;
                                    }
                                    //------------------------------------------------------------------------------
                                    (*MyOutput_) << "\n     "; 
                                    for (i=0; i<=159; ++i) {
                                        symbol=' '; 
                                        if (i>= 10) 
                                            symbol='0'+(i/10 )%10; 
                                        (*MyOutput_) << symbol;
                                    }                                   
                                    //------------------------------------------------------------------------------
                                    (*MyOutput_) << "\n     "; 
                                    for (i=0; i<=159; ++i) {
                                        symbol=' '; 
                                        if (i>=  0) symbol='0'+(i/1  )%10; 
                                        (*MyOutput_) << symbol;
                                    }                                  
                                    (*MyOutput_) << "\n";
                                    //------------------------------------------------------------------------------
                                    first_scn=false;
                                }

                                symbol=' ';                                                         // display row heading
                                if (ikey%32==0||ikey%32==31) symbol='-';
                                (*MyOutput_) << symbol << symbol << std::setw(3) << ikey; 

                                for (i=0; i<=159; ++i) {
                                    symbol=' '; 
                                    if ((1 << (i/32) & active_feb_list)!=0)
                                        symbol='.';                 // cfeb is in the active feb list

                                    if (clct0_vpf_tmb==1 && clct0_key_tmb==i) 
                                        symbol='0'+clct0_hit_tmb;   // clct0 hits 0-6
                                    if (clct1_vpf_tmb==1 && clct1_key_tmb==i) 
                                        symbol='A'+clct1_hit_tmb;   // clct1 hits A-G
                                    if (clct0_vpf_tmb==1 && clct0_key_tmb==i  && clct1_vpf_tmb==1 && clct1_key_tmb==i) 
                                        symbol='X';                 // clct0 and clct1 on the same key, should not happen

                                    (*MyOutput_) << symbol << std::endl;
                                } 

                                (*MyOutput_) << "\n";                                       // cr on current ikey line

                                if (ikey==159) {                                            // partial column headings again after last row
                                    (*MyOutput_) << "     "; 
                                    for (i=0; i<=159; ++i) {
                                        symbol=' '; 
                                        if (i>=0) 
                                            symbol='0'+(i/1)%10; 
                                        (*MyOutput_) << symbol;
                                    }  
                                    (*MyOutput_) << "\n";
                                }

                                do {  //replaced goto statement with do {...} while (false) 
                                    // Get DMB RAM word count and busy bit
                                    if (!rrhd)      break; 

                                    adr    = dmb_wdcnt_adr;
                                    status = vme_read(adr,rd_data);
                                    dmb_wdcnt = rd_data & 0x0FFF;
                                    dmb_busy  = (rd_data >> 14) & 0x0001;

                                    (*MyOutput_) << "Raw Hits Dump: ikey=" << ikey << std::endl;
                                    (*MyOutput_) << "word count = " << dmb_wdcnt << std::endl;
                                    (*MyOutput_) << "busy       = " << dmb_busy << std::endl;

                                    if (dmb_busy) {
                                        (*MyOutput_) << "Can not read RAM: dmb reports busy\n";
                                        break; 
                                    }

                                    if (dmb_wdcnt <= 0) {
                                        (*MyOutput_) << "Can not read RAM: dmb reports word count <=0\n";
                                        break; 
                                    }

                                    // Write RAM read address to TMB
                                    for (i=0; i<=dmb_wdcnt-1; ++i) {
                                        adr     = dmb_ram_adr;
                                        wr_data = i & 0xffff;
                                        status  = vme_write(adr,wr_data);

                                        // Read RAM data from TMB
                                        adr    = dmb_rdata_adr;
                                        status = vme_read(adr,rd_data);             // read lsbs
                                        dmb_rdata_lsb = rd_data;

                                        adr    = dmb_wdcnt_adr;
                                        status = vme_read(adr,rd_data);             // read msbs
                                        dmb_rdata_msb = (rd_data >> 12) & 0x3;      // rdata msbs
                                        dmb_rdata     = dmb_rdata_lsb | (dmb_rdata_msb << 16);

                                        vf_data[i]=dmb_rdata;
                                        if (debug_)
                                            std::cout << "Adr=" << i << " Data=" << std::hex << dmb_rdata << std::endl;
                                    } // close i

                                    // Clear RAM address for next event
                                    adr     = dmb_ram_adr;
                                    wr_data = 0x2000;   // reset RAM write address
                                    status  = vme_write(adr,wr_data);
                                    wr_data = 0x0000;   // unreset
                                    status  = vme_write(adr,wr_data);

                                    // Decode raw hits dump, variables passed by common block struct
                                    decode_readout(vf_data,dmb_wdcnt,err_check=true);

                                    (*MyOutput_) << "Non-zero triad bits=" << nonzero_triads << std::endl;
                                } while (false); //close do loop


                                // Take snapshot of current counter state
                                //L16708:
                                adr = cnt_ctrl_adr;
                                wr_data=0x0022; //snap
                                status = vme_write(adr,wr_data);
                                wr_data=0x0020; //unsnap
                                status = vme_write(adr,wr_data);

                                // Read counters
                                for (i=0; i<mxcounter; ++i) {
                                    for (j=0; j<=1; ++j) {
                                        adr = cnt_ctrl_adr;
                                        wr_data=(i << 9) | 0x0020 | (j << 8);
                                        status = vme_write(adr,wr_data);
                                        adr = cnt_rdata_adr;
                                        status = vme_read(adr,rd_data);

                                        // Combine lsbs+msbs
                                        if (j==0)           // Even addresses contain counter LSBs
                                            cnt_lsb=rd_data;
                                        else {              // Odd addresses contain counter MSBs
                                            cnt_msb=rd_data;
                                            cnt_full=cnt_lsb | (cnt_msb << 16);
                                            cnt[i]=cnt_full;    // Assembled counter MSB,LSB
                                        }
                                    }}  //close j,i

                                // Display counters
                                for (i=0; i<mxcounter; ++i) {
                                    (*MyOutput_) << "\nDisplay Counters:\n";
                                    (*MyOutput_) << "i" << "\t" << "cnt[i]" << "\t" << "scnt[i].c_str()" << std::endl;
                                    (*MyOutput_) << i << "\t" << cnt[i] << "\t" << scnt[i].c_str() << std::endl;
                                }

                                // Read back embedded scope data
                                scp_arm        = false;
                                scp_readout    = true;
                                scp_raw_decode = false;
                                scp_silent     = true;
                                scp_playback   = false;
                                if (rdscope && scp_auto==0)
                                    scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

                                // Close big key-stepping loops
                                if (pause_on_fail) 
                                    pause("<cr> to resume");
                    }   //close for ipidlp
                }  //close for ikeylp

                // Set pattern thresholds back to default
                adr    = seq_clct_adr;
                status = vme_read(adr,rd_data);

                hit_thresh_pretrig_temp   = hit_thresh_pretrig;
                hit_thresh_postdrift_temp = hit_thresh_postdrift;

                wr_data = rd_data & 0x8000;     // clear hit_thresh,nph_pattern,drift
                wr_data = wr_data | (triad_persist             <<  0);
                wr_data = wr_data | (hit_thresh_pretrig_temp   <<  4);
                wr_data = wr_data | (dmb_thresh_pretrig        <<  7);
                wr_data = wr_data | (hit_thresh_postdrift_temp << 10);
                wr_data = wr_data | (drift_delay               << 13);
                status  = vme_write(adr,wr_data);

                // Bang mode
                if (ifunc < 0)  
                    usleep(1500000);
                else
                    break; 
            } //close Bang Mode loop
        } //close Inject_walking_CLCT()

        //------------------------------------------------------------------------------
        //  External Trigger ALCT+CLCT
        //------------------------------------------------------------------------------
        void TMB::TriggerTestExternalTriggerALCTCLCT () {
            ifunc=1;
            inquirb("Global", "rdscope", rdscope);
            //L16800:
            while(true) { //bang mode loop
                if (ifunc<0) rdscope = false;
                else         rdscope = true;

                // Turn off CCB backplane inputs, enable L1A emulator
                adr     = ccb_cfg_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data | 0x0005;
                status  = vme_write(adr,wr_data);

                // Turn off ALCT cable inputs
                adr     = alct_inj_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0x0000;
                wr_data = wr_data | 0x0001;
                wr_data = wr_data | (alct_injector_delay << 5);
                status  = vme_write(adr,wr_data);

                // Turn off CFEB cable inputs
                adr     = cfeb_inj_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFFE0;
                status  = vme_write(adr,wr_data);

                // Turn on CFEB enables to over-ride mask_all
                adr     = seq_trig_en_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0x03FF;     // clear old cfeb_en and source
                wr_data = wr_data | 0x7C00;     // ceb_en_source=0,cfeb_en=1F
                status  = vme_write(adr,wr_data);

                // Select sequencer to take clct ext or alct ext trig
                adr     = seq_trig_en_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFF00;
                wr_data = wr_data | 0x0060;     // Select alct or clct ext trig mode
                status  = vme_write(adr,wr_data);

                // Arm scope trigger
                scp_arm        = true;
                scp_readout    = false;
                scp_raw_decode = false;
                scp_silent     = false;
                scp_playback   = false;
                if (rdscope)
                    scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

                // Fire pseudo-CCB external clct trigger linked to alct
                adr     = ccb_trig_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data | 0x0014;     // fire clct ext trig
                status  = vme_write(adr,wr_data);
                wr_data = rd_data & 0xFFE7;     // unfire
                status  = vme_write(adr,wr_data);

                // Read back trigger register to see what triggered
                adr     = seq_trig_src_adr;
                status  = vme_read(adr,rd_data);

                if (rd_data!=0x0020) 
                    (*MyOutput_) << "Trigger source error rd_data=" << std::hex << rd_data << std::endl;

                // Read back embedded scope data
                scp_arm        = false;
                scp_readout    = true;
                scp_raw_decode = false;
                scp_silent     = true;
                scp_playback   = false;
                if (rdscope && scp_auto==0)
                    scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

                // Bang Mode
                if (ifunc<0)    usleep (1500000);
                else            break;          //exit loop if bang mode == false
            } // close Bang mode loop
        } //close ExternalTriggerALCTCLCT ()

        //------------------------------------------------------------------------------
        //  External Trigger ALCT
        //------------------------------------------------------------------------------
        void TMB::TriggerTestExternalTriggerALCT () {
            ifunc=1;
            inquirb("Global", "rdscope", rdscope);
            while(true) { //bang mode loop
                if (ifunc<0) rdscope = false;
                else         rdscope = true;

                // Turn off CCB backplane inputs, enable L1A emulator
                adr     = ccb_cfg_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data | 0x0005;
                status  = vme_write(adr,wr_data);

                // Turn off ALCT cable inputs
                adr     = alct_inj_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0x0000;
                wr_data = wr_data | 0x0001;
                wr_data = wr_data | (alct_injector_delay << 5);
                status  = vme_write(adr,wr_data);

                // Turn off CFEB cable inputs
                adr     = cfeb_inj_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFFE0;
                status  = vme_write(adr,wr_data);

                // Turn on CFEB enables to over-ride mask_all
                adr     = seq_trig_en_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0x03FF;     // clear old cfeb_en and source
                wr_data = wr_data | 0x7C00;     // ceb_en_source=0,cfeb_en=1F
                status  = vme_write(adr,wr_data);

                // Select sequencer to take clct ext or alct ext trig
                adr      = seq_trig_en_adr;
                status   = vme_read(adr,rd_data);
                wr_data  = rd_data & 0xFF00;
                wr_data  = wr_data | 0x0060;    // Select alct or clct ext trig mode
                status   = vme_write(adr,wr_data);

                // Arm scope trigger
                scp_arm        = true;
                scp_readout    = false;
                scp_raw_decode = false;
                scp_silent     = false;
                scp_playback   = false;
                if (rdscope)
                    scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

                // Fire pseudo-CCB external trigger alct
                adr     = ccb_trig_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data | 0x000C;     // fire alct ext trig
                //  wr_data = rd_data | 0x0014;     // fire clct ext trig !!!!TEMPORARY !!!!!!
                status = vme_write(adr,wr_data);
                wr_data = rd_data | 0xFFF3; // unfire
                status = vme_write(adr,wr_data);

                // Read back trigger register to see what triggered
                adr    = seq_trig_src_adr;
                status = vme_read(adr,rd_data);

                if (rd_data!=0x0040) 
                    (*MyOutput_) << "\tTrigger source error rd_data=" << std::hex << rd_data << std::endl;

                // Read back embedded scope data
                scp_arm        = false;
                scp_readout    = true;
                scp_raw_decode = false;
                scp_silent     = true;
                scp_playback   = false;
                if (rdscope && scp_auto==0)
                    scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

                // Bang mode
                if (ifunc<0)        usleep (1500000);
                else                break; 
            } //close bang mode loop
        } //close ExternalTriggerALCT ()

        //------------------------------------------------------------------------------
        //  External Trigger CLCT
        //------------------------------------------------------------------------------
        //L96000:
        void TMB::TriggerTestExternalTriggerCLCT () {
            ifunc=1;
            inquirb("Global", "rdscope", rdscope);
            while(true) { //bang mode loop
                if (ifunc<0) rdscope = false;
                else         rdscope = true;

                // Turn off CCB backplane inputs, enable L1A emulator
                adr     = ccb_cfg_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data | 0x0005;
                status  = vme_write(adr,wr_data);

                // Turn off ALCT cable inputs
                adr     = alct_inj_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0x0000;
                wr_data = wr_data | 0x0001;
                wr_data = wr_data | (alct_injector_delay << 5);
                status  = vme_write(adr,wr_data);

                // Turn off CFEB cable inputs
                adr     = cfeb_inj_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFFE0;
                status  = vme_write(adr,wr_data);

                // Turn on CFEB enables to over-ride mask_all
                adr     = seq_trig_en_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0x03FF; // clear old cfeb_en and source
                wr_data = wr_data | 0x7C00; // ceb_en_source=0,cfeb_en=1F
                status  = vme_write(adr,wr_data);

                // Select sequencer to take clct ext, turn on all cfebs
                adr     = seq_trig_en_adr;
                wr_data = 0x0220;
                status  = vme_write(adr,wr_data);

                // Arm scope trigger
                scp_arm        = true;
                scp_readout    = false;
                scp_raw_decode = false;
                scp_silent     = false;
                scp_playback   = false;
                if (rdscope)
                    scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

                // Fire pseudo-CCB external trigger clct
                adr     = ccb_trig_adr;
                status  = vme_read(adr,rd_data);
                //  wr_data = rd_data | 0x000C;     // fire alct ext trig
                wr_data = rd_data | 0x0014;     // fire clct ext trig
                status  = vme_write(adr,wr_data);
                wr_data = rd_data & 0xFFE3;     // unfire
                status  = vme_write(adr,wr_data);

                // Read back trigger register to see what triggered
                adr    = seq_trig_src_adr;
                status = vme_read(adr,rd_data);

                if (rd_data!=0x0020) 
                    (*MyOutput_) << "\tTrigger source error rd_data=" << std::hex << rd_data << std::endl;

                // Read back embedded scope data
                scp_arm        = false;
                scp_readout    = true;
                scp_raw_decode = false;
                scp_silent     = true;
                scp_playback   = false;
                if (rdscope && scp_auto==0)
                    scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

                // Loop mode
                if (ifunc<0)        usleep(1500000);
                else                break; 
            } //close bang mode loop
        } //close ExternalTriggerCLCT ()

        //------------------------------------------------------------------------------
        //  External Trigger ALCT+CLCT with GTL pulser
        //------------------------------------------------------------------------------
        void TMB::TriggerTestExternalTriggerALCTCLCTwithGTLpulser () {
            ifunc=1;
            inquirb("Global", "rdscope", rdscope);
            //L96100:

            if (ifunc<0) 
                rdscope = false;
            else         
                rdscope = true;

            // Turn off CCB backplane inputs
            adr     = ccb_cfg_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data | 0x0005;
            status  = vme_write(adr,wr_data);

            // Enable GTL ccb_clct_ext_trig
            adr     = ccb_trig_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data | 0x0040;
            status  = vme_write(adr,wr_data);

            // Turn off ALCT cable inputs
            adr     = alct_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x0000;
            wr_data = wr_data | 0x0001;
            wr_data = wr_data | (alct_injector_delay << 5);
            status  = vme_write(adr,wr_data);

            // Turn off CFEB cable inputs
            adr     = cfeb_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFE0;
            status  = vme_write(adr,wr_data);

            // Turn on CFEB enables to over-ride mask_all
            adr     = seq_trig_en_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x03FF;     // clear old cfeb_en and source
            wr_data = wr_data | 0x7C00;     // ceb_en_source=0,cfeb_en=1F
            status  = vme_write(adr,wr_data);

            // Select sequencer to take clct ext or alct ext trig
            adr     = seq_trig_en_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFF00;
            wr_data = wr_data | 0x0060; // Select alct or clct ext trig mode
            status  = vme_write(adr,wr_data);

            // Turn on sequencer internal L1A
            adr     = seq_l1a_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data | 0x1000;
            status  = vme_write(adr,wr_data);

            // Fire CCB external clct trigger with pulse generator
            pause("Connect GTL pulse generator to P2A D10, monitor TP382-6");

            // Set start_trigger state for FMM
            adr     = ccb_cmd_adr;

            ttc_cmd = 6;            // start_trigger
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);
            wr_data = 0x0003 | (ttc_cmd << 8);
            status  = vme_write(adr,wr_data);
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);

            ttc_cmd = 1;            // bx0
            wr_data = 0x0003 | (ttc_cmd << 8);
            status  = vme_write(adr,wr_data);
            wr_data =0x0001;
            status  = vme_write(adr,wr_data);

            // Arm scope trigger
            scp_arm        = true;
            scp_readout    = false;
            scp_raw_decode = false;
            scp_silent     = false;
            scp_playback   = false;
            if (rdscope)
                scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

            // Read back embedded scope data
            scp_arm        = false;
            scp_readout    = true;
            scp_raw_decode = false;
            scp_silent     = true;
            scp_playback   = false;
            if (rdscope && scp_auto==0)
                scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);


        } // close ExternalTriggerALCTCLCTwithGTLpulser()

        //------------------------------------------------------------------------------
        //  External Trigger ALCT+CLCT with GTL pulser, check CRC
        //------------------------------------------------------------------------------
        //L96200:
        void TMB::TriggerTestExternalALCTCLCTwithGTLpulserCheckCRC () {
            ifunc=1;
            inquirb("Global", "rdscope", rdscope);
            first_event = true;

            if (ifunc<0) {
                rdscope = false;
                rdraw   = false;
            }
            else {
                rdscope = true;
                rdraw   = true;
            }

            // Turn off CCB backplane inputs
            adr     = ccb_cfg_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data | 0x0005;
            status  = vme_write(adr,wr_data);

            // Enable GTL ccb_clct_ext_trig
            adr     = ccb_trig_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data | 0x0040;
            status  = vme_write(adr,wr_data);

            // Turn off ALCT cable inputs
            adr     = alct_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x0000;
            wr_data = wr_data | 0x0001;
            wr_data = wr_data | (alct_injector_delay << 5);
            status  = vme_write(adr,wr_data);

            // Turn off CFEB cable inputs
            adr     = cfeb_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFE0;
            status  = vme_write(adr,wr_data);

            // Turn on CFEB enables to over-ride mask_all
            adr     = seq_trig_en_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x03FF;     // clear old cfeb_en and source
            wr_data = wr_data | 0x7C00;     // ceb_en_source=0,cfeb_en=1F
            status  = vme_write(adr,wr_data);

            // Select sequencer to take clct ext or alct ext trig
            adr     = seq_trig_en_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFF00;
            wr_data = wr_data | 0x0060;     // Select alct or clct ext trig mode
            status  = vme_write(adr,wr_data);

            // Turn on sequencer internal L1A
            adr     = seq_l1a_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data | 0x1000;
            status  = vme_write(adr,wr_data);

            // Set start_trigger state for FMM
            adr     = ccb_cmd_adr;

            ttc_cmd = 6;            // start_trigger
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);
            wr_data = 0x0003 | (ttc_cmd << 8);
            status  = vme_write(adr,wr_data);
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);

            ttc_cmd = 1;            // bx0
            wr_data = 0x0003 | (ttc_cmd << 8);
            status  = vme_write(adr,wr_data);
            wr_data =0x0001;
            status  = vme_write(adr,wr_data);

            // Fire CCB external clct trigger with pulse generator
            pause("Connect GTL pulse generator to P2A D10, monitor TP382-6");

            // Event loop option
            //L96210:

            // Arm scope trigger
            scp_arm        = true;
            scp_readout    = false;
            scp_raw_decode = false;
            scp_silent     = false;
            scp_playback   = false;
            if (rdscope)
                scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

            do {            //do{...} while(false) to replace goto
                // Get DMB RAM word count and busy bit
                if (!rdraw)     break; 

                adr       = dmb_wdcnt_adr;
                status    = vme_read(adr,rd_data);
                dmb_wdcnt = rd_data & 0x0FFF;
                dmb_busy  = (rd_data>>14) & 0x0001;

                (*MyOutput_) << "\tword count = " << dmb_wdcnt << std::endl;
                (*MyOutput_) << "\tbusy       = " << dmb_busy  << std::endl;

                if (dmb_busy==1) {
                    (*MyOutput_) << "\tCan not read RAM: dmb reports busy\n";
                    break; 
                }
                if (dmb_wdcnt<=0) {
                    (*MyOutput_) << "\tCan not read RAM: dmb reports word count <=0";
                    break; 
                }

                // Write RAM read address to TMB
                //L96211:
                for (i=0; i<=dmb_wdcnt-1; ++i) {
                    adr     = dmb_ram_adr;
                    wr_data = i & 0xFFFF;
                    status  = vme_write(adr,wr_data);

                    // Read RAM data from TMB
                    adr    = dmb_rdata_adr;
                    status = vme_read(adr,rd_data);         // read lsbs
                    dmb_rdata_lsb = rd_data;

                    adr    = dmb_wdcnt_adr;
                    status = vme_read(adr,rd_data);         // read msbs

                    dmb_rdata_msb = (rd_data>>12) & 0x3;    // rdata msbs
                    dmb_rdata     = dmb_rdata_lsb | (dmb_rdata_msb<<16);

                    vf_data[i]=dmb_rdata;
                    if (debug_)
                        std::cout << "\tAdr=" << i << " Data=" << std::hex << dmb_rdata << std::endl;
                }   // close for i

                // Clear RAM address for next event
                adr     = dmb_ram_adr;
                wr_data = 0x2000;   // reset RAM write address
                status  = vme_write(adr,wr_data);
                wr_data = 0x0000;   // unreset
                status  = vme_write(adr,wr_data);
            } while(false); //close do{} while().. 

            // Read back embedded scope data
            //L96220:
            scp_arm        = false;
            scp_readout    = true;
            scp_raw_decode = false;
            scp_silent     = true;
            scp_playback   = false;
            if (rdscope && scp_auto==0)
                scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

            // Decode raw hits dump
            decode_readout(vf_data,dmb_wdcnt,err_check=false);

        } // close externalALCTCLCTwithGTLpulserCheckCRC

        //------------------------------------------------------------------------------
        //  Test BXN Counter
        //------------------------------------------------------------------------------
        void TMB::TriggerTestTestBXNCounter() {
            ifunc=1;
            inquirb("Global", "rdscope", rdscope);
            //L96300:
            //bang mode loop
            while(true) { 
                if (ifunc<0) rdscope = false;
                else         rdscope = true;

                // Turn off CCB backplane inputs, turn on L1A emulator
                adr     = ccb_cfg_adr;
                wr_data = 0x003D;
                status  = vme_write(adr,wr_data);

                // Enable sequencer trigger, turn off dmb trigger, set internal l1a delay
                adr     = ccb_trig_adr;
                wr_data = 0x0004;
                wr_data = wr_data | (114<<8);
                status  = vme_write(adr,wr_data);

                // Turn off ALCT cable inputs, enable synchronized alct+clct triggers
                adr     = alct_inj_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0x0000;
                wr_data = wr_data | 0x0005;
                wr_data = wr_data | (alct_injector_delay << 5);
                status  = vme_write(adr,wr_data);

                // Set ALCT delay for TMB matching
                adr     = tmbtim_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFFF0;
                wr_data = wr_data | 0x0003;
                status  = vme_write(adr,wr_data);

                // Turn off CLCT cable inputs
                adr     = cfeb_inj_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFFE0;
                status  = vme_write(adr,wr_data);

                // Turn on CFEB enables to over-ride mask_all
                adr     = seq_trig_en_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0x03FF; // clear old cfeb_en and source
                wr_data = wr_data | 0x7C00; // ceb_en_source=0,cfeb_en=1F
                status  = vme_write(adr,wr_data);

                // Turn off internal level 1 accept for sequencer
                adr     = seq_l1a_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0x0FFF;
                status  = vme_write(adr,wr_data);

                // Select pattern trigger
                adr     = seq_trig_en_adr;
                status  = vme_read(adr,rd_data);
                rd_data = rd_data & 0xFF00;
                wr_data = rd_data | 0x0001;
                status  = vme_write(adr,wr_data);

                // Clear previous ALCT inject
                adr=alct_inj_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFFFD;
                status  = vme_write(adr,wr_data);

                // Set l1reset, which takes FMM to stop trigger
                ttc_cmd = 3;        // l1reset
                adr     = ccb_cmd_adr;
                wr_data = 0x0001;
                status  = vme_write(adr,wr_data);
                wr_data = 0x0003 | (ttc_cmd<<8);
                status  = vme_write(adr,wr_data);
                wr_data =0x0001;
                status  = vme_write(adr,wr_data);

                // Check FMM machine is in stop_trigger state after l1reset
                adr     = ccb_cmd_adr;
                status  = vme_read(adr,rd_data);
                fmm_state = (rd_data >> 4) & 0x0007;

                if (fmm_state!=2) pause("FMM failed to go to stop_trigger");

                // Set FMM start_trigger (wait for bx0) after l1reset
                ttc_cmd=6;      // start_trigger

                adr     = ccb_cmd_adr;
                wr_data = 0x0001;
                status  = vme_write(adr,wr_data);
                wr_data = 0x0003 | (ttc_cmd<<8);
                status  = vme_write(adr,wr_data);
                wr_data = 0x0001;
                status  = vme_write(adr,wr_data);

                // Check FMM machine is waiting for bx0 after start trigger
                adr     = ccb_cmd_adr;
                status  = vme_read(adr,rd_data);
                fmm_state = (rd_data>>4) & 0x0007;

                if (fmm_state!=3) pause("FMM failed to go to fmm_wait_bx0");

                // Set FMM to start_trigger by sending bx0
                ttc_cmd = 1;
                adr     = ccb_cmd_adr;
                wr_data = 0x0003 | (ttc_cmd<<8);
                status  = vme_write(adr,wr_data);
                wr_data = 0x0001;
                status  = vme_write(adr,wr_data);

                // Check FMM machine is in start_trigger state
                adr     = ccb_cmd_adr;
                status  = vme_read(adr,rd_data);
                fmm_state = (rd_data>>4) & 0x0007;

                if (fmm_state!=4) pause("FMM failed to go to start_trigger");

                // Send some triggers, expect bxn stays at 0 1st pass, rarely 0 2nd pass
                ntrig = 100;

                for (ipass=1; ipass<=2; ++ipass)
                {
                    nbxn0 = 0;
                    for (i=1; i<=ntrig; ++i)
                    {
                        // Clear previous  CLCT inject
                        adr     = cfeb_inj_adr;
                        status  = vme_read(adr,rd_data);
                        wr_data = rd_data & 0x7FFF;
                        status  = vme_write(adr,wr_data);

                        // Fire CLCT Injector
                        wr_data = wr_data | 0x8000;
                        status  = vme_write(adr,wr_data);

                        // Clear previous inject    
                        wr_data = rd_data & 0x7FFF; 
                        status  = vme_write(adr,wr_data);

                        // Read back latched CLCT bxn
                        adr    = seq_clctm_adr;
                        status = vme_read(adr,rd_data);
                        clctc_vme = (rd_data >> 0) & 0x0007;

                        // Check bxn is always 0
                        clctc_bxn_vme  =  clctc_vme & 0x0003;       // Bunch crossing number

                        // Print output
                        if (clctc_bxn_vme==0) nbxn0++;
                        (*MyOutput_) << "\tPass " << ipass << " bxn=" << clctc_bxn_vme << std::endl;
                    } // close for ntrig

                    // Print output
                    (*MyOutput_) << "\tBXN was 0 " << nbxn0 << "/" << ntrig << " times" << std::endl;

                    // Set FMM bxn after l1reset to resume bxn counting
                    ttc_cmd = 1;        // bx0
                    adr     = ccb_cmd_adr;
                    wr_data = 0x0001;
                    status  = vme_write(adr,wr_data);
                    wr_data = 0x0003 | (ttc_cmd<<8);
                    status  = vme_write(adr,wr_data);
                    wr_data = 0x0001;
                    status  = vme_write(adr,wr_data);

                } // close for  ipass

                if (ifunc<0)        usleep(100000); 
                else                break; 
            } // close bang mode loop
        }  // Close TestBXNCounter()

        //------------------------------------------------------------------------------
        //  Fire L1A-only event check short  or long header readout
        //------------------------------------------------------------------------------
        int TMB::TriggerTestFireL1A() {
            ifunc=1;
            inquirb("Global", "rdscope", rdscope);

            // Get current fifo_mode, l1a_lookback, hdr_wr_continuous, scope
            adr    = seq_fifo_adr;
            status = vme_read(adr,rd_data);

            fifo_mode       = (rd_data >> 0) & 0x07;    // 3 bits
            fifo_tbins      = (rd_data >> 3) & 0x1F;    // 5 bits
            fifo_pretrig    = (rd_data >> 8) & 0x1F;    // 5 bits
            if (fifo_tbins==0) fifo_tbins=32;

            adr    = l1a_lookback_adr;
            status = vme_read(adr,rd_data);
            l1a_lookback = (rd_data & 0x07FF);

            adr    = seqmod_adr;
            status = vme_read(adr,rd_data);
            hdr_wr_continuous = (rd_data >> 5) & 0x1;

            adr    = scp_ctrl_adr;
            status = vme_read(adr,rd_data);
            scp_auto   =(rd_data >> 3) & 0x1;           // 1 bit
            scp_nowrite=(rd_data >> 4) & 0x1;           // 1 bit
            scp_tbins  =(rd_data >> 5) & 0x7;           // 3 bits


            // Display CLCT fifo mode reminder
            //(*MyOutput_) << "\n";
            //(*MyOutput_) << "\tfifo_mode=0:  Dump=No    Header=Full \n";
            //(*MyOutput_) << "\tfifo_mode=1:  Dump=Full  Header=Full \n";
            //(*MyOutput_) << "\tfifo_mode=2:  Dump=Local Header=Full \n";
            //(*MyOutput_) << "\tfifo_mode=3:  Dump=No    Header=Short\n";
            //(*MyOutput_) << "\tfifo_mode=4:  Dump=No    Header=No   \n";
            //(*MyOutput_) << "\n";

            // Inquire
            inquire("FireL1AEvent", "fifo_mode", 			minv=0, maxv=4,     radix=10, fifo_mode); 	  
            inquire("FireL1AEvent", "fifo_tbins", 			minv=0, maxv=10,    radix=10, fifo_tbins); 	  
            inquire("FireL1AEvent", "fifo_pretrig", 		minv=0, maxv=31,    radix=10, fifo_pretrig); 		
            inquire("FireL1AEvent", "l1a_lookback", 		minv=0, maxv=256,   radix=10, l1a_lookback); 		
            inquire("FireL1AEvent", "hdr_wr_continuous", 	minv=0, maxv=1,     radix=10, hdr_wr_continuous); 	
            inquirb("FireL1AEvent", "fire_injector", 		fire_injector); 								
            inquire("FireL1AEvent", "scp_tbins", 			minv=0, maxv=31,    radix=10, scp_tbins); 		 
            inquire("FireL1AEvent", "alct_injector_delay", 	minv=0, maxv=15,    radix=10, alct_injector_delay);		
            inquire("FireL1AEvent", "l1a_delay", 			minv=0, maxv=10,    radix=10, l1a_delay); 
            inquire("FireL1AEvent", "alct_delay", 			minv=0, maxv=15,    radix=10, alct_delay);	  
            inquire("FireL1AEvent", "clct_width", 			minv=0, maxv=15,    radix=10, clct_width);	  
            inquire("FireL1AEvent", "tmb_allow_clct", 		minv=0, maxv=1,     radix=10, tmb_allow_clct);	
            inquire("FireL1AEvent", "tmb_allow_match", 		minv=0, maxv=1,     radix=10, tmb_allow_match);	   
            inquire("FireL1AEvent", "pid_thresh_pretrig", 	minv=0, maxv=15,    radix=16, pid_thresh_pretrig);   
            inquire("FireL1AEvent", "pid_thresh_postdrift", minv=0, maxv=15,    radix=16, pid_thresh_postdrift);	
            inquire("FireL1AEvent", "adjcfeb_dist", 		minv=0, maxv=63,    radix=10, adjcfeb_dist);	
            inquire("FireL1AEvent", "clct_sep", 			minv=0, maxv=255,   radix=10, clct_sep);	 
            inquire("FireL1AEvent", "active_feb_src", 		minv=0, maxv=1,     radix=10, active_feb_src); 
            inquire("FireL1AEvent", "rat_sync_mode", 		minv=0, maxv=1,     radix=10, rat_sync_mode);	

            inquire("FireL1AEvent", "triad_persist", 		minv=0, maxv=15,    radix=10, triad_persist);  
            inquire("FireL1AEvent", "dmb_thresh_pretrig", 	minv=0, maxv=7,     radix=10, dmb_thresh_pretrig);
            inquire("FireL1AEvent", "hit_thresh_pretrig", 	minv=0, maxv=7,     radix=10, hit_thresh_pretrig);	
            inquire("FireL1AEvent", "hit_thresh_postdrift", minv=0, maxv=7,     radix=10, hit_thresh_postdrift);   
            inquire("FireL1AEvent", "drift_delay", 			minv=0, maxv=3,     radix=10, drift_delay);	  

            // Turn off CFEB cable inputs
            //L96405:
            while(true) { //loop until L1Loopback > 800
                adr     = cfeb_inj_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFFE0;     // mask_all=5'b00000
                status  = vme_write(adr,wr_data);

                // Turn off ALCT cable inputs, enable synchronized alct+clct triggers
                adr     = alct_inj_adr;
                status  = vme_read(adr,rd_data);

                wr_data = rd_data & 0x0000;
                wr_data = wr_data | 0x0005;
                wr_data = wr_data | (alct_injector_delay << 5);
                status  = vme_write(adr,wr_data);

                // Turn on CFEB enables to over-ride mask_all
                adr     = seq_trig_en_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0x03FF;         // clear old cfeb_en and source
                wr_data = wr_data | 0x7C00;         // ceb_en_source=0,cfeb_en=1F
                status  = vme_write(adr,wr_data);

                // Enable sequencer trigger, turn off dmb trigger, set internal l1a delay
                adr     = ccb_trig_adr;
                wr_data = 0x0004;
                wr_data = wr_data | (l1a_delay << 8);
                status  = vme_write(adr,wr_data);

                // Set L1A lookback
                adr     = l1a_lookback_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & ~0x07FF;
                wr_data = wr_data | (l1a_lookback << 0);
                status  = vme_write(adr,wr_data);

                // Set readout machine to respond to unexpected L1As
                adr    = seqmod_adr;
                status = vme_read(adr,rd_data);     // current ccb reg state

                wr_data = (rd_data | 0x0200);       // turn on l1a_allow_notmb bit 9
                status  = vme_write(adr,wr_data);

                // Set new hdr_wr_continuous
                adr    = seqmod_adr;
                status = vme_read(adr,rd_data);
                wr_data = rd_data & ~0x0020;
                wr_data = wr_data | (hdr_wr_continuous << 5);
                status  = vme_write(adr,wr_data);

                // Turn off CCB backplane inputs, turn on L1A emulator, do this after turning off cfeb and alct cable inputs
                adr     = ccb_cfg_adr;
                wr_data = 0x0000;
                wr_data = wr_data | 0x0001; // ccb_ignore_rx
                //  wr_data = wr_data | 0x0004; // ccb_int_l1a_en
                wr_data = wr_data | 0x0008; // ccb_status_oe_vme
                wr_data = wr_data | 0x0010; // alct_status_en
                wr_data = wr_data | 0x0020; // clct_status_en
                status  = vme_write(adr,wr_data);

                // Set ALCT delay for TMB matching
                adr     = tmbtim_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFF00;
                wr_data = wr_data | (alct_delay << 0);
                wr_data = wr_data | (clct_width << 4);
                status  = vme_write(adr,wr_data);

                // Set tmb_match mode
                adr     = tmb_trig_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFFE7;     // clear bits 4,3
                wr_data = wr_data | (tmb_allow_clct  << 3);
                wr_data = wr_data | (tmb_allow_match << 4);
                status  = vme_write(adr,wr_data);

                // Turn off internal level 1 accept for sequencer, set l1a window width
                adr     = seq_l1a_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0x00FF;
                wr_data = wr_data | 0x0300;         //  l1a window width
                status  = vme_write(adr,wr_data);

                // Set fifo tbins
                adr     = seq_fifo_adr;
                status  = vme_read(adr,rd_data);    // get current
                wr_data = rd_data & 0xF000;         // clear lower bits

                wr_data=wr_data
                    | ((fifo_mode    & 0x07) << 0)      // [2:0]
                    | ((fifo_tbins   & 0x1F) << 3)      // [7:3]
                    | ((fifo_pretrig & 0x1F) << 8);     // [12:8]

                status = vme_write(adr,wr_data);

                // Set pid_thresh_pretrig, pid_thresh_postdrift
                adr    = pattern_find_pretrg_adr;
                status = vme_read(adr,rd_data);

                wr_data=rd_data & 0xFC03;
                wr_data=wr_data | (pid_thresh_pretrig   << 2);  // 4 bits
                wr_data=wr_data | (pid_thresh_postdrift << 6);  // 4 bits

                status = vme_write(adr,wr_data);

                // Set adjcfeb_dist
                adr     = pattern_find_pretrg_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0x03FF;         // adjcfeb_dist[5:0] is in [15:10]
                wr_data = wr_data | (adjcfeb_dist << 10);
                status  = vme_write(adr,wr_data);

                // Set CLCT separation
                adr     = clct_separation_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0x00FF;
                wr_data = wr_data | (clct_sep << 8);
                status  = vme_write(adr,wr_data);

                // Set active_feb_list source
                adr     = seqmod_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & ~(1 << 14);
                wr_data = wr_data | (active_feb_src << 14);
                status  = vme_write(adr,wr_data);

                // Set RAT out of sync mode
                adr     = vme_ratctrl_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFFFE;
                wr_data = wr_data | rat_sync_mode;
                status  = vme_write(adr,wr_data);

                // Select clct pattern trigger
                adr     = seq_trig_en_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFF00;
                wr_data = wr_data | 0x0001;
                status  = vme_write(adr,wr_data);

                // Set start_trigger state for FMM
                adr     = ccb_cmd_adr;

                ttc_cmd = 3;            // l1reset
                wr_data = 0x0003 | (ttc_cmd << 8);
                status  = vme_write(adr,wr_data);
                wr_data = 0x0001;
                status  = vme_write(adr,wr_data);

                ttc_cmd = 6;            // start_trigger
                wr_data = 0x0003 | (ttc_cmd << 8);
                status  = vme_write(adr,wr_data);
                wr_data = 0x0001;
                status  = vme_write(adr,wr_data);

                ttc_cmd = 1;            // bx0
                wr_data = 0x0003 | (ttc_cmd << 8);
                status  = vme_write(adr,wr_data);
                wr_data =0x0001;
                status  = vme_write(adr,wr_data);

                // Lower pattern threshold temporarily so edge key 1/2-strips will trigger, set it back later
                adr    = seq_clct_adr;
                status = vme_read(adr,rd_data);

                wr_data = rd_data & 0x8000; // clear hit_thresh,nph_pattern,drift
                wr_data = wr_data | (triad_persist             <<  0);
                wr_data = wr_data | (hit_thresh_pretrig        <<  4);
                wr_data = wr_data | (dmb_thresh_pretrig        <<  7);
                wr_data = wr_data | (hit_thresh_postdrift      << 10);
                wr_data = wr_data | (drift_delay               << 13);
                status  = vme_write(adr,wr_data);

                // Set scope-in-readout
                adr     = scp_ctrl_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data & 0xFF07;  // clear bits 3,4,5,6,7
                wr_data = wr_data | (scp_auto    << 3);
                wr_data = wr_data | (scp_nowrite << 4);
                wr_data = wr_data | (scp_tbins   << 5);
                status  = vme_write(adr,wr_data);

                // Arm scope trigger
                scp_arm        = true;
                scp_readout    = false;
                scp_raw_decode = false;
                scp_silent     = false;
                scp_playback   = false;
                if (rdscope)
                    scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

                // Prepare to fire L1A
                adr     = ccb_cfg_adr;
                status  = vme_read(adr,rd_data);        // current ccb reg state

                wr_data = (rd_data & ~0x0040);          // turn off l1a oneshot bit 6 in case it was on
                status  = vme_write(adr,wr_data);

                wr_fire_l1a = (rd_data | 0x0040);       // ready to fire bit 6 l1a oneshot;

                // Fire CLCT+ALCT Injectors
                (*MyOutput_) << "\nFiring injectors for L1A-only event\n";

                adr     = cfeb_inj_adr;
                status  = vme_read(adr,rd_data);
                wr_data = rd_data | 0x8000;             // fire injector
                status  = vme_write(adr,wr_data);
                wr_data = rd_data & 0x7FFF;             // unfire
                status  = vme_write(adr,wr_data);

                // Fire L1A
                adr     = ccb_cfg_adr;
                wr_data = wr_fire_l1a;
                status  = vme_write(adr,wr_data);       // fire L1A

                status  = vme_read(adr,rd_data);        // current ccb reg state
                wr_data = (rd_data & ~0x0040);          // turn off l1a oneshot
                status  = vme_write(adr,wr_data);

                // Wait for DMB readout to complete
                sleep(1);

                // Get DMB RAM word count and busy bit
                adr    = dmb_wdcnt_adr;
                status = vme_read(adr,rd_data);
                dmb_wdcnt = rd_data & 0x0FFF;
                dmb_busy  = (rd_data >> 14) & 0x0001;

                (*MyOutput_) << "Raw Hits Dump: L1A-only event\n";
                (*MyOutput_) << "word count = " << dmb_wdcnt << std::endl;
                (*MyOutput_) << "busy       = " << dmb_busy << std::endl;

                do {  //do{...} while(false) to replace gotos
                    if (dmb_busy) {
                        (*MyOutput_) << "Can not read RAM: dmb reports busy\n";
                        break; 
                    }

                    if (dmb_wdcnt <= 0) {
                        (*MyOutput_) << "Can not read RAM: dmb reports word count <=0\n";
                        break;
                    }

                    // Write RAM read address to TMB
                    for (i=0; i<=dmb_wdcnt-1; ++i) {
                        adr     = dmb_ram_adr;
                        wr_data = i & 0xffff;
                        status  = vme_write(adr,wr_data);

                        // Read RAM data from TMB
                        adr    = dmb_rdata_adr;
                        status = vme_read(adr,rd_data);             // read lsbs
                        dmb_rdata_lsb = rd_data;

                        adr    = dmb_wdcnt_adr;
                        status = vme_read(adr,rd_data);             // read msbs
                        dmb_rdata_msb = (rd_data >> 12) & 0x3;      // rdata msbs
                        dmb_rdata     = dmb_rdata_lsb | (dmb_rdata_msb << 16);

                        vf_data[i]=dmb_rdata;
                        if (debug_)
                            std::cout << "\tAdr=" << i << " Data=" << std::hex << dmb_rdata << std::endl;
                    } // close i

                    // Clear RAM address for next event
                    adr     = dmb_ram_adr;
                    wr_data = 0x2000;   // reset RAM write address
                    status  = vme_write(adr,wr_data);
                    wr_data = 0x0000;   // unreset
                    status  = vme_write(adr,wr_data);

                    // Decode raw hits dump, variables passed by common block struct
                    decode_readout(vf_data,dmb_wdcnt,err_check=false);

                    // Scanning for non-zero triads
                    (*MyOutput_) << "\tl1a_lookback=  " << l1a_lookback << std::endl;
                    (*MyOutput_) << "Non-zero triad bits= " << nonzero_triads << std::endl;
                    lookback_triad_hits[l1a_lookback%2048]=nonzero_triads;
                    if (ifunc<0) l1a_lookback++;

                    // Read sequencer Debug register
                    for (seqdeb_adr=0; seqdeb_adr<=1; ++seqdeb_adr) {
                        adr     = seq_debug_adr;
                        wr_data = seqdeb_adr;
                        status  = vme_write(adr,wr_data);   // write sub adr
                        status  = vme_read (adr,rd_data);   // read data
                        seqdeb_rd_mux = (rd_data >> 4);     // Extract mux data

                        switch (seqdeb_adr) {
                            case 0x0: deb_wr_buf_adr    = seqdeb_rd_mux; break; // [10:0]   Buffer write address at last pretrig
                            case 0x1: deb_buf_push_adr  = seqdeb_rd_mux; break; // [10:0]   Queue push address at last push
                        }}
                        deb_adr_diff = abs(long(deb_buf_push_adr-deb_wr_buf_adr));

                        (*MyOutput_) << "push_adr-pretrig_adr=" << std::hex << deb_adr_diff << std::endl;

                        // Take snapshot of current counter state
                } while(false); //close do{...} while(false) 
                //L96708:

                adr = cnt_ctrl_adr;
                wr_data=0x0022; //snap
                status = vme_write(adr,wr_data);
                wr_data=0x0020; //unsnap
                status = vme_write(adr,wr_data);

                // Read counters
                for (i=0; i<mxcounter; ++i) {
                    for (j=0; j<=1; ++j) {
                        adr = cnt_ctrl_adr;
                        wr_data=(i << 9) | 0x0020 | (j << 8);
                        status = vme_write(adr,wr_data);
                        adr = cnt_rdata_adr;
                        status = vme_read(adr,rd_data);

                        // Combine lsbs+msbs
                        if (j==0)           // Even addresses contain counter LSBs
                            cnt_lsb=rd_data;
                        else {              // Odd addresses contain counter MSBs
                            cnt_msb=rd_data;
                            cnt_full=cnt_lsb | (cnt_msb << 16);
                            cnt[i]=cnt_full;    // Assembled counter MSB,LSB
                        }
                    }   //close j 
                }       //close i

                // Display counters
                for (i=0; i<mxcounter; ++i) {
                    (*MyOutput_) << "\nDisplay Counters:\n";
                    (*MyOutput_) << "i" << "\t" << "cnt[i]" << "\t" << "scnt[i].c_str()" << std::endl;
                    (*MyOutput_) << i << "\t" << cnt[i] << "\t" << scnt[i].c_str() << std::endl;
                }

                // Read back embedded scope data
                scp_arm        = false;
                scp_readout    = true;
                scp_raw_decode = false;
                scp_silent     = true;
                scp_playback   = false;
                if (rdscope && scp_auto==0)
                    scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

                // Bang mode
                if (ifunc >= 0)
                    return EXIT_SUCCESS; 
                //goto L1600;

                sleep(1);

                // End of bang scan, look for nonzero triads
                //  if (l1a_lookback < 2048) goto L96405;   // Full range of lookbacks
                if (l1a_lookback >  800)   break;           // Shorten cuz we know its in range of 600 to 700

                first_nonzero_bx = 0;
                last_nonzero_bx  = 0;
                max_triads       = 0;

                for (i=0; i<=2047; ++i) {
                    if (lookback_triad_hits[i] !=0) {
                        if (first_nonzero_bx==0) first_nonzero_bx=i;
                        if (lookback_triad_hits[i] > max_triads) max_triads=lookback_triad_hits[i];
                        last_nonzero_bx = i;
                    } //close loopback_triad_hits
                } //close i

                if (first_nonzero_bx!=0) {
                    (*MyOutput_) << "\n";
                    (*MyOutput_) << "\tfirst nonzero triad at l1a_lookback = " << first_nonzero_bx << std::endl;
                    (*MyOutput_) << "\tlast  nonzero triad at l1a_lookback = " << last_nonzero_bx << std::endl;
                    (*MyOutput_) << "\tpeak triad bits                     = " << max_triads << std::endl;
                    (*MyOutput_) << "\n";
                    pause ("<cr> to finish display");
                }
                else {
                    (*MyOutput_) << "\tOh noes! I can has no triads =:-(.\n";
                    return EXIT_FAILURE; 
                }

                // Display lookback values that have nonzero triads
                first_bx = std::max(first_nonzero_bx-10,0);
                last_bx  = std::min(last_nonzero_bx+10,2047);
                scale    = 50./float(max_triads);

                for (i=first_bx; i<= last_bx; ++i) {
                    (*MyOutput_) << "lookback" << i << "bx " << lookback_triad_hits[i] << "triads |";
                    if (lookback_triad_hits[i]>0) for (j=0; j<=lookback_triad_hits[i]*scale; ++j) 
                        (*MyOutput_) << "x";
                    (*MyOutput_) << "\n";
                }
                // Bang mode
                if (ifunc < 0)      usleep(1500000);
                else                break; 
            } //close Bang Mode loop
            return 0; 
        } //close FireL1A()


        //------------------------------------------------------------------------------
        //  Forced CLCT trigger and readout
        //------------------------------------------------------------------------------
        int TMB::TriggerTestForceCLCTtriggerandReadout() {
            ifunc=1;
            inquirb("Global", "rdscope", rdscope);

            icfeb=1;
            display_cfeb=true;

            // Get current cfeb tbins
            adr    = seq_fifo_adr;
            status = vme_read(adr,rd_data);

            fifo_mode       = (rd_data >> 0) & 0x07;    // 3 bits
            fifo_tbins      = (rd_data >> 3) & 0x1F;    // 5 bits
            fifo_pretrig    = (rd_data >> 8) & 0x1F;    // 5 bits
            if (fifo_tbins==0) fifo_tbins=32;

            // Turn off CCB backplane inputs, turn on L1A emulator
            adr     = ccb_cfg_adr;
            wr_data = 0x003D;
            status  = vme_write(adr,wr_data);

            // Enable l1a on sequencer trigger, turn off dmb trigger, set internal l1a delay
            adr     = ccb_trig_adr;
            wr_data = 0x0004;
            wr_data = wr_data | (l1a_delay << 8);
            status  = vme_write(adr,wr_data);

            // Turn off ALCT cable inputs, enable synchronized alct+clct triggers
            adr     = alct_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x0000;
            wr_data = wr_data | 0x0005;
            wr_data = wr_data | (alct_injector_delay << 5);
            status  = vme_write(adr,wr_data);

            // Set ALCT delay for TMB matching
            adr     = tmbtim_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFF0;
            wr_data = wr_data | 0x0003;
            status  = vme_write(adr,wr_data);

            // Turn on all CFEB inputs so we can check for crosstalk
            adr     = cfeb_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFE0;
            wr_data = wr_data | 0x001F;
            status  = vme_write(adr,wr_data);

            // Turn on CFEB enables to over-ride mask_all
            adr     = seq_trig_en_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x03FF;     // clear old cfeb_en and source
            wr_data = wr_data | 0x7C00;     // ceb_en_source=0,cfeb_en=1F
            status  = vme_write(adr,wr_data);

            // Turn off internal level 1 accept for sequencer, set l1a window width
            adr     = seq_l1a_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0x00FF;
            wr_data = wr_data | 0x0300;     // l1a window width
            status  = vme_write(adr,wr_data);

            // Turn off CLCT pattern trigger
            adr     = seq_trig_en_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFF00;
            status  = vme_write(adr,wr_data);

            // Clear previous ALCT inject
            adr     = alct_inj_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFFFD;
            status  = vme_write(adr,wr_data);

            // Set start_trigger state for FMM
            ttc_cmd = 6;            // start_trigger
            adr     = ccb_cmd_adr;
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);
            wr_data = 0x0003 | (ttc_cmd << 8);
            status  = vme_write(adr,wr_data);
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);

            ttc_cmd = 1;            // bx0
            wr_data = 0x0003 | (ttc_cmd << 8);
            status  = vme_write(adr,wr_data);
            wr_data = 0x0001;
            status  = vme_write(adr,wr_data);

            // Clear DMB RAM write-address
            adr     = dmb_ram_adr;
            wr_data = 0x2000;   //reset RAM write address
            status  = vme_write(adr,wr_data);
            wr_data = 0x0000;   // unreset
            status  = vme_write(adr,wr_data);

            // Fire VME trigger
            adr     = seq_trig_en_adr;
            status  = vme_read(adr,rd_data);
            wr_data = rd_data & 0xFF00;
            wr_data = wr_data | (1 << 7);   // fire vme trigger
            status  = vme_write(adr,wr_data);
            wr_data = rd_data & 0xFF00;     // unfire vme trigger
            status  = vme_write(adr,wr_data);

            // Wait for TMB to read out to DMB
            sleep(1);

            // Get DMB RAM word count and busy bit
            adr       = dmb_wdcnt_adr;
            status    = vme_read(adr,rd_data);
            dmb_wdcnt = rd_data & 0x0FFF;
            dmb_busy  = (rd_data >> 14) & 0x0001;

            (*MyOutput_) << "\tdmb word count = " << dmb_wdcnt << std::endl;
            (*MyOutput_) << "\tdmb busy       = " << dmb_busy << std::endl;

            if (dmb_busy  != 0) pause ("Can not read RAM: dmb reports busy");
            if (dmb_wdcnt <= 0) pause ("Can not read RAM: dmb reports word count <=0");

            (*MyOutput_) << "\nProcessing Dump\n"; 

            // Write RAM read address to TMB
            for (iadr=0; iadr<=dmb_wdcnt-1; ++iadr) {
                adr     = dmb_ram_adr;
                wr_data = iadr & 0xFFFF;
                status  = vme_write(adr,wr_data);

                // Read RAM data from TMB
                adr    = dmb_rdata_adr;
                status = vme_read(adr,rd_data);         // read lsbs
                dmb_rdata_lsb=rd_data;

                adr    = dmb_wdcnt_adr;
                status = vme_read(adr,rd_data);         // read msbs
                dmb_rdata_msb = (rd_data >> 12) & 0x3;  // rdata msbs

                dmb_rdata = dmb_rdata_lsb | (dmb_rdata_msb << 16);
                vf_data[iadr]=dmb_rdata;

                if (debug_)
                    std::cout << "\tAdr=" << iadr << " Data=" << std::hex << dmb_rdata << std::endl;
            }   // close iadr

            // Clear RAM address for next event
            adr     = dmb_ram_adr;
            wr_data = 0x2000;   // reset RAM write address
            status  = vme_write(adr,wr_data);
            wr_data = 0x0000;   // unreset
            status  = vme_write(adr,wr_data);

            // Point to start of CFEB data
            iframe     = 5;
            r_nheaders = vf_data[iframe] & 0x3F;                    // Number of header words
            adr_e0b    = r_nheaders;

            (*MyOutput_) << "r_nheaders=" << r_nheaders << std::endl;
            if (adr_e0b <=0) pause ("Unreasonable nheaders");

            iframe=19;
            r_ncfebs     =  (vf_data[iframe] >>  0) & 0x7;      // Number of CFEBs read out
            r_fifo_tbins =  (vf_data[iframe] >>  3) & 0x1F;     // Number of time bins per CFEB in dump


            (*MyOutput_) << "r_fifo_tbins=" << r_fifo_tbins << std::endl;
            if (r_fifo_tbins<=0) pause ("Unreasonable ntbins");

            // Copy triad bits to a holding array
            iframe = adr_e0b+1;                                     // First raw hits frame for cfeb0
            //  iframe = iframe + icfeb*(r_fifo_tbins*6);               // First frame for icfeb

            for (jcfeb  = 0; jcfeb  <= r_ncfebs-1;     ++jcfeb ) {  // Loop over all cfebs so we can see crosstalk
                for (itbin  = 0; itbin  <= r_fifo_tbins-1; ++itbin ) {  // Loop over time bins
                    for (ilayer = 0; ilayer <= mxly-1;         ++ilayer) {  // Loop over layers

                        rdcid  = (vf_data[iframe] >> 12) & 0x7;                 // CFEB ID in the dump
                        rdtbin = (vf_data[iframe] >>  8) & 0xF;                 // Tbin number in the dump
                        hits8  =  vf_data[iframe]        & 0xFF;                // 8 triad block

                        for (ids=0; ids< mxds; ++ids) {                         // Loop over hits per block
                            hits1=(hits8 >> ids) & 0x1;                             // Extract 1 hit
                            ids_abs=ids+jcfeb*8;                                    // Absolute distrip id
                            read_pat[itbin][ilayer][ids_abs]=hits1;                 // hit this distrip
                            if (hits1 != 0) nonzero_triads++;                       // Count nonzero triads
                            (*MyOutput_)
                                << "iframe=" << iframe
                                << " vf_data=" << std::hex << vf_data[iframe]
                                << " hits8=" << hits8
                                << " jcfeb=" << jcfeb
                                << " itbin=" << itbin
                                << " ids_abs=" << ids_abs
                                << " hits1=" << hits1
                                << std::endl;
                        }                                                       // Close ids
                        iframe++;                                               // Next frame
                    }                                                       // Close for ilayer
                }                                                       // Close for itbin
            }                                                       // Close for jcfeb

            // Display cfeb and ids column markers
            if (display_cfeb) {
                (*MyOutput_) << "\n";
                (*MyOutput_) << "     Raw Hits Triads\n";
                (*MyOutput_) << "Cfeb-";
                for (jcfeb=0; jcfeb<mxcfeb; ++jcfeb) { 
                    (*MyOutput_) << "|"; // display cfeb columms
                    for (ids=0; ids<mxds; ++ids)   
                        (*MyOutput_) << jcfeb ;
                } //close jcfeb
                (*MyOutput_) << "|\n";
                (*MyOutput_) << "Ds---";
                for (jcfeb=0; jcfeb < mxcfeb; ++jcfeb) { 
                    (*MyOutput_) << "|";    // display ids columns
                    for (ids=0; ids<mxds; ++ids)
                        (*MyOutput_) << ids%10;
                }//close jcfeb
                (*MyOutput_) << "|\n";
                (*MyOutput_) << "Ly Tb\n";

                // Display CFEB raw hits
                for (ilayer=0; ilayer <= mxly-1; ++ilayer){
                    for (itbin=0;  itbin  <= r_fifo_tbins-1; ++itbin ) {
                        (*MyOutput_) << ilayer << " " << itbin;
                        for (ids_abs=0;ids_abs<=39;++ids_abs) {
                            if (ids_abs%8==0) {
                                (*MyOutput_) << "|";
                            } //close if
                            (*MyOutput_) << read_pat[itbin][ilayer][ids_abs];
                        }   // close for ids_abs
                        (*MyOutput_) << "|\n";
                    }   // close for itbin
                    (*MyOutput_) << "\n";
                }   // close ilayer
            }   // close display cfeb
            return 0; 
        } //close ForceCLCTtriggerandReadout

        //------------------------------------------------------------------------------
        // Entry decode_raw_hits()
        //------------------------------------------------------------------------------
        void TMB::decode_readout(int	vf_data[mxframe],int &dmb_wdcnt, bool &err_check) {
            bool			header_ok;
            bool			header_only_short;
            bool			header_only_long;
            bool			header_full;
            bool			header_filler;
            static bool		first_entry=true;

            const int		wdcnt_short_hdr=12;
            const int		wdcnt_long_hdr=48;

            int				adr_b0c;
            int				adr_e0b;
            int				adr_b04;
            int				adr_e04;
            int				adr_b05;
            int				adr_e05;
            int				adr_b07;
            int				adr_e07;
            int				adr_bcb;
            int				adr_ecb;
            int				adr_e0c;
            int				adr_fil;
            int				adr_e0f;

            // Local
            int				i;
            int				ipair;
            int				last_frame;

            long int		din;
            long int		crc;
            long int		crc_calc;
            long int		tmb_crc_lsb;
            long int		tmb_crc_msb;
            long int		tmb_crc;
            bool			crc_match;

            int				dmb_wdcnt_trun;
            //int				fifo_cfeb_enable;
            int				frame_cnt_expect;
            int				frame_cnt_expect_trun;
            int				frame_cntex_nheaders;
            int				frame_cntex_ntbins;
            int				frame_cntex_b0ce0c;
            int				frame_cntex_rpc;
            int				frame_cntex_b04e04;
            int				frame_cntex_scope;
            int				frame_cntex_b05e05;
            int				frame_cntex_miniscope;
            int				frame_cntex_b07e07;
            int				frame_cntex_bcbecb;
            int				frame_cntex_blockedbits;
            int				frame_cntex_fill;
            int				frame_cntex_trailer;

            int				clct0;
            int				clct0_vpf;
            int				clct0_nhit;
            int				clct0_pat;
            int				clct0_key;
            int				clct0_cfeb;
            int				clct0_fullkey;

            int				clct1;
            int				clct1_vpf;
            int				clct1_nhit;
            int				clct1_pat;
            int				clct1_key;
            int				clct1_cfeb;
            int				clct1_fullkey;

            int				clctc;
            int				clctc_bxn;
            int				clctc_sync;

            int				mpc0_frame0;
            int				mpc0_frame1;
            int				mpc1_frame0;
            int				mpc1_frame1;

            int				mpc_alct0_key;
            int				mpc_clct0_pat;
            int				mpc_lct0_quality;
            int				mpc_lct0_vpf;

            int				mpc_clct0_key;
            int				mpc_clct0_bend;
            int				mpc_sync_err0;
            int				mpc_alct0_bxn;
            int				mpc_bx0_clct;
            int				mpc_csc_id0;

            int				mpc_alct1_key;
            int				mpc_clct1_pat;
            int				mpc_lct1_quality;
            int				mpc_lct1_vpf;

            int				mpc_clct1_key;
            int				mpc_clct1_bend;
            int				mpc_sync_err1;
            int				mpc_alct1_bxn;
            int				mpc_bx0_alct;
            int				mpc_csc_id1;

            int				mpc_clct0_key_expect;
            int				mpc_clct0_pat_expect;
            int				mpc_alct0_key_expect;

            int				mpc_clct1_key_expect;
            int				mpc_clct1_pat_expect;
            int				mpc_alct1_key_expect;

            // Local
            int				icfeb;
            int				itbin;
            int				ilayer;

            int				rdcid;
            int				rdtbin;
            int				itbin_expect;	
            int				hits1;
            int				hits8;
            int				ids;
            int				ids_abs;
            int				read_pat[mxtbins][mxly][mxdsabs];
            bool			triad_skipped;

            char			x[]="          ";

            int				active_febs_expect;
            int				active_febs_flipped;
            int				clctc_bxn_vme;
            int				clctc_bxn_header;
            static int		l1a_rxcount_save;
            int				l1a_rxcount_expect;
            static int		trig_counter_save;
            int				trig_counter_expect;
            int				l1a_type_expect;

            int				rpc_data0;
            int				rpc_data1;
            int				rpc_lsbs;
            int				rpc_tbin;
            int				rpc_msbs;
            int				rpc_bxn;
            int				rpc_flag;
            int				rpc_data;
            int				rpc_id0;
            int				rpc_id1;

            int				bd_status_vec[15];
            int				lhc_cycle=3564;

            std::string			sfifo_mode;
            std::string			sreadout_type;
            std::string			sl1a_type;
            std::string			scsc_type_inferred;
            char			csc_type_code;

            int				id_rev;
            int				id_rev_day;
            int				id_rev_month;
            int				id_rev_year;
            int				id_rev_fpga;

            int				pretrig_counter;
            int				clct_counter;
            int				trig_counter;
            int				alct_counter;
            int				uptime_counter;
            int				uptime_sec;

            bool			triad_error;
            int				triad_read;
            int				triad_write;

            int				wrtbin;
            //int				ntbins;
            int				ntbinspre;

            int				wdcnt;
            int				data;
            int				first_word;
            int				last_word;

            int				first_rpc_frame;
            int				last_rpc_frame;

            int				ncfebs_met;
            int				icfeb_included;
            bool			non_trig_event;
            bool			non_trig_override;

            int				first_bcb_frame;
            int				last_bcb_frame;
            int				bcb_data[4];
            int				bcb_cfebid[4];
            int				bcb_cfeb_ly[5][6];
            int				blocked_distrips[5][6][8];

            int				hdr_one_alct;
            int				hdr_one_clct;
            int				hdr_two_alct;
            int				hdr_two_clct;
            int				hdr_dupe_alct;
            int				hdr_dupe_clct;

            int				iscp_begin;
            int				iscp_end;
            int				iscp;
            int				scp_arm;
            int				scp_readout;
            int				scp_raw_decode;
            int				scp_silent;
            int				scp_raw_data[512*160/16-1];	//512tbins*160ch/(16ch/frame)
            int				miniscope_data[2048];

            //---------------------------------------------------------------------------------
            //	Error flags
            //---------------------------------------------------------------------------------
            const	int		MXERF=39+1;
            char			error_flag[MXERF];
            static	std::string	error_msg[MXERF];

            if(first_entry) {
                error_msg[ 0] = "0xDB0C first frame marker not found";
                error_msg[ 1] = "0xDE0C or 0xDEEF last frame marker not found";
                error_msg[ 2] = "Calculated word count does not match caller";
                error_msg[ 3] = "Word count <=0";
                error_msg[ 4] = "Word count not a multiple of 4";
                error_msg[ 5] = "Wordcount does not match short or long header format";
                error_msg[ 6] = "CRC error =  embedded does not match calculated";
                error_msg[ 7] = "First frame missing 0xDB0C marker";
                error_msg[ 8] = "First 4 frames do not have DDU-special codes";
                error_msg[ 9] = "Last  4 frames do not have DDU-special codes";
                error_msg[10] = "Last frame-3 missing EEF marker";
                error_msg[11] = "Last frame-3 missing E0F marker";
                error_msg[12] = "Last 4 frames missing bit[11]=1";
                error_msg[13] = "Fifo mode does not match short header format";
                error_msg[14] = "Readout type does not match short header format";
                error_msg[15] = "Fifo mode does not match long  header format";
                error_msg[16] = "Readout type does not match long header format";
                error_msg[17] = "Readout type does not match full header format";
                error_msg[18] = "Readout type does not match FIFO mode";
                error_msg[19] = "Expected frame count does not match actual frame count";
                error_msg[20] = "E0B marker not found at expected address";
                error_msg[21] = "B04 marker not found at expected address";
                error_msg[22] = "E04 marker not found at expected address";
                error_msg[23] = "B05 marker not found at expected address";
                error_msg[24] = "E05 marker not found at expected address";
                error_msg[25] = "E0C marker not found at expected address";
                error_msg[26] = "2AAA filler not found at expected address";
                error_msg[27] = "5555 filler not found at expected address";
                error_msg[28] = "Bad board hardware status";
                error_msg[29] = "Clock bx0 sync error";
                error_msg[30] = "RAM SEU parity error";
                error_msg[31] = "CLCT0 key does not match LCT0";
                error_msg[32] = "CLCT0 pattern ID does not match LCT0";
                error_msg[33] = "ALCT0 key does not match LCT0";
                error_msg[34] = "CLCT1 key does not match LCT1";
                error_msg[35] = "CLCT1 pattern ID does not match LCT1";
                error_msg[36] = "ALCT1 key does not match LCT1";
                error_msg[37] = "Expected number of CFEBs 0<r_ncfebs<=5";
                error_msg[38] = "Expected number of CFEB tbins 0<r_fifo_tbins";
                error_msg[39] = "Active CFEB list to DMB does not match CFEBs read out";
            }

            //---------------------------------------------------------------------------------
            //	Board status
            //---------------------------------------------------------------------------------
            const	int		MXSTAT=14+1;
            static	std::string	bd_status_msg[MXSTAT];
            int				bd_status_expect[MXSTAT];

            if(first_entry) {
                bd_status_msg[ 0] = "bd_status_ok  ";
                bd_status_msg[ 1] = "vstat_5p0vs   ";
                bd_status_msg[ 2] = "vstat_3p3v    ";
                bd_status_msg[ 3] = "vstat_1p8v    ";
                bd_status_msg[ 4] = "vstat_1p5v    ";
                bd_status_msg[ 5] = "_t_crit       ";
                bd_status_msg[ 6] = "vsm_ok        ";
                bd_status_msg[ 7] = "vsm_aborted   ";
                bd_status_msg[ 8] = "vsm_cksum_ok  ";
                bd_status_msg[ 9] = "vsm_wdcnt_ok  ";
                bd_status_msg[10] = "jsm_ok        ";
                bd_status_msg[11] = "jsm_aborted   ";
                bd_status_msg[12] = "jsm_cksum_ok  ";
                bd_status_msg[13] = "jsm_wdcnt_ok  ";
                bd_status_msg[14] = "sm_tck_fpga_ok";
            }
            //---------------------------------------------------------------------------------
            //	Header data types
            //---------------------------------------------------------------------------------
            int			ddu[mxframe];
            int			iframe;

            int			boc;
            int			pop_l1a_bxn;
            int			pop_l1a_rx_counter;
            int			readout_counter;
            int			board_id;
            int			csc_id;
            int			run_id;
            int			h4_buf_q_ovf_err;
            int			r_sync_err;

            int			r_nheaders;
            int			fifo_mode;
            int			readout_type;
            int			l1a_type;
            int			r_has_buf;
            int			r_buf_stalled;
            int			bd_status;
            int			revcode;

            int			r_bxn_counter_ff;
            int			r_tmb_clct0_discard;
            int			r_tmb_clct1_discard;
            int			clock_lock_lost;

            int			r_pretrig_counter_lsb;
            int			r_pretrig_counter_msb;

            int			r_clct_counter_lsb;
            int			r_clct_counter_msb;

            int			r_trig_counter_lsb;
            int			r_trig_counter_msb;

            int			r_alct_counter_lsb;
            int			r_alct_counter_msb;

            int			r_orbit_counter_lsb;
            int			r_orbit_counter_msb;

            int			r_ncfebs;
            int			r_fifo_tbins;
            int			fifo_pretrig;
            int			scope_exists;
            int			miniscope_exists;

            int			hit_thresh_pretrig;
            int			pid_thresh_pretrig;
            int			hit_thresh_postdrf;
            int			pid_thresh_postdrf;
            int			stagger_csc;
            //	int			csc_me1ab;

            int			triad_persist;
            int			dmb_thresh;
            int			alct_delay;
            int			clct_window;

            // CLCT Trigger Status
            int			r_trig_source_vec;
            int			r_trig_source_vec9;
            int			r_trig_source_vec10;
            int			r_layers_hit;

            int			r_active_feb_ff;
            int			r_febs_read;
            int			r_l1a_match_win;
            int			hs_layer_trig;
            int			active_feb_src;

            // CLCT+ALCT Match Status
            int			r_tmb_match;
            int			r_tmb_alct_only;
            int			r_tmb_clct_only;
            int			r_tmb_match_win;
            int			r_no_alct_tmb;
            int			r_one_alct_tmb;
            int			r_one_clct_tmb;
            int			r_two_alct_tmb;
            int			r_two_clct_tmb;
            int			r_dupe_alct_tmb;
            int			r_dupe_clct_tmb;
            int			r_rank_err_tmb;

            // CLCT Trigger Data
            int			r_clct0_tmb_lsb;
            int			r_clct1_tmb_lsb;
            int			r_clct0_tmb_msb;
            int			r_clct1_tmb_msb;
            int			r_clctc_tmb;
            int			r_clct0_invp;
            int			r_clct1_invp;
            int			r_clct1_busy;
            int			perr_cfeb_ff;
            int			perr_rpc_ff;
            int			perr_ff;

            // ALCT Trigger Data
            int			r_alct0_valid;
            int			r_alct0_quality;
            int			r_alct0_amu;
            int			r_alct0_key;
            int			r_alct_pretrig_win;

            int			r_alct1_valid;
            int			r_alct1_quality;
            int			r_alct1_amu;
            int			r_alct1_key;
            int			drift_delay;
            int			h_bcb_read_enable;

            int			r_alct_bxn;
            int			alct_ecc_err;
            int			cfeb_badbits_found;
            int			cfeb_badbits_blocked;
            int			alct_cfg_done;
            int			bx0_match;

            // MPC Frames
            int			r_mpc0_frame0_lsb;
            int			r_mpc0_frame1_lsb;
            int			r_mpc1_frame0_lsb;
            int			r_mpc1_frame1_lsb;
            int			r_mpc0_frame0_msb;
            int			r_mpc0_frame1_msb;
            int			r_mpc1_frame0_msb;
            int			r_mpc1_frame1_msb;
            int			mpc_tx_delay;
            int			r_mpc_accept;
            int			cfeb_en;

            // RPC Configuration
            int			rd_rpc_list;
            int			rd_nrpcs;
            int			rpc_read_enable;
            int			fifo_tbins_rpc;
            int			fifo_pretrig_rpc;

            // Buffer Status
            int			r_wr_buf_adr;
            int			r_wr_buf_ready;
            int			wr_buf_ready;
            int			buf_q_full;
            int			buf_q_empty;

            int			r_buf_fence_dist;
            int			buf_q_ovf_err;
            int			buf_q_udf_err;
            int			buf_q_adr_err;
            int			buf_stalled_once;

            // Spare Frames
            int			buf_fence_cnt;
            int			reverse_hs_csc;
            int			reverse_hs_me1a;
            int			reverse_hs_me1b;

            int			buf_fence_cnt_peak;
            int			tmb_trig_pulse;

            int			tmb_allow_alct;
            int			tmb_allow_clct;
            int			tmb_allow_match;
            int			tmb_allow_alct_ro;
            int			tmb_allow_clct_ro;
            int			tmb_allow_match_ro;
            int			tmb_alct_ro;
            int			tmb_clct_ro;
            int			tmb_match_ro;
            int			tmb_trig_keep;
            int			tmb_nontrig_keep;
            int			lyr_thresh_pretrig;
            int			layer_trig_en;

            // E0B marker
            int			eob;
            int			eoc;

            // Optional 2 frames to make word count a multiple of 4
            int			opt2aaa;
            int			opt5555;

            // Last 4 trailer words must conform to DDU specification
            int			eof;
            int			lctype3;
            int			crc22lsb;
            int			lctype2;
            int			crc22msb;
            int			lctype1;
            int			frame_cnt;
            int			lctype0;

            //---------------------------------------------------------------------------------
            //	Entry
            //---------------------------------------------------------------------------------
            (*MyOutput_) << std::endl;

            // Init check bits
            first_entry       = false;
            header_ok         = true;
            header_only_short = false;
            header_only_long  = false;
            header_full       = false;
            header_filler     = false;

            // Clear error flags
            for (i=0; i<MXERF; ++i) 
                error_flag[i]=0;

            //---------------------------------------------------------------------------------
            //  Scan incoming data stream for begin DB0C and end E0F (or DEEF) markers
            //---------------------------------------------------------------------------------
            wdcnt      =  0;
            data       =  0;
            first_word = -1;
            last_word  = -1;

            // Scan for DB0C and DE0F/DEEF markers, DEEF might be crc in full dump, nb Dxxx markers are not unique, could be bxn or wdcnt
            for (i=0; i<mxframe; ++i) {
                data=vf_data[i]&0xFFFF;		// Trim out-of band bits
                fprintf(stdout,"Adr=%5i Data=%6.5X\n",i,data);
                if ((data==0xDB0C) && (first_word < 0))	first_word=i;
                if (((data==0xDE0F) || (data==0xDEEF)) && (i > first_word+3) && (last_word < 0)) last_word=i+3;
                if (i==last_word) break;
            }

            last_frame=last_word;

            // Did not find DB0C
            if(first_word==-1) {
                header_ok=false;
                error_flag[0]=1;	 // 0xDB0C first frame marker not found
                (*MyOutput_) << "ERRs: 0xDB0C first frame marker not found\n" << std::endl;
            }
            else
                (*MyOutput_) << "First frame marker found at Adr=" << first_word << " Data= " << std::hex << vf_data[first_word] << std::endl; 

            // Did not find DE0F/DEEF
            if(last_word ==-1) {
                header_ok=false;
                error_flag[1]=1;	 // 0xDE0C or 0xDEEF last frame marker not found
                (*MyOutput_) << "ERRs: 0xDE0C or 0xDEEF last frame marker not found\n" << std::endl;
            }
            else
                (*MyOutput_) << "Last frame marker found at Adr=" << last_word << " Data= " << std::hex << vf_data[first_word] << std::endl; 

            // Compare word count to callers value [caller may not have supplied a word count]
            wdcnt=1+last_word-first_word;

            (*MyOutput_) << "Calculated word count=" << wdcnt;
            (*MyOutput_) << "Callers    word count=" << dmb_wdcnt;

            if(wdcnt != dmb_wdcnt) {
                header_ok=false;
                error_flag[2]=1;	 // Calculated word count does not match caller
                (*MyOutput_) << "ERRs: Calculated word count does not match caller: wdcnt=" << wdcnt << " dmb_wdcnt=" << dmb_wdcnt << std::endl; 
            }

            //	dmb_wdcnt=wdcnt;	// Uncomment if caller did not supply a word count

            //---------------------------------------------------------------------------------
            //	Check word count matches either short,long or full mode, and is a multiple of 4
            //---------------------------------------------------------------------------------
            // No TMB data
            if(dmb_wdcnt <= 0) {
                header_ok=false;
                error_flag[3]=1;	// Wordcount <=0
                (*MyOutput_) << "ERRs: No TMB readout to decode. wdcnt=" << dmb_wdcnt << std::endl; 
                goto exit;
            }

            // Check that wdcnt is a multiple of 4, all TMB readouts are mod(4) for DDU error checking
            if(dmb_wdcnt%4 != 0) {
                header_ok=false;
                error_flag[4]=1;	// Wordcount not multiple of 4
                (*MyOutput_) << "ERRs: TMB wdcnt is not a multiple of 4. wdcnt=" << dmb_wdcnt << std::endl; 
            }
            (*MyOutput_) << "TMB wdcnt is a multiple of 4. wdcnt=" << dmb_wdcnt << std::endl; 

            // Short header-only mode
            if(dmb_wdcnt == wdcnt_short_hdr) {
                header_only_short=true;
                (*MyOutput_) << "TMB readout short header-only mode. wdcnt=" << dmb_wdcnt << std::endl; 
            }

            // Long header-only mode
            if(dmb_wdcnt == wdcnt_long_hdr) {
                header_only_long=true;
                (*MyOutput_) << "TMB readout long header-only mode. wdcnt=" << dmb_wdcnt << std::endl; 
            }

            // Long header with raw hits mode
            if(dmb_wdcnt > wdcnt_long_hdr) {
                header_full=true;
                (*MyOutput_) << "TMB readout long header with raw hits mode. wdcnt=" << dmb_wdcnt << std::endl; 
            }

            // Check that header format is recognized
            if (!(header_only_short || header_only_long || header_full)) {
                header_ok=false;
                error_flag[5]=1;	// Wordcount does not match short or long header format
                (*MyOutput_) << "ERRs: TMB wdcnt does not match a defined header format. wdcnt=" << dmb_wdcnt << std::endl; 
            }

            (*MyOutput_) << "header_only_short = " << logical(header_only_short) << std::endl;
            (*MyOutput_) << "header_only_long  = " << logical(header_only_long) << std::endl;
            (*MyOutput_) << "header_full       = " << logical(header_full) << std::endl;
            (*MyOutput_) << "header_filler     = " << logical(header_filler) << std::endl;

            //------------------------------------------------------------------------------
            //	Check CRC
            //------------------------------------------------------------------------------
            // Calculate CRC for data stream
            if(dmb_wdcnt < 12) {	// should not ever get here
                (*MyOutput_) << "TMB raw hits dump too short for crc calculation, exiting.\n";
                pause("TMB raw hits dump too short for crc calculation");
                header_ok=false;
                goto exit;
            }

            crc=0;
            for (iframe=0; iframe<=dmb_wdcnt-1; ++iframe) {
                din=vf_data[iframe];
                din=din & 0xFFFF;
                if(iframe==0) crc22a(din,crc,1);				// Reset crc
                crc22a(din,crc,0);								// Calc  crc
                if(iframe==dmb_wdcnt-1-4) crc_calc=crc;			// Latch result prior to de0f marker beco ddu fails to process de0f frame
                (*MyOutput_) << "iframe=" << iframe << " din=" << std::hex << din << "crc= " << std::hex << crc << std::endl; 
            }

            // Compare our computed CRC to what TMB computed
            tmb_crc_lsb=vf_data[dmb_wdcnt-1-2] & 0x07FF;	// 11 crc bits per frame
            tmb_crc_msb=vf_data[dmb_wdcnt-1-1] & 0x07FF;	// 11 crc bits per frame

            tmb_crc=tmb_crc_lsb | (tmb_crc_msb << 11);		// Full 22 bit crc
            crc_match=crc_calc==tmb_crc;

            (*MyOutput_) << "calc crc  =" << std::hex << crc_calc << std::endl;
            (*MyOutput_) << "tmb crc   =" << std::hex << tmb_crc << std::endl;
            (*MyOutput_) << "crc_match =" << logical(crc_match) << std::endl;

            // CRC mismatch
            if(!crc_match) {
                header_ok=false;
                error_flag[6]=1;	// CRC error, embedded does not match calculated
                fprintf(stdout,"Expect vf_data[%i]=%5.5ld \n",(dmb_wdcnt-1-2),((crc_calc>> 0) & 0x07FF));	
                fprintf(stdout,"Expect vf_data[%i]=%5.5ld \n",(dmb_wdcnt-1-1),((crc_calc>>11) & 0x07FF));	
                pause ("TMB crc ERROR in decode_raw_hits, WTF!?");
            }

            //-------------------------------------------------------------------------------
            //	Unpack first 8 header frames, format is common to short, long, and full modes
            //-------------------------------------------------------------------------------
            // First 4 header words must conform to DDU specification
            iframe=0;
            boc=				(vf_data[iframe] >>  0) & 0xFFF;	// Beginning of Cathode record marker
            ddu[iframe]=		(vf_data[iframe] >> 12) & 0xF;		// DDU special

            iframe=1;
            pop_l1a_bxn=		(vf_data[iframe] >>  0) & 0xFFF;	// Bxn pushed on L1A stack at L1A arrival
            ddu[iframe]=		(vf_data[iframe] >> 12) & 0xF;		// DDU special

            iframe=2;
            pop_l1a_rx_counter=	(vf_data[iframe] >>  0) & 0xFFF;	// L1As received and pushed on L1A stack
            ddu[iframe]=		(vf_data[iframe] >> 12) & 0xF;		// DDU special

            iframe=3;
            readout_counter=	(vf_data[iframe] >>  0) & 0xFFF;	// Readout counter, same as l1a_rx_counter for now
            ddu[iframe]=		(vf_data[iframe] >> 12) & 0xF;		// DDU special

            // Next 4 words for short, long or full header modes
            iframe=4;
            board_id=			(vf_data[iframe] >>  0) & 0x1F;		// TMB module ID number = VME slot
            csc_id=				(vf_data[iframe] >>  5) & 0xF;		// Chamber ID number
            run_id=				(vf_data[iframe] >>  9) & 0xF;		// Run info
            h4_buf_q_ovf_err=	(vf_data[iframe] >> 13) & 0x1;		// Fence queue overflow error
            r_sync_err=			(vf_data[iframe] >> 14) & 0x1;		// BXN sync error
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=5;
            r_nheaders=			(vf_data[iframe] >>  0) & 0x3F;		// Number of header words
            fifo_mode=			(vf_data[iframe] >>  6) & 0x7;		// Trigger type and fifo mode
            readout_type=		(vf_data[iframe] >>  9) & 0x3;		// Readout type: dump,nodump, full header, short header
            l1a_type=			(vf_data[iframe] >> 11) & 0x3;		// L1A Pop type code: buffers, no buffers, clct/alct_only
            r_has_buf=			(vf_data[iframe] >> 13) & 0x1;		// Event has clct and rpc buffer data
            r_buf_stalled=		(vf_data[iframe] >> 14) & 0x1;		// Raw hits buffer was full at pretrigger
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=6;
            bd_status=			(vf_data[iframe] >>  0) & 0x7FFF;	// Board status summary
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=7;
            revcode=			(vf_data[iframe] >>  0) & 0x7FFF;	// Firmware version date code
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            // Short header-only mode ends here, next 4 frames should be trailer
            if (header_only_short) goto unpack_trailer;

            //---------------------------------------------------------------------------------------
            //	Unpack frames 8-47 for long header-only mode or long header with full raw hits readout
            //----------------------------------------------------------------------------------------
            iframe=8;
            r_bxn_counter_ff=	(vf_data[iframe] >>  0) & 0xFFF;	// Full CLCT Bunch Crossing number at pretrig
            r_tmb_clct0_discard=(vf_data[iframe] >> 12) & 0x1;		// TMB discarded CLCT0 from ME1A
            r_tmb_clct1_discard=(vf_data[iframe] >> 13) & 0x1;		// TMB discarded CLCT1 from ME1A
            clock_lock_lost=	(vf_data[iframe] >> 14) & 0x1;		// Clock lock lost
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=9;
            r_pretrig_counter_lsb=(vf_data[iframe] >>  0) & 0x7FFF;	// Counts CLCT pre-triggers [stops on ovf]
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=10;
            r_pretrig_counter_msb=(vf_data[iframe] >>  0) & 0x7FFF;	// Counts CLCT pre-triggers [stops on ovf]
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=11;
            r_clct_counter_lsb=	(vf_data[iframe] >>  0) & 0x7FFF;	// Counts CLCTs post-drift [stops on ovf]
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=12;
            r_clct_counter_msb=	(vf_data[iframe] >>  0) & 0x7FFF;	// Counts CLCTs post-drift [stops on ovf]
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=13;
            r_trig_counter_lsb=	(vf_data[iframe] >>  0) & 0x7FFF;	// Counts TMB triggers to MPC, L1A request to CCB,
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=14;
            r_trig_counter_msb=	(vf_data[iframe] >>  0) & 0x7FFF;	// Counts TMB triggers to MPC, L1A request to CCB,
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=15;
            r_alct_counter_lsb=	(vf_data[iframe] >>  0) & 0x7FFF;	// Counts ALCTs received from ALCT board [stops on ovf]
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=16;
            r_alct_counter_msb=	(vf_data[iframe] >>  0) & 0x7FFF;	// Counts ALCTs received from ALCT board [stops on ovf]
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=17;
            r_orbit_counter_lsb=(vf_data[iframe] >>  0) & 0x7FFF;	// BX0s since last hard reset [stops on ovf]
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=18;
            r_orbit_counter_msb=(vf_data[iframe] >>  0) & 0x7FFF;	// BX0s since last hard reset [stops on ovf]
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            // CLCT Raw Hits Size
            iframe=19;
            r_ncfebs=			(vf_data[iframe] >>  0) & 0x7;		// Number of CFEBs read out
            r_fifo_tbins=		(vf_data[iframe] >>  3) & 0x1F;		// Number of time bins per CFEB in dump
            fifo_pretrig=		(vf_data[iframe] >>  8) & 0x1F;		// # Time bins before pretrigger
            scope_exists=		(vf_data[iframe] >> 13) & 0x1;		// Readout includes logic analyzer scope data
            miniscope_exists=	(vf_data[iframe] >> 14) & 0x1;		// Readout includes miniscope data
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special
            if (r_fifo_tbins==0 && r_ncfebs!=0) r_fifo_tbins=32;	// TMB treats 0 tbins as 32 if cfeb readout is enabled

            // CLCT Configuration
            iframe=20;
            hit_thresh_pretrig=	(vf_data[iframe] >>  0) & 0x7;		// Hits on pattern template pre-trigger threshold
            pid_thresh_pretrig=	(vf_data[iframe] >>  3) & 0xF;		// Pattern shape ID pre-trigger threshold
            hit_thresh_postdrf=	(vf_data[iframe] >>  7) & 0x7;		// Hits on pattern post-drift threshold
            pid_thresh_postdrf=	(vf_data[iframe] >> 10) & 0xF;		// Pattern shape ID post-drift threshold
            stagger_csc=		(vf_data[iframe] >> 14) & 0x1;		// CSC Staggering ON
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=21;
            triad_persist=		(vf_data[iframe] >>  0) & 0xF;		// CLCT Triad persistence
            dmb_thresh=			(vf_data[iframe] >>  4) & 0x7;		// DMB pre-trigger threshold for active-feb
            alct_delay=			(vf_data[iframe] >>  7) & 0xF;		// Delay ALCT for CLCT match window
            clct_window=		(vf_data[iframe] >> 11) & 0xF;		// CLCT match window width
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            // CLCT Trigger Status
            iframe=22;
            r_trig_source_vec=	(vf_data[iframe] >>  0) & 0x1FF;	// Trigger source vector
            r_layers_hit=		(vf_data[iframe] >>  9) & 0x3F;		// CSC layers hit on layer trigger
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=23;
            r_active_feb_ff=	(vf_data[iframe] >>  0) & 0x1F;		// Active CFEB list sent to DMB
            r_febs_read=		(vf_data[iframe] >>  5) & 0x1F;		// CFEBs read out for this event
            r_l1a_match_win=	(vf_data[iframe] >> 10) & 0xF;		// Position of l1a in window
            active_feb_src=		(vf_data[iframe] >> 14) & 0x1;		// Active CFEB list source
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            // CLCT+ALCT Match Status
            iframe=24;
            r_tmb_match=		(vf_data[iframe] >>  0) & 0x1;		// ALCT and CLCT matched in time, pushed on L1A stack
            r_tmb_alct_only=	(vf_data[iframe] >>  1) & 0x1;		// Only ALCT triggered, pushed on L1a stack
            r_tmb_clct_only=	(vf_data[iframe] >>  2) & 0x1;		// Only CLCT triggered, pushed on L1A stack
            r_tmb_match_win=	(vf_data[iframe] >>  3) & 0xF;		// Location of alct in clct window, pushed on L1A stack
            r_no_alct_tmb=		(vf_data[iframe] >>  7) & 0x1;		// No ALCT
            r_one_alct_tmb=		(vf_data[iframe] >>  8) & 0x1;		// One ALCT
            r_one_clct_tmb=		(vf_data[iframe] >>  9) & 0x1;		// One CLCT
            r_two_alct_tmb=		(vf_data[iframe] >> 10) & 0x1;		// Two ALCTs
            r_two_clct_tmb=		(vf_data[iframe] >> 11) & 0x1;		// Two CLCTs
            r_dupe_alct_tmb=	(vf_data[iframe] >> 12) & 0x1;		// ALCT0 copied into ALCT1 to make 2nd LCT
            r_dupe_clct_tmb=	(vf_data[iframe] >> 13) & 0x1;		// CLCT0 copied into CLCT1 to make 2nd LCT
            r_rank_err_tmb=		(vf_data[iframe] >> 14) & 0x1;		// LCT1 has higher quality than LCT0
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            // CLCT Trigger Data
            iframe=25;
            r_clct0_tmb_lsb=	(vf_data[iframe] >>  0) & 0x7FFF;	// CLCT0 after drift lsbs
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=26;
            r_clct1_tmb_lsb=	(vf_data[iframe] >>  0) & 0x7FFF;	// CLCT1 after drift lsbs
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=27;
            r_clct0_tmb_msb=	(vf_data[iframe] >>  0) & 0x1;		// CLCT0 after drift msbs
            r_clct1_tmb_msb=	(vf_data[iframe] >>  1) & 0x1;		// CLCT1 after drift msbs
            r_clctc_tmb=		(vf_data[iframe] >>  2) & 0x7;		// CLCTC after drift
            r_clct0_invp=		(vf_data[iframe] >>  5) & 0x1;		// CLCT0 had invalid pattern after drift delay
            r_clct1_invp=		(vf_data[iframe] >>  6) & 0x1;		// CLCT1 had invalid pattern after drift delay
            r_clct1_busy=		(vf_data[iframe] >>  7) & 0x1;		// 2nd CLCT busy, logic error indicator
            perr_cfeb_ff=		(vf_data[iframe] >>  8) & 0x1F;		// CFEB parity error
            perr_rpc_ff=		(vf_data[iframe] >> 13) & 0x1;		// RPC  parity error
            perr_ff=			(vf_data[iframe] >> 14) & 0x1;		// Parity error summary
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            // ALCT Trigger Data
            iframe=28;
            r_alct0_valid=		(vf_data[iframe] >>  0) & 0x1;		// ALCT0 valid pattern flag
            r_alct0_quality=	(vf_data[iframe] >>  1) & 0x3;		// ALCT0 quality
            r_alct0_amu=		(vf_data[iframe] >>  3) & 0x1;		// ALCT0 accelerator muon flag
            r_alct0_key=		(vf_data[iframe] >>  4) & 0x7F;		// ALCT0 key wire group
            r_alct_pretrig_win=	(vf_data[iframe] >> 11) & 0xF;		// ALCT active_feb_flag position in pretrig window
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=29;
            r_alct1_valid=		(vf_data[iframe] >>  0) & 0x1;		// ALCT1 valid pattern flag
            r_alct1_quality=	(vf_data[iframe] >>  1) & 0x3;		// ALCT1 quality
            r_alct1_amu=		(vf_data[iframe] >>  3) & 0x1;		// ALCT1 accelerator muon flag
            r_alct1_key=		(vf_data[iframe] >>  4) & 0x7F;		// ALCT1 key wire group
            drift_delay=		(vf_data[iframe] >> 11) & 0x3F;		// CLCT drift delay
            h_bcb_read_enable=	(vf_data[iframe] >> 13) & 0x1;		// CFEB blocked bits included in readout
            hs_layer_trig=		(vf_data[iframe] >> 14) & 0x1;		// Layer-mode trigger
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=30;
            r_alct_bxn=			(vf_data[iframe] >>  0) & 0x1F;		// ALCT0/1 bxn
            alct_ecc_err=		(vf_data[iframe] >>  5) & 0x3;		// ALCT trigger path ECC error code
            cfeb_badbits_found=	(vf_data[iframe] >>  7) & 0x1F;		// Bad distrip bits detected in cfeb[n]
            cfeb_badbits_blocked=(vf_data[iframe] >> 12) & 0x1;		// At least one CFEB has a bad bit that was blocked
            alct_cfg_done=		(vf_data[iframe] >> 13) & 0x1;		// ALCT FPGA configuration done
            bx0_match=			(vf_data[iframe] >> 14) & 0x1;		// alct_bx0==clct_bx0, latched at clct_bx0 time
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            // MPC Frames
            iframe=31;
            r_mpc0_frame0_lsb=	(vf_data[iframe] >>  0) & 0x7FFF;	// MPC muon 0 frame 0 LSBs
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=32;
            r_mpc0_frame1_lsb=	(vf_data[iframe] >>  0) & 0x7FFF;	// MPC muon 0 frame 1 LSBs
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=33;
            r_mpc1_frame0_lsb=	(vf_data[iframe] >>  0) & 0x7FFF;	// MPC muon 1 frame 0 LSBs
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=34;
            r_mpc1_frame1_lsb=	(vf_data[iframe] >>  0) & 0x7FFF;	// MPC muon 1 frame 1 LSBs
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=35;
            r_mpc0_frame0_msb=	(vf_data[iframe] >>  0) & 0x1;		// MPC muon 0 frame 0 MSB
            r_mpc0_frame1_msb=	(vf_data[iframe] >>  1) & 0x1;		// MPC muon 0 frame 1 MSB
            r_mpc1_frame0_msb=	(vf_data[iframe] >>  2) & 0x1;		// MPC muon 1 frame 0 MSB
            r_mpc1_frame1_msb=	(vf_data[iframe] >>  3) & 0x1;		// MPC muon 1 frame 1 MSB
            mpc_tx_delay=		(vf_data[iframe] >>  4) & 0xF;		// MPC transmit delay
            r_mpc_accept=		(vf_data[iframe] >>  8) & 0x3;		// MPC muon accept response
            cfeb_en=			(vf_data[iframe] >> 10) & 0x1F;		// CFEBs enabled for triggering
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            // RPC Configuration
            iframe=36;
            rd_rpc_list=		(vf_data[iframe] >>  0) & 0x3;		// RPCs included in read out
            rd_nrpcs=			(vf_data[iframe] >>  2) & 0x3;		// Number of RPCs in readout, 0,1,2
            rpc_read_enable=	(vf_data[iframe] >>  4) & 0x1;		// RPC readout enabled
            fifo_tbins_rpc=		(vf_data[iframe] >>  5) & 0x1F;		// Number RPC FIFO time bins to read out
            fifo_pretrig_rpc=	(vf_data[iframe] >> 10) & 0x1F;		// Number RPC FIFO time bins before pretrigger
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special
            if (fifo_tbins_rpc==0 && rd_nrpcs!=0) fifo_tbins_rpc=32;// TMB treats 0 tbins as 32 if rpc readout is enabled

            // Buffer Status
            iframe=37;
            r_wr_buf_adr=		(vf_data[iframe] >>  0) & 0x7FF;	// Buffer RAM write address at pretrigger
            r_wr_buf_ready=		(vf_data[iframe] >> 11) & 0x1;		// Write buffer was ready at pretrig
            wr_buf_ready=		(vf_data[iframe] >> 12) & 0x1;		// Write buffer ready now
            buf_q_full=			(vf_data[iframe] >> 13) & 0x1;		// All raw hits ram in use, ram writing must stop
            buf_q_empty=		(vf_data[iframe] >> 14) & 0x1;		// No fences remain on buffer stack
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=38;
            r_buf_fence_dist=	(vf_data[iframe] >>  0) & 0x7FF;	// Distance to 1st fence address at pretrigger
            buf_q_ovf_err=		(vf_data[iframe] >> 11) & 0x1;		// Tried to push when stack full
            buf_q_udf_err=		(vf_data[iframe] >> 12) & 0x1;		// Tried to pop when stack empty
            buf_q_adr_err=		(vf_data[iframe] >> 13) & 0x1;		// Fence adr popped from stack doesnt match rls adr
            buf_stalled_once=	(vf_data[iframe] >> 14) & 0x1;		// Buffer stalled at least once
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            // Spare Frames
            iframe=39;
            buf_fence_cnt=		(vf_data[iframe] >>  0) & 0xFFF;	// Number of fences in fence RAM currently
            reverse_hs_csc=		(vf_data[iframe] >> 12) & 0x1;		// 1=Reverse staggered CSC, non-me1
            reverse_hs_me1a=	(vf_data[iframe] >> 13) & 0x1;		// 1=ME1A hstrip order reversed
            reverse_hs_me1b=	(vf_data[iframe] >> 14) & 0x1;		// 1=ME1B hstrip order reversed
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=40;
            buf_fence_cnt_peak=	(vf_data[iframe] >>  0) & 0xFFF;	// Peak number of fences in fence RAM
            r_trig_source_vec9=	(vf_data[iframe] >> 12) & 0x1;		// Pre-trigger was ME1A only
            r_trig_source_vec10=(vf_data[iframe] >> 13) & 0x1;		// Pre-trigger was ME1B only
            tmb_trig_pulse=		(vf_data[iframe] >> 14) & 0x1;		// TMB trig pulse
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=41;
            tmb_allow_alct=		(vf_data[iframe] >>  0) & 0x1;		// Allow ALCT-only  tmb-matching
            tmb_allow_clct=		(vf_data[iframe] >>  1) & 0x1;		// Allow CLCT-only  tmb-matching
            tmb_allow_match=	(vf_data[iframe] >>  2) & 0x1;		// Allow Match-only tmb-matching
            tmb_allow_alct_ro=	(vf_data[iframe] >>  3) & 0x1;		// Allow ALCT-only  tmb-matching, nontrig readout
            tmb_allow_clct_ro=	(vf_data[iframe] >>  4) & 0x1;		// Allow CLCT-only  tmb-matching, nontrig readout
            tmb_allow_match_ro=	(vf_data[iframe] >>  5) & 0x1;		// Allow Match-only tmb-matching, nontrig readout
            tmb_alct_ro=		(vf_data[iframe] >>  6) & 0x1;		// Allow ALCT-only  tmb-matching, nontrig readout
            tmb_clct_ro=		(vf_data[iframe] >>  7) & 0x1;		// Allow CLCT-only  tmb-matching, nontrig readout
            tmb_match_ro=		(vf_data[iframe] >>  8) & 0x1;		// Allow Match-only tmb-matching, nontrig readout
            tmb_trig_keep=		(vf_data[iframe] >>  9) & 0x1;		// Triggering readout
            tmb_nontrig_keep=	(vf_data[iframe] >> 10) & 0x1;		// Non-triggering readout
            lyr_thresh_pretrig=	(vf_data[iframe] >> 11) & 0x7;		// Layer pre-trigger threshold
            layer_trig_en=		(vf_data[iframe] >> 14) & 0x1;		// Layer-trigger mode enabled
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            // EOB marker
            iframe=42;
            eob=				(vf_data[iframe] >>  0) & 0x7FFF;	// EOB
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            // EOC marker
            iframe=last_frame-6;
            eoc=				(vf_data[iframe] >>  0) & 0x7FFF;
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            //------------------------------------------------------------------------------
            // Unpack optional 2 filler frames to make word count a multiple of 4
            //------------------------------------------------------------------------------
            iframe=last_frame-5;
            opt2aaa=			(vf_data[iframe] >>  0) & 0x7FFF;
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            iframe=last_frame-4;
            opt5555=			(vf_data[iframe] >>  0) & 0x7FFF;
            ddu[iframe]=		(vf_data[iframe] >> 15) & 0x1;		// DDU special

            //------------------------------------------------------------------------------
            //	Unpack trailer frames: Last 4 trailer words must conform to DDU specification
            //------------------------------------------------------------------------------
unpack_trailer:

            iframe=last_frame-3;
            eof=				(vf_data[iframe] >>  0) & 0xFFF;
            lctype3=			(vf_data[iframe] >> 11) & 0x1;
            ddu[iframe]=		(vf_data[iframe] >> 12) & 0xF;		// DDU special

            iframe=last_frame-2;
            crc22lsb=			(vf_data[iframe] >>  0) & 0x7FF;
            lctype2=			(vf_data[iframe] >> 11) & 0x1;
            ddu[iframe]=		(vf_data[iframe] >> 12) & 0xF;		// DDU special

            iframe=last_frame-1;
            crc22msb=			(vf_data[iframe] >>  0) & 0x7FF;
            lctype1=			(vf_data[iframe] >> 11) & 0x1;
            ddu[iframe]=		(vf_data[iframe] >> 12) & 0xF;		// DDU special

            iframe=last_frame;
            frame_cnt=			(vf_data[iframe] >>  0) & 0x7FF;
            lctype0=			(vf_data[iframe] >> 11) & 0x1;
            ddu[iframe]=		(vf_data[iframe] >> 12) & 0xF;		// DDU special

            //------------------------------------------------------------------------------
            // Check DDU frame structure
            //------------------------------------------------------------------------------
            // First frame must be DB0C marker
            iframe=0;
            if ((vf_data[iframe]&0xFFFF)!=0xDB0C) {
                header_ok=false; 
                error_flag[7]=1;		// First frame missing 0xDB0C marker
                fprintf(stdout,"ERRs: Expected 0xDB0C marker in vf_data[%i], found %5.5X\n",iframe,vf_data[iframe]);
            }

            // First 4 frames must have DDU special D-code set
            for (iframe=0; iframe<=3; ++iframe) {
                if (ddu[iframe]!=0xD) {
                    header_ok=false; 
                    error_flag[8]=1;		// First 4 frames do not have DDU-special codes
                    fprintf(stdout,"ERRs: Expected DDU special code in vf_data[%iframe], found %5.5X\n",iframe,vf_data[iframe]);
                } //close if 
            } //close for

            // Last 4 frames must have DDU special D-code set
            for (iframe=last_frame-3; iframe<=last_frame; ++iframe) {
                if (ddu[iframe]!=0xD) {
                    header_ok=false;
                    error_flag[9]=1;		// Last 4 frames do not have DDU-special codes
                }
            }

            // Last frame-3 must be EEF for short header or E0F for long header
            if (header_only_short) {
                if (eof != 0xEEF) {
                    header_ok=false;
                    error_flag[10]=1;		// Last frame-3 missing EEF marker
                    fprintf(stdout,"ERRs: Expected EEF at vf_data[%i], found %3.3X\n",last_frame-3,eof);
                } 
            }
            else {
                if (eof != 0xE0F) {
                    header_ok=false;
                    error_flag[11]=1;		// Last frame-3 missing E0F marker
                    fprintf(stdout,"ERRs: Expected EOF at vf_data[%i], found %3.3X\n",last_frame-3,eof);
                }
            }

            // Last 4 frames must set bit 11 ==1, its implied in EEF/EOF markers in last_frame-3
            if ((lctype0 != 1) || (lctype1 != 1) || (lctype2 != 1) || (lctype3 != 1)) {
                header_ok=false;
                error_flag[12]=1;		// Last 4 frames missing bit[11]=1
                fprintf(stdout,"ERRs: Expected bit11=1 in last 4 frames, found %i%i%i%i\n",lctype0,lctype1,lctype2,lctype3);
            }

            //------------------------------------------------------------------------------
            // Unpack event format codes from first 8 frames
            //------------------------------------------------------------------------------
            // CLCT fifo mode
            sfifo_mode           = "Undefined////          ";
            switch (fifo_mode) {
                case 0x0: sfifo_mode = "Dump=No    Header=Full "; break;
                case 0x1: sfifo_mode = "Dump=Full  Header=Full "; break;
                case 0x2: sfifo_mode = "Dump=Local Header=Full "; break;
                case 0x3: sfifo_mode = "Dump=No    Header=Short"; break;
                case 0x4: sfifo_mode = "Dump=No    Header=No   "; break;
                case 0x5: sfifo_mode = "Undefined////          "; break;
                case 0x6: sfifo_mode = "Undefined////          "; break;
                case 0x7: sfifo_mode = "Undefined////          "; break;
            }

            // Raw hits dump mode
            sreadout_type           = "Undefined////          ";
            switch (readout_type) {
                case 0x0: sreadout_type = "Dump=No    Header=Full "; break;
                case 0x1: sreadout_type = "Dump=Full  Header=Full "; break;
                case 0x2: sreadout_type = "Dump=Local Header=Full "; break;
                case 0x3: sreadout_type = "Dump=No    Header=Short"; break;
            }

            // Raw hits buffer state per l1a_type
            sl1a_type            = "Undefined////                 ";
            switch (l1a_type) {
                case 0x0: sl1a_type  = "Buffer=yes CLCT trig+L1A match"; break;
                case 0x1: sl1a_type  = "Buffer=no  ALCT trig          "; break;
                case 0x2: sl1a_type  = "Buffer=no  L1A  only          "; break;
                case 0x3: sl1a_type  = "Buffer=yes TMB  trig  no L1A  "; break;
            }

            // Firmware revcode
            id_rev			= revcode;
            id_rev_day		= (id_rev >>  0) & 0x001F;
            id_rev_month	= (id_rev >>  5) & 0x000F;
            id_rev_year		= (id_rev >>  9) & 0x000F;
            id_rev_fpga		= (id_rev >> 13) & 0x0007;
            id_rev_fpga		= id_rev_fpga+2;

            // TMB board hardware status summary
            for (i=0; i<=14; ++i) {
                bd_status_vec[i]=(bd_status >> i) & 0x1;
            }

            // CSC type
            scsc_type_inferred = "Indeterminate";
            csc_type_code      = 'X';

            if(header_only_short) {
                fprintf(stdout,"Header inferred CSC Type=%c %s\n",csc_type_code,scsc_type_inferred.c_str());
                goto check_types;
            }

            if (stagger_csc == 1 && reverse_hs_csc  == 0	&& reverse_hs_me1a == 0	&& reverse_hs_me1b == 0) {
                csc_type_code='A'; 
                scsc_type_inferred = "Normal";
            }

            if (stagger_csc     == 1	&& reverse_hs_csc  == 1	&& reverse_hs_me1a == 0	&& reverse_hs_me1b == 0) {
                csc_type_code='B'; 
                scsc_type_inferred = "Normal_Reverse";
            }

            if (stagger_csc     == 0	&& reverse_hs_csc  == 0	&& reverse_hs_me1a == 1	&& reverse_hs_me1b == 0) {
                csc_type_code='C'; 
                scsc_type_inferred = "ME1A_Reverse_ME1B_Normal";
            }

            if (stagger_csc     == 0	&& reverse_hs_csc  == 0	&& reverse_hs_me1a == 0	&& reverse_hs_me1b == 1) {
                csc_type_code='D'; 
                scsc_type_inferred = "ME1A_Normal_ME1B_Reverse";
            }

            fprintf(stdout,"Header inferred CSC Type=%c %s\n",csc_type_code,scsc_type_inferred.c_str());

            //------------------------------------------------------------------------------
            // Check event type codes match actual header size
            //------------------------------------------------------------------------------
check_types:

            // Readout types
            if (header_only_short) {
                if (fifo_mode!=0x3) {
                    header_ok=false;
                    error_flag[13]=1;	// Fifo mode does not match short header format
                    fprintf(stdout,"ERRs: fifo_mode does not match short header format %i%i\n",fifo_mode,header_only_short);
                }
                if (readout_type!=0x3) {
                    header_ok=false;
                    error_flag[14]=1;	// Readout type does not match short header format
                    fprintf(stdout,"ERRs: readout_type does not match short header format %i%i\n",readout_type,header_only_short);
                }
            }

            if(header_only_long || header_full) {
                if (!((fifo_mode==0x0) || (fifo_mode==0x1) || (fifo_mode==0x2))) {
                    header_ok=false;
                    error_flag[15]=1;	// Fifo mode does not match long header format
                    fprintf(stdout,"ERRs: fifo_mode does not match long header format %i%i\n",fifo_mode,header_only_short);
                }
            }

            if(header_only_long) {
                if (readout_type!=0x0) {
                    header_ok=false;
                    error_flag[16]=1;	// Readout type does not match long header format
                    fprintf(stdout,"ERRs: readout_type does not match long header format %i%i\n",readout_type,header_only_short);
                }
            }

            if(header_full) {
                if (!((readout_type==0x1) || (readout_type==0x2))) {
                    header_ok=false;
                    error_flag[17]=1;	// Readout type does not match full header format
                    fprintf(stdout,"ERRs: readout_type does not match full header format %i%i\n",readout_type,header_only_short);
                }
            }

            if (fifo_mode!=readout_type) {
                header_ok=false;
                error_flag[18]=1;
                fprintf(stdout,"ERRs: readout type does not match FIFO mode r_type=%i fifo_mode=%i\n",readout_type,fifo_mode);
            }

            // L1A Types...in progress
            l1a_type_expect=0;

            if ((l1a_type!=l1a_type_expect) && (l1a_type_expect==0)) fprintf(stdout,"ERRs: l1a_type =%1.1i Buffer=yes CLCT trig+L1A match, expected=%1.1i\n",l1a_type,l1a_type_expect);
            if ((l1a_type!=l1a_type_expect) && (l1a_type_expect==1)) fprintf(stdout,"ERRs: l1a_type =%1.1i Buffer=no  ALCT trig,           expected=%1.1i\n",l1a_type,l1a_type_expect);
            if ((l1a_type!=l1a_type_expect) && (l1a_type_expect==2)) fprintf(stdout,"ERRs: l1a_type =%1.1i Buffer=no  L1A  only,           expected=%1.1i\n",l1a_type,l1a_type_expect);
            if ((l1a_type!=l1a_type_expect) && (l1a_type_expect==3)) fprintf(stdout,"ERRs: l1a_type =%1.1i Buffer=yes TMB  trig,           expected=%1.1i\n",l1a_type,l1a_type_expect);

            //------------------------------------------------------------------------------
            // Check word count matches expected, assumes mode 1 full readout for now
            //------------------------------------------------------------------------------
            //fifo_cfeb_enable		= 0; 
            frame_cntex_ntbins		= 0;
            frame_cntex_b0ce0c		= 0;
            frame_cntex_rpc			= 0;
            frame_cntex_b04e04		= 0;
            frame_cntex_scope		= 0;
            frame_cntex_b05e05		= 0;
            frame_cntex_miniscope	= 0;
            frame_cntex_b07e07		= 0;
            frame_cntex_bcbecb		= 0;
            frame_cntex_blockedbits	= 0;

            frame_cntex_nheaders	= r_nheaders;									// Expected Header words
            //fifo_cfeb_enable		= ((fifo_mode==1) || (fifo_mode==2)) && ((readout_type==1) || (readout_type==2));  // CLCT raw hits exist

            if(header_only_long) {
                frame_cntex_b0ce0c		= 2;											// Expected EOB, EOC markers
            }

            if(header_full) {														// Raw hits are only in full readout mode
                frame_cntex_ntbins		= 6*r_fifo_tbins*r_ncfebs;						// Expected CFEB tbins
                frame_cntex_b0ce0c		= 2;											// Expected EOB, EOC markers
                frame_cntex_rpc			= (rd_nrpcs*fifo_tbins_rpc*2)*rpc_read_enable;	// Expected RPC  tbins
                frame_cntex_b04e04		= 2*rpc_read_enable;							// Expected RPC  B04/E04 markers
                frame_cntex_scope		= ((scp_tbins+1)*64*160/16)*scope_exists;		// Expected scope data
                frame_cntex_b05e05		= 2*scope_exists;								// Expected scope B05/E05 markers
                frame_cntex_miniscope	= fifo_tbins_mini*miniscope_exists;				// Expected miniscope data
                frame_cntex_b07e07		= 2*miniscope_exists;							// Expected miniscope B07/E07 markers
                frame_cntex_blockedbits	= 20*h_bcb_read_enable;							// Expected blocked bits data
                frame_cntex_bcbecb		= 2*h_bcb_read_enable;							// Expected blocked bits BCB/ECB markers
            }

            frame_cnt_expect=									// Expected frames before trailer
                frame_cntex_nheaders
                +frame_cntex_ntbins
                +frame_cntex_b0ce0c
                +frame_cntex_rpc
                +frame_cntex_b04e04
                +frame_cntex_scope
                +frame_cntex_b05e05
                +frame_cntex_miniscope
                +frame_cntex_b07e07
                +frame_cntex_bcbecb
                +frame_cntex_blockedbits;

            frame_cntex_fill=0;									// Insert fillers if frames not multiple of 4
            if((frame_cnt_expect%4) != 0)frame_cntex_fill=2;
            if(frame_cntex_fill!=0) header_filler=true;

            frame_cntex_trailer=4;								// Add 4 trailer words

            frame_cnt_expect=
                frame_cnt_expect
                +frame_cntex_fill
                +frame_cntex_trailer;	

            frame_cnt_expect_trun=frame_cnt_expect & 0x07FF;	// Trailer word count is truncated to 11 bits
            dmb_wdcnt_trun=dmb_wdcnt & 0x07FF;

            if((frame_cnt_expect/4)*4 != frame_cnt_expect)		// Check we are still mod 4 happy
                pause ("expected frame count not mod 4..wtf?");

            (*MyOutput_) << "\nExpected header             frames =" << frame_cntex_nheaders;
            (*MyOutput_) << "\nExpected cfeb  tbins        frames =" << frame_cntex_ntbins;
            (*MyOutput_) << "\nExpected cfeb  e0b/e0c      frames =" << frame_cntex_b0ce0c;
            (*MyOutput_) << "\nExpected rpc   tbins        frames =" << frame_cntex_rpc;
            (*MyOutput_) << "\nExpected rpc   b04e04       frames =" << frame_cntex_b04e04;
            (*MyOutput_) << "\nExpected scope data         frames =" << frame_cntex_scope;
            (*MyOutput_) << "\nExpected scope b05e05       frames =" << frame_cntex_b05e05;
            (*MyOutput_) << "\nExpected miniscope data     frames =" << frame_cntex_miniscope;
            (*MyOutput_) << "\nExpected miniscope b07e07   frames =" << frame_cntex_b07e07;
            (*MyOutput_) << "\nExpected blockedbits bcbecb frames =" << frame_cntex_bcbecb;
            (*MyOutput_) << "\nExpected blockedbits data   frames =" << frame_cntex_blockedbits;
            (*MyOutput_) << "\nExpected filler             frames =" << frame_cntex_fill;
            (*MyOutput_) << "\nExpected trailer            frames =" << frame_cntex_trailer;

            (*MyOutput_) << "\nExpected frame count from header   =" << frame_cnt_expect;
            (*MyOutput_) << "\nFrame count stored in trailer      =" << frame_cnt;
            (*MyOutput_) << "\nFrame count from DMB RAM           =" << dmb_wdcnt;

            if((dmb_wdcnt_trun==frame_cnt)&&(frame_cnt==frame_cnt_expect_trun))
                (*MyOutput_) << "\nFrame count OK, frame_cnt=" << frame_cnt << std::endl;
            else {
                header_ok=false;
                error_flag[19]=1;	// Expected frame count does not match actual frame count
                (*MyOutput_) << "\ERRs: Bad frame count: read=" << frame_cnt << " expect=" << frame_cnt_expect_trun << std::endl;
            }

            //------------------------------------------------------------------------------
            // Construct CLCT, RPC, and Scope pointers
            // Do not just scan for the markers, because they are not unique
            //------------------------------------------------------------------------------
            adr_b0c =  0;				// All formats start with b0c
            adr_e0b = -1;				// Short or long header-only events do not have these markers
            adr_b04 = -1;
            adr_e04 = -1;
            adr_b05 = -1;
            adr_e05 = -1;
            adr_b07 = -1;
            adr_e07 = -1;
            adr_bcb = -1;
            adr_ecb = -1;
            adr_e0c = -1;
            adr_fil = -1;
            adr_e0f = dmb_wdcnt-4;		// All formats have e0f or eef near the end

            if (!header_only_short)		// short header has no e0b
                adr_e0b = r_nheaders;
            if (!(header_only_short || header_only_long))	{	// cfeb readouts have these markers
                adr_b04 = (rpc_read_enable  ==1) ? (adr_e0b+frame_cntex_ntbins+1) : -1;
                adr_e04 = (rpc_read_enable  ==1) ? (adr_b04+frame_cntex_rpc+1  )  : -1;
                adr_b05 = (scope_exists     ==1) ? (adr_e0b+frame_cntex_ntbins+frame_cntex_rpc+frame_cntex_b04e04+1) : -1;
                adr_e05 = (scope_exists     ==1) ? (adr_b05+frame_cntex_scope+1)  : -1;
                adr_b07 = (miniscope_exists ==1) ? (adr_e0b+frame_cntex_ntbins+frame_cntex_rpc+frame_cntex_b04e04+frame_cntex_scope+1) : -1;
                adr_e07 = (miniscope_exists ==1) ? (adr_b07+frame_cntex_miniscope+1)   : -1;
                adr_bcb = (h_bcb_read_enable==1) ? (adr_e0b+frame_cntex_ntbins+frame_cntex_rpc+frame_cntex_b04e04+frame_cntex_scope+frame_cntex_b05e05+frame_cntex_miniscope+frame_cntex_b07e07+1) : -1;
                adr_ecb = (h_bcb_read_enable==1) ? (adr_bcb+frame_cntex_blockedbits+1) : -1;
            }
            if (!header_only_short)		// Short header does not have eoc
                adr_e0c = adr_e0b+frame_cntex_ntbins
                    +frame_cntex_rpc+frame_cntex_b04e04
                    +frame_cntex_scope+frame_cntex_b05e05
                    +frame_cntex_miniscope+frame_cntex_b07e07
                    +frame_cntex_blockedbits+frame_cntex_bcbecb+1;

            adr_fil =(frame_cntex_fill !=0) ? (frame_cnt_expect-6) : -1;


            //------------------------------------------------------------------------------
            // Check that markers and filler frames exist at the predicted locations
            //------------------------------------------------------------------------------
            fprintf(stdout,"adr_b0c=%5i",adr_b0c); if(adr_b0c!=-1)fprintf(stdout," data=%4.4X",vf_data[adr_b0c]); fprintf(stdout,"\n");
            fprintf(stdout,"adr_e0b=%5i",adr_e0b); if(adr_e0b!=-1)fprintf(stdout," data=%4.4X",vf_data[adr_e0b]); fprintf(stdout,"\n");
            fprintf(stdout,"adr_b04=%5i",adr_b04); if(adr_b04!=-1)fprintf(stdout," data=%4.4X",vf_data[adr_b04]); fprintf(stdout,"\n");
            fprintf(stdout,"adr_e04=%5i",adr_e04); if(adr_e04!=-1)fprintf(stdout," data=%4.4X",vf_data[adr_e04]); fprintf(stdout,"\n");
            fprintf(stdout,"adr_b05=%5i",adr_b05); if(adr_b05!=-1)fprintf(stdout," data=%4.4X",vf_data[adr_b05]); fprintf(stdout,"\n");
            fprintf(stdout,"adr_e05=%5i",adr_e05); if(adr_e05!=-1)fprintf(stdout," data=%4.4X",vf_data[adr_e05]); fprintf(stdout,"\n");
            fprintf(stdout,"adr_b07=%5i",adr_b07); if(adr_b07!=-1)fprintf(stdout," data=%4.4X",vf_data[adr_b07]); fprintf(stdout,"\n");
            fprintf(stdout,"adr_e07=%5i",adr_e07); if(adr_e07!=-1)fprintf(stdout," data=%4.4X",vf_data[adr_e07]); fprintf(stdout,"\n");
            fprintf(stdout,"adr_bcb=%5i",adr_bcb); if(adr_bcb!=-1)fprintf(stdout," data=%4.4X",vf_data[adr_bcb]); fprintf(stdout,"\n");
            fprintf(stdout,"adr_ecb=%5i",adr_ecb); if(adr_ecb!=-1)fprintf(stdout," data=%4.4X",vf_data[adr_ecb]); fprintf(stdout,"\n");
            fprintf(stdout,"adr_e0c=%5i",adr_e0c); if(adr_e0c!=-1)fprintf(stdout," data=%4.4X",vf_data[adr_e0c]); fprintf(stdout,"\n");
            fprintf(stdout,"adr_fil=%5i",adr_fil); if(adr_fil!=-1)fprintf(stdout," data=%4.4X",vf_data[adr_fil]); fprintf(stdout,"\n");
            fprintf(stdout,"adr_e0f=%5i",adr_e0f); if(adr_e0f!=-1)fprintf(stdout," data=%4.4X",vf_data[adr_e0f]); fprintf(stdout,"\n");

            // Check E0B Header
            if ((adr_e0b>0) && ((vf_data[adr_e0b]&0xFFFF)!=0x6E0B)) {
                header_ok=false;
                error_flag[20]=1;	// E0B marker not found at expected address
                fprintf(stdout,"\n");
            }

            // Check B04 | E04 RPC
            if ((adr_b04>0) && ((vf_data[adr_b04]&0xFFFF)!=0x6B04)) {
                header_ok=false;
                error_flag[21]=1;    // B04 marker not found at expected address
                fprintf(stdout,"ERRs: B04 marker not found at expected address\n");
            }

            if ((adr_e04>0) && ((vf_data[adr_e04]&0xFFFF)!=0x6E04)) {
                header_ok=false;
                error_flag[22]=1;	 // E04 marker not found at expected address
                fprintf(stdout,"ERRs: E04 marker not found at expected address\n");
            }

            // Check B05 | E05 Scope
            if ((adr_b05>0) && ((vf_data[adr_b05]&0xFFFF)!=0x6B05)) {
                header_ok=false;
                error_flag[23]=1;	 // B05 marker not found at expected address
                fprintf(stdout,"ERRs: B05 marker not found at expected address\n");
            }

            if ((adr_e05>0) && ((vf_data[adr_e05]&0xFFFF)!=0x6E05)) {
                header_ok=false;
                error_flag[24]=1;	 // E05 marker not found at expected address
                fprintf(stdout,"ERRs: E05 marker not found at expected address\n");
            }

            // Check B07 | E07 Miniscope
            if ((adr_b07>0) && ((vf_data[adr_b07]&0xFFFF)!=0x6B07)) {
                header_ok=false;
                error_flag[23]=1;	 // B07 marker not found at expected address
                fprintf(stdout,"ERRs: B07 marker not found at expected address\n");
            }

            if ((adr_e07>0) && ((vf_data[adr_e07]&0xFFFF)!=0x6E07)) {
                header_ok=false;
                error_flag[24]=1;	 // E07 marker not found at expected address
                fprintf(stdout,"ERRs: E07 marker not found at expected address\n");
            }

            // Check BCB | ECB Blocked bits
            if ((adr_bcb>0) && ((vf_data[adr_bcb]&0xFFFF)!=0x6BCB)) {
                header_ok=false;
                error_flag[23]=1;	 // BCB marker not found at expected address
                fprintf(stdout,"ERRs: BCB marker not found at expected address\n");
            }

            if ((adr_ecb>0) && ((vf_data[adr_ecb]&0xFFFF)!=0x6ECB)) {
                header_ok=false;
                error_flag[24]=1;	 // ECB marker not found at expected address
                fprintf(stdout,"ERRs: ECB marker not found at expected address\n");
            }

            // Check E0C
            if ((adr_e0c>0) && ((vf_data[adr_e0c]&0xFFFF)!=0x6E0C)) {
                header_ok=false;
                error_flag[25]=1;	// E0C marker not found at expected address
                fprintf(stdout,"ERRs: E0C marker not found at expected address\n");
            }

            // Check filler 02AAA 05555
            if ((adr_fil>0) && ((vf_data[adr_fil]&0xFFFF)!=0x2AAA)) {
                header_ok=false;
                error_flag[26]=1;	// 2AAA filler not found at expected address
                fprintf(stdout,"ERRs: Filler frame 0x2AAA not found at expected address\n");
            }

            if ((adr_fil>0) && ((vf_data[adr_fil+1]&0xFFFF)!=0x5555)) {
                header_ok=false;
                error_flag[27]=1;	// 5555 filler not found at expected address
                fprintf(stdout,"ERRs: Filler frame 0x5555 not found at expected address\n");
            }

            //------------------------------------------------------------------------------
            // Check TMB hardware status
            //------------------------------------------------------------------------------
            bd_status_expect[0]=1;		// bd_status_ok
            bd_status_expect[1]=1;		// vstat_5p0vs
            bd_status_expect[2]=1;		// vstat_3p3v
            bd_status_expect[3]=1;		// vstat_1p8v
            bd_status_expect[4]=1;		// vstat_1p5v
            bd_status_expect[5]=1;		// _t_crit
            bd_status_expect[6]=1;		// vsm_ok
            bd_status_expect[7]=0;		// vsm_aborted
            bd_status_expect[8]=1;		// vsm_cksum_ok
            bd_status_expect[9]=1;		// vsm_wdcnt_ok
            bd_status_expect[10]=1;		// jsm_ok
            bd_status_expect[11]=0;		// jsm_aborted
            bd_status_expect[12]=1;		// jsm_cksum_ok
            bd_status_expect[13]=1;		// jsm_wdcnt_ok
            bd_status_expect[14]=1;		// sm_tck_fpga_ok

            for (i=0; i<MXSTAT; ++i) {
                if(bd_status_vec[i]!=bd_status_expect[i]) {
                    header_ok=false;
                    error_flag[28]=1;
                    fprintf(stdout,"ERRs: Bad board status %s=%i expected=%i\n",bd_status_msg[i].c_str(),bd_status_vec[i],bd_status_expect[i]);
                }
            }

            if (header_only_short) goto check_l1a;

            //------------------------------------------------------------------------------
            // Check buffer status, requires long header
            //------------------------------------------------------------------------------
            /*
            // Buffer Status
            iframe=37;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_wr_buf_adr       = %4.3X\n",	r_wr_buf_adr);
            fprintf(stdout,"r_wr_buf_ready     = %4.1X\n",	r_wr_buf_ready);
            fprintf(stdout,"wr_buf_ready       = %4.1X\n",	wr_buf_ready);
            fprintf(stdout,"buf_q_full         = %4.1X\n",	buf_q_full);
            fprintf(stdout,"buf_q_empty        = %4.1X\n",	buf_q_empty);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=38;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_buf_fence_dist   = %4.3X%5i\n",	r_buf_fence_dist,r_buf_fence_dist);
            fprintf(stdout,"buf_q_ovf_err      = %4.1X\n",	buf_q_ovf_err);
            fprintf(stdout,"buf_q_udf_err      = %4.1X\n",	buf_q_udf_err);
            fprintf(stdout,"buf_q_adr_err      = %4.1X\n",	buf_q_adr_err);
            fprintf(stdout,"buf_stalled_once   = %4.1X\n",	buf_stalled_once);

*/
            //------------------------------------------------------------------------------
            // Unpack Long header event counters
            //------------------------------------------------------------------------------
            // Long header counters
            pretrig_counter = r_pretrig_counter_lsb | (r_pretrig_counter_msb << 15);
            clct_counter    = r_clct_counter_lsb    | (r_clct_counter_msb    << 15);
            trig_counter    = r_trig_counter_lsb    | (r_trig_counter_msb    << 15);
            alct_counter    = r_alct_counter_lsb    | (r_alct_counter_msb    << 15);
            uptime_counter  = r_orbit_counter_lsb   | (r_orbit_counter_msb   << 15);

            uptime_sec=int(float(lhc_cycle)*float(uptime_counter)*25.0e-09);

            //------------------------------------------------------------------------------
            // Decode LCTs
            //------------------------------------------------------------------------------
            // Decode CLCT0 Word
            clct0=r_clct0_tmb_lsb | (r_clct0_tmb_msb << 15);			//Reassemble to full 16 bits

            clct0_vpf=	(clct0 >>  0) & 0x1;	// Valid pattern flag
            clct0_nhit=	(clct0 >>  1) & 0x7;	// Hits on pattern 0-6
            clct0_pat=	(clct0 >>  4) & 0xF;	// Pattern shape 0-A
            clct0_key=	(clct0 >>  8) & 0x1F;	// 1/2-strip ID number
            clct0_cfeb=	(clct0 >> 13) & 0x7;

            clct0_fullkey=clct0_key+32*clct0_cfeb;

            // Decode CLCT1 Word
            clct1=r_clct1_tmb_lsb | (r_clct1_tmb_msb << 15);			//Reassemble to full 16 bits

            clct1_vpf=	(clct1 >>  0) & 0x1;	// Valid pattern flag
            clct1_nhit=	(clct1 >>  1) & 0x7;	// Hits on pattern
            clct1_pat=	(clct1 >>  4) & 0xF;	// Pattern shape 0-A
            clct1_key=	(clct1 >>  8) & 0x1F;	// 1/2-strip ID number
            clct1_cfeb=	(clct1 >> 13) & 0x7;

            clct1_fullkey=clct1_key+32*clct1_cfeb;

            // Decode CLCT common data
            clctc=r_clctc_tmb;
            clctc_bxn=	(clctc >> 0) & 0x3;
            clctc_sync=	(clctc >> 2) & 0x1;		// Sync error

            // Decode MPC Frames
            mpc0_frame0 = r_mpc0_frame0_lsb | (r_mpc0_frame0_msb << 15);	//Reassemble to full 16 bits
            mpc0_frame1 = r_mpc0_frame1_lsb | (r_mpc0_frame1_msb << 15);
            mpc1_frame0 = r_mpc1_frame0_lsb | (r_mpc1_frame0_msb << 15);
            mpc1_frame1 = r_mpc1_frame1_lsb | (r_mpc1_frame1_msb << 15);

            mpc_alct0_key		=	(mpc0_frame0 >>  0) & 0x007F;
            mpc_clct0_pat		=	(mpc0_frame0 >>  7) & 0x000F;
            mpc_lct0_quality	=	(mpc0_frame0 >> 11) & 0x000F;
            mpc_lct0_vpf		=	(mpc0_frame0 >> 15) & 0x0001;

            mpc_clct0_key		=	(mpc0_frame1 >>  0) & 0x00FF;
            mpc_clct0_bend		=	(mpc0_frame1 >>  8) & 0x0001;
            mpc_sync_err0		=	(mpc0_frame1 >>  9) & 0x0001;
            mpc_alct0_bxn		=	(mpc0_frame1 >> 10) & 0x0001;
            mpc_bx0_clct		=	(mpc0_frame1 >> 11) & 0x0001;
            mpc_csc_id0			=	(mpc0_frame1 >> 12) & 0x000F;

            mpc_alct1_key		=	(mpc1_frame0 >>  0) & 0x007F;
            mpc_clct1_pat		=	(mpc1_frame0 >>  7) & 0x000F;
            mpc_lct1_quality	=	(mpc1_frame0 >> 11) & 0x000F;
            mpc_lct1_vpf		=	(mpc1_frame0 >> 15) & 0x0001;

            mpc_clct1_key		=	(mpc1_frame1 >>  0) & 0x00FF;
            mpc_clct1_bend		=	(mpc1_frame1 >>  8) & 0x0001;
            mpc_sync_err1		=	(mpc1_frame1 >>  9) & 0x0001;
            mpc_alct1_bxn		=	(mpc1_frame1 >> 10) & 0x0001;
            mpc_bx0_alct		=	(mpc1_frame1 >> 11) & 0x0001;
            mpc_csc_id1			=	(mpc1_frame1 >> 12) & 0x000F;

            //------------------------------------------------------------------------------
            // Check if TMB duplicated the ALCT or CLCT correctly
            //------------------------------------------------------------------------------
            if(!err_check) goto unpack_cfebs;

            // Count clcts and alcts in header, determine expected duplication behavior
            hdr_one_clct  = clct0_vpf & !clct1_vpf;
            hdr_two_clct  = clct0_vpf &  clct1_vpf;

            hdr_one_alct  = r_alct0_valid & !r_alct1_valid;
            hdr_two_alct  = r_alct0_valid &  r_alct1_valid;

            hdr_dupe_clct = hdr_one_clct & hdr_two_alct;
            hdr_dupe_alct = hdr_one_alct & hdr_two_clct;

            // Check header duplication flags are as expected
            if (hdr_one_clct  != expect_one_clct ) fprintf(stdout,"\tERRs: hdr_one_clct =%1i does not match expect_one_clct =%1i\n",hdr_one_clct, expect_one_clct);
            if (hdr_two_clct  != expect_two_clct ) fprintf(stdout,"\tERRs: hdr_two_clct =%1i does not match expect_two_clct =%1i\n",hdr_two_clct, expect_two_clct);
            if (hdr_one_alct  != expect_one_alct ) fprintf(stdout,"\tERRs: hdr_one_alct =%1i does not match expect_one_alct =%1i\n",hdr_one_alct, expect_one_alct);
            if (hdr_two_alct  != expect_two_alct ) fprintf(stdout,"\tERRs: hdr_two_alct =%1i does not match expect_two_alct =%1i\n",hdr_two_alct, expect_two_alct);
            if (hdr_dupe_clct != expect_dupe_clct) fprintf(stdout,"\tERRs: hdr_dupe_clct=%1i does not match expect_dupe_clct=%1i\n",hdr_dupe_clct,expect_dupe_clct);
            if (hdr_dupe_alct != expect_dupe_alct) fprintf(stdout,"\tERRs: hdr_dupe_alct=%1i does not match expect_dupe_alct=%1i\n",hdr_dupe_alct,expect_dupe_alct);

            // Compare expected duplication to what tmb reports for this event
            if (r_one_alct_tmb  != hdr_one_alct ) fprintf(stdout,"\tERRs: r_one_alct_tmb =%1i does not match expected hdr_one_alct =%1i\n",r_one_alct_tmb, hdr_one_alct );
            if (r_one_clct_tmb  != hdr_one_clct ) fprintf(stdout,"\tERRs: r_one_clct_tmb =%1i does not match expected hdr_one_clct =%1i\n",r_one_clct_tmb, hdr_one_clct );
            if (r_two_alct_tmb  != hdr_two_alct ) fprintf(stdout,"\tERRs: r_two_alct_tmb =%1i does not match expected hdr_two_alct =%1i\n",r_two_alct_tmb, hdr_two_alct );
            if (r_two_clct_tmb  != hdr_two_clct ) fprintf(stdout,"\tERRs: r_two_clct_tmb =%1i does not match expected hdr_two_clct =%1i\n",r_two_clct_tmb, hdr_two_clct );
            if (r_dupe_alct_tmb != hdr_dupe_alct) fprintf(stdout,"\tERRs: r_dupe_alct_tmb=%1i does not match expected hdr_dupe_alct=%1i\n",r_dupe_alct_tmb,hdr_dupe_alct);
            if (r_dupe_clct_tmb != hdr_dupe_clct) fprintf(stdout,"\tERRs: r_dupe_clct_tmb=%1i does not match expected hdr_dupe_clct=%1i\n",r_dupe_clct_tmb,hdr_dupe_clct);

            if (r_one_alct_tmb  != hdr_one_alct ) fprintf(stdout,"ERRs: r_one_alct_tmb =%1i does not match expected hdr_one_alct =%1i\n",r_one_alct_tmb, hdr_one_alct );
            if (r_one_clct_tmb  != hdr_one_clct ) fprintf(stdout,"ERRs: r_one_clct_tmb =%1i does not match expected hdr_one_clct =%1i\n",r_one_clct_tmb, hdr_one_clct );
            if (r_two_alct_tmb  != hdr_two_alct ) fprintf(stdout,"ERRs: r_two_alct_tmb =%1i does not match expected hdr_two_alct =%1i\n",r_two_alct_tmb, hdr_two_alct );
            if (r_two_clct_tmb  != hdr_two_clct ) fprintf(stdout,"ERRs: r_two_clct_tmb =%1i does not match expected hdr_two_clct =%1i\n",r_two_clct_tmb, hdr_two_clct );
            if (r_dupe_alct_tmb != hdr_dupe_alct) fprintf(stdout,"ERRs: r_dupe_alct_tmb=%1i does not match expected hdr_dupe_alct=%1i\n",r_dupe_alct_tmb,hdr_dupe_alct);
            if (r_dupe_clct_tmb != hdr_dupe_clct) fprintf(stdout,"ERRs: r_dupe_clct_tmb=%1i does not match expected hdr_dupe_clct=%1i\n",r_dupe_clct_tmb,hdr_dupe_clct);

            //------------------------------------------------------------------------------
            // Check trigger type flags in header
            //------------------------------------------------------------------------------
            if (r_tmb_match    ==1 && tmb_allow_match   !=1) ck("Trigger flag: r_tmb_match     : tmb_allow_match   ",r_tmb_match,     tmb_allow_match   );
            if (r_tmb_alct_only==1 && tmb_allow_alct    !=1) ck("Trigger flag: r_tmb_alct_only : tmb_allow_alct    ",r_tmb_alct_only, tmb_allow_alct    );
            if (r_tmb_clct_only==1 && tmb_allow_clct    !=1) ck("Trigger flag: r_tmb_clct_only : tmb_allow_clct    ",r_tmb_clct_only, tmb_allow_clct    );

            if (tmb_alct_ro    ==1 && tmb_allow_alct_ro !=1) ck("Trigger flag: tmb_alct_ro     : tmb_allow_alct_ro ",tmb_alct_ro,     tmb_allow_alct_ro );
            if (tmb_clct_ro    ==1 && tmb_allow_clct_ro !=1) ck("Trigger flag: tmb_clct_ro     : tmb_allow_clct_ro ",tmb_clct_ro,     tmb_allow_clct_ro );
            if (tmb_match_ro   ==1 && tmb_allow_match_ro!=1) ck("Trigger flag: tmb_match_ro    : tmb_allow_match_ro",tmb_match_ro,    tmb_allow_match_ro);

            if (tmb_trig_keep  ==1 && tmb_nontrig_keep  !=0) ck("Trigger flag: tmb_trig_keep   : tmb_nontrig_keep  ",tmb_trig_keep,   tmb_nontrig_keep  );
            if (tmb_trig_keep  ==0 && tmb_nontrig_keep  !=1) ck("Trigger flag: tmb_trig_keep   : tmb_nontrig_keep  ",tmb_trig_keep,   tmb_nontrig_keep  );

            if (tmb_alct_ro    ==1 && tmb_nontrig_keep  !=1) ck("Trigger flag: tmb_alct_ro     : tmb_nontrig_keep  ",tmb_alct_ro,     tmb_nontrig_keep  );
            if (tmb_clct_ro    ==1 && tmb_nontrig_keep  !=1) ck("Trigger flag: tmb_clct_ro     : tmb_nontrig_keep  ",tmb_clct_ro,     tmb_nontrig_keep  );
            if (tmb_match_ro   ==1 && tmb_nontrig_keep  !=1) ck("Trigger flag: tmb_match_ro    : tmb_nontrig_keep  ",tmb_match_ro,    tmb_nontrig_keep  );

            //------------------------------------------------------------------------------
            // Check if header LCT matches CLCT and ALCT from header
            //------------------------------------------------------------------------------
            non_trig_event    = (tmb_nontrig_keep==1);
            non_trig_override = (mpc_me1a_block  ==0);

            if (non_trig_event) fprintf(stdout,"Info: This is a non-triggering-event readout tmb_alct_ro=%1i tmb_clct_ro=%1i tmb_match_ro=%1i\n",tmb_alct_ro,tmb_clct_ro,tmb_match_ro);

            // Type A: Normal CSC
            if (csc_type_code=='A')
            {
                mpc_clct0_key_expect = clct0_fullkey;
                mpc_clct0_pat_expect = clct0_pat;
                mpc_alct0_key_expect = r_alct0_key;

                mpc_clct1_key_expect = (r_dupe_clct_tmb) ? clct0_fullkey : clct1_fullkey;
                mpc_clct1_pat_expect = (r_dupe_clct_tmb) ? clct0_pat     : clct1_pat;
                mpc_alct1_key_expect = (r_dupe_alct_tmb) ? r_alct0_key   : r_alct1_key;
            }

            // Type B: Reversed CSC
            else if (csc_type_code=='B')
            {
                mpc_clct0_key_expect = clct0_fullkey;
                mpc_clct0_pat_expect = clct0_pat;
                mpc_alct0_key_expect = r_alct0_key;

                mpc_clct1_key_expect = (r_dupe_clct_tmb) ? clct0_fullkey : clct1_fullkey;
                mpc_clct1_pat_expect = (r_dupe_clct_tmb) ? clct0_pat     : clct1_pat;
                mpc_alct1_key_expect = (r_dupe_alct_tmb) ? r_alct0_key   : r_alct1_key;
            }

            // Type C: ME1B strips not reversed on CFEBs 0-3, ME1A on CFEB4 reverses strip numbers
            else if (csc_type_code=='C')
            {
                mpc_clct0_key_expect = ((non_trig_event || clct0_fullkey>=128) && !non_trig_override) ? 0: clct0_fullkey;
                mpc_clct0_pat_expect = ((non_trig_event || clct0_fullkey>=128) && !non_trig_override) ? 0: clct0_pat;
                mpc_alct0_key_expect = ((non_trig_event || clct0_fullkey>=128) && !non_trig_override) ? 0: r_alct0_key;

                mpc_clct1_key_expect = (r_dupe_clct_tmb) ? clct0_fullkey : clct1_fullkey;
                mpc_clct1_pat_expect = (r_dupe_clct_tmb) ? clct0_pat     : clct1_pat;
                mpc_alct1_key_expect = (r_dupe_alct_tmb) ? r_alct0_key   : r_alct1_key;

                mpc_clct1_key_expect = ((non_trig_event || clct1_fullkey>=128) && !non_trig_override) ? 0: mpc_clct1_key_expect;
                mpc_clct1_pat_expect = ((non_trig_event || clct1_fullkey>=128) && !non_trig_override) ? 0: mpc_clct1_pat_expect;
                mpc_alct1_key_expect = ((non_trig_event || clct1_fullkey>=128) && !non_trig_override) ? 0: mpc_alct1_key_expect;
            }

            // Type D: ME1B reverses strips on CFEBs 0-3, ME1A on CFEB4 strips not reversed
            else if (csc_type_code=='D')
            {
                mpc_clct0_key_expect = ((non_trig_event || clct0_fullkey>=128) && !non_trig_override) ? 0: clct0_fullkey;
                mpc_clct0_pat_expect = ((non_trig_event || clct0_fullkey>=128) && !non_trig_override) ? 0: clct0_pat;
                mpc_alct0_key_expect = ((non_trig_event || clct0_fullkey>=128) && !non_trig_override) ? 0: r_alct0_key;

                mpc_clct1_key_expect = (r_dupe_clct_tmb) ? clct0_fullkey : clct1_fullkey;
                mpc_clct1_pat_expect = (r_dupe_clct_tmb) ? clct0_pat     : clct1_pat;
                mpc_alct1_key_expect = (r_dupe_alct_tmb) ? r_alct0_key   : r_alct1_key;

                mpc_clct1_key_expect = ((non_trig_event || clct1_fullkey>=128) && !non_trig_override) ? 0: mpc_clct1_key_expect;
                mpc_clct1_pat_expect = ((non_trig_event || clct1_fullkey>=128) && !non_trig_override) ? 0: mpc_clct1_pat_expect;
                mpc_alct1_key_expect = ((non_trig_event || clct1_fullkey>=128) && !non_trig_override) ? 0: mpc_alct1_key_expect;
            }

            // Type unknown
            else
            {
                mpc_clct0_key_expect = 0;
                mpc_clct0_pat_expect = 0;
                mpc_alct0_key_expect = 0;

                mpc_clct1_key_expect = 0;
                mpc_clct1_pat_expect = 0;
                mpc_alct1_key_expect = 0;
            }

            // CLCT0 key
            if (mpc_clct0_key != mpc_clct0_key_expect)
            {
                header_ok=false;
                error_flag[31]=1;	// CLCT0 key does not match LCT0
                fprintf(stdout,"ERRs: CLCT0 key does not match LCT0: clct0_fullkey=%3i mpc_clct0_key=%3i expect=%3i\n",clct0_fullkey,mpc_clct0_key,mpc_clct0_key_expect);
            }

            // CLCT0 pattern ID
            if (mpc_clct0_pat != mpc_clct0_pat_expect) {
                header_ok=false;
                error_flag[32]=1;	// CLCT0 pattern ID does not match LCT0
                fprintf(stdout,"ERRs: CLCT0 pattern ID does not match LCT0: clct0_pat=%1X mpc_clct0_pat=%1X expect=%1X\n",clct0_pat,mpc_clct0_pat,mpc_clct0_pat_expect);
            }

            // ALCT0 key
            if (mpc_alct0_key != mpc_alct0_key_expect) {
                header_ok=false;
                error_flag[33]=1;	// ALCT0 key does not match LCT0
                fprintf(stdout,"ERRs: ALCT0 key does not match LCT0: r_alct0_key=%3i mpc_alct0_key=%3i expect=%3i\n",r_alct0_key,mpc_alct0_key,mpc_alct0_key_expect);
            }

            // CLCT1 key
            if (mpc_clct1_key != mpc_clct1_key_expect) {
                header_ok=false;
                error_flag[34]=1;	// CLCT1 key does not match LCT1
                fprintf(stdout,"ERRs: CLCT1 key does not match LCT1: clct1_fullkey=%3i mpc_clct1_key=%3i expect=%3i\n",clct1_fullkey,mpc_clct1_key,mpc_clct1_key_expect);
            }

            // CLCT1 pattern ID
            if (mpc_clct1_pat != mpc_clct1_pat_expect) {
                header_ok=false;
                error_flag[35]=1;	// CLCT1 pattern ID does not match LCT1
                fprintf(stdout,"ERRs: CLCT1 pattern ID does not match LCT1: clct1_pat=%1X mpc_clct1_pat=%1X expect=%1X\n",clct1_pat,mpc_clct1_pat,mpc_clct1_pat_expect);
            }

            // ALCT1 key
            if (mpc_alct1_key != mpc_alct1_key_expect) {
                header_ok=false;
                error_flag[36]=1;	// ALCT1 key does not match LCT1
                fprintf(stdout,"ERRs: ALCT1 key does not match LCT1: r_alct1_key=%3i mpc_alct1_key=%3i expect=%3i\n",r_alct1_key,mpc_alct1_key,mpc_alct1_key_expect);
            }

            //------------------------------------------------------------------------------
            // Check if LCT header data matches VME latched data
            //------------------------------------------------------------------------------
            if(err_check) {
                ck("clct0 header", clct0, clct0_vme);
                ck("clct1 header", clct1, clct1_vme);
                ck("clctc header", clctc, clctc_vme);

                // Check if lct bxn matches header bxn
                clctc_bxn_vme	 = (clctc_vme >> 0) & 0x0003;	// Bunch crossing number
                clctc_bxn_header = r_bxn_counter_ff & 0x0003;

                fprintf(stdout,"\nclctc_vme=%8X clctc_bxn_vme=%8X r_bxn_counter_ff=%8X clctc_bxn_header,=%8X pop_l1a_bxn=%8X \n",
                        clctc_vme,clctc_bxn_vme,r_bxn_counter_ff,clctc_bxn_header,pop_l1a_bxn);

                ck("clctc lctvmebxn, headerbxn", clctc_bxn_vme, clctc_bxn_header);

                // Check if MPC header matches LCTs and VME
                if ((csc_type_code=='A' || csc_type_code=='B') ||						// Full 160 key csc
                        ((csc_type_code=='C' || csc_type_code=='D') && clct0_fullkey<=127))	// ME1A/B do not create mpcs on cfeb4 ikey>=128
                {
                    ck("mpc0_frame0 header vs vme", mpc0_frame0, mpc0_frame0_vme);
                    ck("mpc0_frame1 header vs vme", mpc0_frame1, mpc0_frame1_vme);
                    ck("mpc1_frame0 header vs vme", mpc1_frame0, mpc1_frame0_vme);
                    ck("mpc1_frame1 header vs vme", mpc1_frame1, mpc1_frame1_vme);
                }

            }	// close err_check

            //------------------------------------------------------------------------------
            // Check for sequential level 1 accept event numbers, first l1a may not be 1 beco offset
            //------------------------------------------------------------------------------
check_l1a:

            fprintf(stdout,"first_event=%i\n",first_event);

            if(err_check) {
                if (first_event) {
                    l1a_rxcount_save	= pop_l1a_rx_counter;	
                    l1a_rxcount_expect	= l1a_rxcount_save;
                    if (!header_only_short) {	// short header does not have trig counter
                        trig_counter_save	= trig_counter;
                        trig_counter_expect	= trig_counter_save;
                    }
                    first_event=false;
                }

                else {
                    l1a_rxcount_expect   = (l1a_rxcount_save +1) & 0x0FFF;
                    trig_counter_expect  = (trig_counter_save+1) & 0x0FFF;
                    ck("l1a rxcount  ", pop_l1a_rx_counter, l1a_rxcount_expect );
                    if (!header_only_short) {	// short header does not have trig counter
                        ck("l1a rxtxcount", trig_counter,       trig_counter_expect);
                    }
                    l1a_rxcount_save++;
                    trig_counter_save++;
                }
            }

            //------------------------------------------------------------------------------
            // Check sync error, requires long header for clct and mpc sync check
            //------------------------------------------------------------------------------
            if (header_only_short) {
                clctc_sync    = 0;
                mpc_sync_err0 = 0;
                mpc_sync_err1 = 0;
            }

            if	((r_sync_err	!=0) || (clctc_sync	!=0) || (mpc_sync_err0	!=0) || (mpc_sync_err1	!=0)) {
                //	if (err_check && scp_playback) 			// dont flag sync errors from reference tmb beco it always has sync errors	
                if (err_check && (vme_bx0_emu_en==1)) {		    // reference tmb now emulates bx0 so sync errors are detectable
                    error_flag[29]=1;	
                    fprintf(stdout,"ERRs: Clock bx0 sync error: r_sync_err=%i clctc_sync=%i mpc_sync_err0=%i mpc_sync_err1=%i\n",
                            r_sync_err,clctc_sync,mpc_sync_err0,mpc_sync_err1);
                }
            } 

            //------------------------------------------------------------------------------
            // Check buffer parity error SEU status, requires long header
            //------------------------------------------------------------------------------
            if (!header_only_short) {
                if ((perr_cfeb_ff!=0) || (perr_rpc_ff!=0) || (perr_ff!=0)) {
                    header_ok=false;
                    error_flag[30]=1;
                    fprintf(stdout,"ERRs: RAM SEU parity error: cfeb_ram=%X rpc_ram=%X sum=%X\n",perr_cfeb_ff,perr_rpc_ff,perr_ff);
                }
            }

            if (header_only_short) goto display_header;

            //------------------------------------------------------------------------------
            // Check active_feb list is as expected
            //------------------------------------------------------------------------------
            if (((fifo_mode==1) && (r_febs_read!=0x1F)) ||				// Expect 5 cfebs
                    ((fifo_mode==2) && (r_febs_read!=r_active_feb_ff))) {	// Expect hit cfebs
                header_ok=false;
                error_flag[39]=1;
                fprintf(stdout,"ERRs: Active CFEB list sent to DMB does not match CFEBs read out aff=%2.2X read=%2.2X\n",r_active_feb_ff,r_febs_read);
            }

            // Construct expected active_feb from 1st and 2nd clcts
            active_febs_expect = 0;

            // Type A:
            if (csc_type_code=='A')
            {
                if (clct0_vpf==1)
                { 	                                                    active_febs_expect = active_febs_expect | (1 << (clct0_cfeb  ));	// cfebn was hit
                    if ((clct0_key < (adjcfeb_dist   )) && (clct0_cfeb!=0)) active_febs_expect = active_febs_expect | (1 << (clct0_cfeb-1));	// cfebn-1 was hit
                    if ((clct0_key > (31-adjcfeb_dist)) && (clct0_cfeb!=4)) active_febs_expect = active_febs_expect | (1 << (clct0_cfeb+1));	// cfebn+1 was hit
                }

                if (clct1_vpf==1)
                { 	                                                    active_febs_expect = active_febs_expect | (1 << (clct1_cfeb  ));	// cfebn was hit
                    if ((clct1_key < (adjcfeb_dist   )) && (clct1_cfeb!=0)) active_febs_expect = active_febs_expect | (1 << (clct1_cfeb-1));	// cfebn-1 was hit
                    if ((clct1_key > (31-adjcfeb_dist)) && (clct1_cfeb!=4)) active_febs_expect = active_febs_expect | (1 << (clct1_cfeb+1));	// cfebn+1 was hit
                }
            }

            // Type B:
            else if (csc_type_code=='B') {
                if (clct0_vpf==1) { 	
                    active_febs_expect = active_febs_expect | (1 << (clct0_cfeb  ));	// cfebn was hit
                    if ((clct0_key < (adjcfeb_dist   )) && (clct0_cfeb!=0)) active_febs_expect = active_febs_expect | (1 << (clct0_cfeb-1));	// cfebn-1 was hit
                    if ((clct0_key > (31-adjcfeb_dist)) && (clct0_cfeb!=4)) active_febs_expect = active_febs_expect | (1 << (clct0_cfeb+1));	// cfebn+1 was hit
                }

                if (clct1_vpf==1) { 	                                                    
                    active_febs_expect = active_febs_expect | (1 << (clct1_cfeb  ));	// cfebn was hit
                    if ((clct1_key < (adjcfeb_dist   )) && (clct1_cfeb!=0)) active_febs_expect = active_febs_expect | (1 << (clct1_cfeb-1));	// cfebn-1 was hit
                    if ((clct1_key > (31-adjcfeb_dist)) && (clct1_cfeb!=4)) active_febs_expect = active_febs_expect | (1 << (clct1_cfeb+1));	// cfebn+1 was hit
                }

                active_febs_flipped=0;
                if (((active_febs_expect >> 0) & 0x1) == 1) active_febs_flipped = active_febs_flipped | 0x10;	// swap bit 0 with 4 
                if (((active_febs_expect >> 1) & 0x1) == 1) active_febs_flipped = active_febs_flipped | 0x8; 	// swap bit 1 with 3 
                if (((active_febs_expect >> 2) & 0x1) == 1) active_febs_flipped = active_febs_flipped | 0x4; 	// swap bit 2 with 2 
                if (((active_febs_expect >> 3) & 0x1) == 1) active_febs_flipped = active_febs_flipped | 0x2; 	// swap bit 3 with 1 
                if (((active_febs_expect >> 4) & 0x1) == 1) active_febs_flipped = active_febs_flipped | 0x1; 	// swap bit 4 with 0 
                active_febs_expect=active_febs_flipped;
            }

            // Type C:
            else if (csc_type_code=='C') {
                if (clct0_vpf==1) { 	                    
                    active_febs_expect = active_febs_expect | (1 << (clct0_cfeb  ));	// cfebn was hit
                    if (clct0_key < adjcfeb_dist    && clct0_cfeb!=0 && clct0_cfeb!=4) active_febs_expect = active_febs_expect | (1 << (clct0_cfeb-1));	// cfebn-1 was hit
                    if (clct0_key > 31-adjcfeb_dist && clct0_cfeb<=2 && clct0_cfeb!=4) active_febs_expect = active_febs_expect | (1 << (clct0_cfeb+1));	// cfebn+1 was hit
                }
                if (clct1_vpf==1) {
                    active_febs_expect = active_febs_expect | (1 << (clct1_cfeb  ));	// cfebn was hit
                    if (clct1_key < adjcfeb_dist    && clct1_cfeb!=0 && clct1_cfeb!=4) active_febs_expect = active_febs_expect | (1 << (clct1_cfeb-1));	// cfebn-1 was hit
                    if (clct1_key > 31-adjcfeb_dist && clct1_cfeb<=2 && clct1_cfeb!=4) active_febs_expect = active_febs_expect | (1 << (clct1_cfeb+1));	// cfebn+1 was hit
                }
            }

            // Type D:
            else if (csc_type_code=='D') {
                if (clct0_vpf==1) {
                    active_febs_expect = active_febs_expect | (1 << (clct0_cfeb  ));	// cfebn was hit
                    if (clct0_key < adjcfeb_dist    && clct0_cfeb!=0 && clct0_cfeb!=4) active_febs_expect = active_febs_expect | (1 << (clct0_cfeb-1));	// cfebn-1 was hit
                    if (clct0_key > 31-adjcfeb_dist && clct0_cfeb<=2 && clct0_cfeb!=4) active_febs_expect = active_febs_expect | (1 << (clct0_cfeb+1));	// cfebn+1 was hit
                }

                if (clct1_vpf==1) {
                    active_febs_expect = active_febs_expect | (1 << (clct1_cfeb  ));	// cfebn was hit
                    if (clct1_key < adjcfeb_dist    && clct1_cfeb!=0 && clct1_cfeb!=4) active_febs_expect = active_febs_expect | (1 << (clct1_cfeb-1));	// cfebn-1 was hit
                    if (clct1_key > 31-adjcfeb_dist && clct1_cfeb<=2 && clct1_cfeb!=4) active_febs_expect = active_febs_expect | (1 << (clct1_cfeb+1));	// cfebn+1 was hit
                }

                active_febs_flipped=0;
                if (((active_febs_expect >> 0) & 0x1) == 1) active_febs_flipped = active_febs_flipped | 0x8;	// swap bit 0 with 3 
                if (((active_febs_expect >> 1) & 0x1) == 1) active_febs_flipped = active_febs_flipped | 0x4; 	// swap bit 1 with 2 
                if (((active_febs_expect >> 2) & 0x1) == 1) active_febs_flipped = active_febs_flipped | 0x2; 	// swap bit 2 with 1 
                if (((active_febs_expect >> 3) & 0x1) == 1) active_febs_flipped = active_febs_flipped | 0x1; 	// swap bit 3 with 0 
                if (((active_febs_expect >> 4) & 0x1) == 1) active_febs_flipped = active_febs_flipped | 0x10; 	// keep bit 4 unchanged 
                active_febs_expect=active_febs_flipped;
            } //close Type D

            // Type Unknown
            else {
                printf("ERRs: Unknown csc_type_code=%c\n",csc_type_code);
                pause("woe is we");
            }

            // Compare expected to indicated active febs
            if (active_febs_expect!=r_active_feb_ff) {
                fprintf(stdout,"ERRs: Active feb list err active_febs_expect=%2.2X r_active_feb_ff=%2.2X\n",active_febs_expect,r_active_feb_ff);
                fprintf(stdout  ,"ERRs: Active feb list err active_febs_expect=%2.2X r_active_feb_ff=%2.2X\n",active_febs_expect,r_active_feb_ff);
            }

            //------------------------------------------------------------------------------
            // Unpack CFEB raw hits
            //------------------------------------------------------------------------------
unpack_cfebs:
            // Check CFEBs exist in readout
            nonzero_triads  = 0;
            ncfebs_met      = 0;

            if ((!header_full) || (r_fifo_tbins<=0) || (r_ncfebs<=0) || (adr_e0b<0)) {
                fprintf(stdout,"Info: No CFEB raw hits in this event\n");
                goto cfeb_done;
            }

            // Check ncfebs is between 1 and 5
            if ((r_ncfebs<=0)||(r_ncfebs>mxcfeb)) {
                header_ok=false;
                error_flag[36]=1; // Expected number of CFEBs 0<r_ncfebs<=5
                fprintf(stdout,"ERRs: Expected number of CFEBs 0<r_ncfebs<=5 %i\n",r_ncfebs);
                goto cfeb_done;
            }

            // Check r_fifo_tbins between 0 and 32
            if (r_fifo_tbins<0 || r_fifo_tbins>32) {
                header_ok=false;
                error_flag[37]=1; // Expected number of CFEB tbins 0<=r_fifo_tbins<=32
                fprintf(stdout,"ERRs: Expected number of CFEB tbins 0<=r_fifo_tbins<=32 %i\n",r_fifo_tbins);
                goto cfeb_done;
            }

            // Clear ds hits array
            for (icfeb  = 0; icfeb  <= mxcfeb-1;       ++icfeb ) {	// Loop over all cfebs
                for (itbin  = 0; itbin  <= r_fifo_tbins-1; ++itbin ) {	// Loop over time bins
                    for (ilayer = 0; ilayer <= mxly-1;         ++ilayer) {	// Loop over layers
                        for (ids    = 0; ids    <  mxds;           ++ids   ) {	// Loop over hits per block
                            ids_abs=ids+icfeb*8;									// Absolute distrip id
                            read_pat[itbin][ilayer][ids_abs]=0xE;	
                        }}}}

            // Loop over cfebs, tbins, layers
            iframe=adr_e0b+1;										// First raw hits frame

            for (icfeb  = 0; icfeb  <= mxcfeb-1;       ++icfeb ) {	// Loop over all cfebs
                icfeb_included = (r_febs_read >> icfeb) & 0x1;			// Extract cfeb included bit
                if (icfeb_included!=1) goto next_cfeb;					// Skip omitted cfebs
                ncfebs_met++;			

                for (itbin  = 0; itbin  <= r_fifo_tbins-1; ++itbin ) {	// Loop over time bins
                    for (ilayer = 0; ilayer <= mxly-1;         ++ilayer) {	// Loop over layers

                        rdcid  = (vf_data[iframe] >> 12) & 0x7;					// CFEB ID in the dump
                        rdtbin = (vf_data[iframe] >>  8) & 0xF;					// Tbin number in the dump
                        hits8  =  vf_data[iframe]        & 0xFF;				// 8 triad block

                        itbin_expect = itbin & 0xF;								// Tbin numbers wrap at 16

                        if(rdcid != icfeb) {
                            fprintf(stdout,"ERRs: cfeb id err in dump: rdcid=%i icfeb=%i iframe=%i\n",rdcid,icfeb,iframe);
                        }

                        if(rdtbin != itbin_expect) {
                            fprintf(stdout,"ERRs: tbin id err in dump: rdtbin=%i itbin_expect=%i iframe=%i\n",rdtbin,itbin,iframe);
                        }

                        if((rdcid != icfeb) || (rdtbin != itbin_expect)) 
                            goto cfeb_done;	// If you take this goto, read_pat is not filled

                        for (ids=0; ids<mxds; ++ids) {					    // Loop over hits per block
                            hits1=(hits8 >> ids) & 0x1;						// Extract 1 hit
                            ids_abs=ids+icfeb*8;							// Absolute distrip id
                            read_pat[itbin][ilayer][ids_abs]=hits1;			// hit this distrip
                            if(hits1 != 0) nonzero_triads++;				// Count nonzero triads
                            fprintf(stdout,"iframe=%4i vf_data=%5.5X hits8=%i icfeb=%i itbin=%i ids_abs=%i hits1=%i\n",
                                    iframe,vf_data[iframe],hits8,icfeb,itbin,ids_abs,hits1);
                        }												// Close for ihit

                        iframe++;										// Next frame
                        if(iframe >= last_frame) {						// Bummer, dude
                            fprintf(stdout,"ERRs: raw hits frame over-run iframe=%i\n",iframe);
                            goto cfeb_done;
                        }
                    }												// Close for ilayer
                }												// Close for itbin
next_cfeb:
                icfeb_included=0;								// Dummy to keep compiler happy
            }												// Close for icfeb

cfeb_done:
            fprintf(stdout,"Non-zero triad bits=%i\n",nonzero_triads);

            // Check if number of cfebs is correct
            if (ncfebs_met!=r_ncfebs) {
                fprintf(stdout,"ERRs: cfebs in dump do not match included-cfeb list, met=%1i included=%1i\n",ncfebs_met,r_ncfebs);
            }

            //------------------------------------------------------------------------------
            // Unpack RPC raw hits
            //------------------------------------------------------------------------------
            // Check for RPC readout enabled
            if(rd_nrpcs==0 || adr_b04<0) {
                fprintf(stdout,"No RPC frames in this event\n");
                goto rpc_done;
            }

            // Unpack RPC data
            first_rpc_frame = adr_b04+1;
            last_rpc_frame  = first_rpc_frame + (rd_nrpcs*fifo_tbins_rpc*2);

            ipair=0;

            for (iframe=first_rpc_frame; iframe<last_rpc_frame; iframe=iframe+2) {
                rpc_data0=vf_data[iframe];
                rpc_data1=vf_data[iframe+1];

                rpc_lsbs = (rpc_data0 >>  0) & 0xFF;
                rpc_tbin = (rpc_data0 >>  8) & 0x0F;
                rpc_id0  = (rpc_data0 >> 12) & 0x07;

                rpc_msbs = (rpc_data1 >>  0) & 0xFF;
                rpc_bxn  = (rpc_data1 >>  8) & 0x07;
                rpc_flag = (rpc_data1 >> 11) & 0x01;
                rpc_id1  = (rpc_data1 >> 12) & 0x07;

                rpc_data = (rpc_msbs  <<  8) | rpc_lsbs;

                fprintf(stdout,"pair=%3i  ",ipair);
                fprintf(stdout,"frame=%5i  ",iframe); 
                fprintf(stdout,"raw=%5.5X  ",vf_data[iframe]);
                fprintf(stdout,"raw=%5.5X  ",vf_data[iframe+1]);
                fprintf(stdout,"rpc_id0=%1i  ",rpc_id0);
                fprintf(stdout,"rpc_id1=%1i  ",rpc_id1);
                fprintf(stdout,"tbin=%2i  ",rpc_tbin);
                fprintf(stdout,"bxn=%2i  ",rpc_bxn);
                fprintf(stdout,"flag=%1i  ",rpc_flag);
                fprintf(stdout,"pads=%4.4X\n",rpc_data);

                if(rpc_id0 != rpc_id1) {
                    fprintf(stdout,"rpc_id mismatch wtf?\n");
                }
                ipair++;
            }	// close for (iframe ..)

rpc_done:

            //------------------------------------------------------------------------------
            // Unpack CFEB Blocked Bits
            //------------------------------------------------------------------------------
            // Check for blocked bits readout enabled
            if (h_bcb_read_enable==1 && adr_bcb==-1) {
                fprintf(stdout,"ERRb: h_bcb_read_enable=%1i adr_bcb=%4i\n",h_bcb_read_enable,adr_bcb);
                if (adr_bcb<0) {
                    fprintf(stdout,"No CFEB blocked bit frames in this event\n");
                    goto bcb_done;
                }

                // Unpack Blocked bits data
                first_bcb_frame = adr_bcb+1;
                last_bcb_frame  = first_bcb_frame + 20;	// 5 cfebs * 8ds *6ly /12

                for (iframe=first_bcb_frame; iframe<last_bcb_frame; iframe=iframe+4) {
                    bcb_data[0] = vf_data[iframe+0];			// 4 frames per cfeb
                    bcb_data[1] = vf_data[iframe+1];
                    bcb_data[2] = vf_data[iframe+2];
                    bcb_data[3] = vf_data[iframe+3];

                    bcb_cfebid[0] = (bcb_data[0] >> 12) & 0x7;	// Extract CFEB IDs
                    bcb_cfebid[1] = (bcb_data[1] >> 12) & 0x7;
                    bcb_cfebid[2] = (bcb_data[2] >> 12) & 0x7;
                    bcb_cfebid[3] = (bcb_data[3] >> 12) & 0x7;

                    icfeb = (iframe-first_bcb_frame)/4;			// Expected cfeb id

                    for (i=0; i<=3; ++i) {
                        if (bcb_cfebid[i]!=icfeb) fprintf(stdout,"ERRb: Blocked bits format mismatch: bcb_cfebid=%i icfeb=%i\n",bcb_cfebid[i],icfeb);
                    }

                    bcb_cfeb_ly[icfeb][0] = ( bcb_data[0] >> 0) & 0xFF;
                    bcb_cfeb_ly[icfeb][1] = ((bcb_data[0] >> 8) & 0x0F) | ((bcb_data[1] & 0x0F) << 4);
                    bcb_cfeb_ly[icfeb][2] = ( bcb_data[1] >> 4) & 0xFF;
                    bcb_cfeb_ly[icfeb][3] = ( bcb_data[2] >> 0) & 0xFF;
                    bcb_cfeb_ly[icfeb][4] = ((bcb_data[2] >> 8) & 0x0F) | ((bcb_data[3] & 0x0F) << 4);
                    bcb_cfeb_ly[icfeb][5] = ( bcb_data[3] >> 4) & 0xFF;

                }	// close for (iframe..)

                // Expand cfeb blocked bits to 1 bit per word
                for (icfeb =0; icfeb  < mxcfeb; ++ icfeb ) {
                    for (ilayer=0; ilayer < mxly;   ++ ilayer) {
                        for (ids   =0; ids    < mxds;   ++ ids   ) {
                            blocked_distrips[icfeb][ilayer][ids]=(bcb_cfeb_ly[icfeb][ilayer] >> ids) & 0x1;
                        }
                    }
                }

                // Display cfeb and ids column markers
                fprintf(stdout,"\n");
                fprintf(stdout,"     Blocked DiStrip Triad Bits Table\n");

                fprintf(stdout,"Cfeb-");
                for (icfeb=0; icfeb < mxcfeb; ++icfeb) { 
                    fprintf(stdout,"|"); // display cfeb columns
                    for (ids=0;   ids   < mxds;   ++ids  )   
                        fprintf(stdout,"%1.1i",icfeb);
                }

                fprintf(stdout,"|\n");

                fprintf(stdout,"Ds---");
                for (icfeb=0; icfeb < mxcfeb; ++icfeb) { 
                    fprintf(stdout,"%s|",x);	// display ids columns
                    for (ids=0;   ids   < mxds;   ++ids  )   
                        fprintf(stdout,"%1.1i",ids%10);}
                    fprintf(stdout,"|\n");
                    fprintf(stdout,"     ----------------------------------------------\n");

                    // Display blocked distrip triads
                    for (ilayer=0; ilayer <= mxly-1;         ++ilayer) {
                        fprintf(stdout,"Ly%1i  ",ilayer);
                        for (ids_abs=0;ids_abs<=39;++ids_abs) {
                            if (ids_abs%8==0)
                                fprintf(stdout,"|");

                            ids   = ids_abs%8;
                            icfeb = ids_abs/8;
                            fprintf(stdout,"%1.1x",blocked_distrips[icfeb][ilayer][ids]);
                        }	// close for ids_abs
                        fprintf(stdout,"|\n");
                    }	// close ilayer

                    // Read Hot Channel Mask 15 registers, 2 layers each, 3 adrs per cfeb
                    bool	display_hcm=false;

                    if (display_hcm)
                    {
                        int hcm001_adr;
                        int hcm_adr;
                        int hcm_data0;
                        int hcm_data1;
                        int hot_channel_mask[5][6][8];
                        int iadr;
                        unsigned long adr;
                        long int		vme_read		(unsigned long &adr, unsigned short &rd_data);
                        unsigned short rd_data;
                        long int	status;

                        hcm001_adr=0x4A;

                        for (iadr =0; iadr<30; iadr=iadr+2) {

                            hcm_adr = hcm001_adr + iadr;
                            icfeb   = iadr/6;
                            ilayer  = iadr%6;
                            adr     = 0xD00000+hcm_adr;
                            status  = vme_read(adr,rd_data);

                            hcm_data0 = (rd_data >> 0); 
                            hcm_data1 = (rd_data >> 8); 

                            for (ids=0; ids<=7; ++ids) {
                                hot_channel_mask[icfeb][ilayer+0][ids] = (hcm_data0 >> ids) & 0x1;
                                hot_channel_mask[icfeb][ilayer+1][ids] = (hcm_data1 >> ids) & 0x1;
                            }}

                            // Display Hot Channel Mask  cfeb and ids column markers
                            fprintf(stdout,"\n");
                            fprintf(stdout,"     Hot Channel Mask\n");

                            fprintf(stdout,"Cfeb-");
                            for (icfeb=0; icfeb < mxcfeb; ++icfeb) { fprintf(stdout,"|"); // display cfeb columns
                                for (ids=0;   ids   < mxds;   ++ids  )   fprintf(stdout,"%1.1i",icfeb);}
                                fprintf(stdout,"|\n");

                                fprintf(stdout,"Ds---");
                                for (icfeb=0; icfeb < mxcfeb; ++icfeb) { fprintf(stdout,"%s|",x);	// display ids columns
                                    for (ids=0;   ids   < mxds;   ++ids  )   fprintf(stdout,"%1.1i",ids%10);}
                                    fprintf(stdout,"|\n");
                                    fprintf(stdout,"     ----------------------------------------------\n");

                                    // Display HCM masked distrip triads
                                    for (ilayer=0; ilayer <= mxly-1;         ++ilayer)        {
                                        fprintf(stdout,"Ly%1i  ",ilayer);

                                        for (ids_abs=0;ids_abs<=39;++ids_abs) {
                                            if (ids_abs%8==0) {fprintf(stdout,"|");}
                                            ids   = ids_abs%8;
                                            icfeb = ids_abs/8;
                                            fprintf(stdout,"%1.1x",hot_channel_mask[icfeb][ilayer][ids]);
                                        }	// close for ids_abs
                                        fprintf(stdout,"|\n");
                                    }	// close ilayer

                    }	// close if display_hcm
            }	// close if h_bcb_read_en

bcb_done:

            //------------------------------------------------------------------------------
            // Display Header Frames
            //------------------------------------------------------------------------------
display_header:

            // First 4 header words must conform to DDU specification
            iframe=0;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"boc                = %4.3X\n",	boc);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=1;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"pop_l1a_bxn        = %4.4X\n",	pop_l1a_bxn);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=2;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"pop_l1a_rx_counter = %4.4X\n",	pop_l1a_rx_counter);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=3;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"readout_counter    = %4.4X\n",	readout_counter);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            // Next 4 words for short header mode
            iframe=4;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"board_id           = %4i\n",		board_id);
            fprintf(stdout,"csc_id             = %4i\n",		csc_id);
            fprintf(stdout,"run_id             = %4i\n",		run_id);
            fprintf(stdout,"h4_buf_q_ovf_err   = %4.1X\n",	h4_buf_q_ovf_err);
            fprintf(stdout,"r_sync_err         = %4.1X\n",	r_sync_err);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=5;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_nheaders         = %4i\n",		r_nheaders);
            fprintf(stdout,"fifo_mode          = %4i  %s\n",	fifo_mode,sfifo_mode.c_str());
            fprintf(stdout,"readout_type       = %4i  %s\n",	readout_type,sreadout_type.c_str());
            fprintf(stdout,"l1a_type           = %4i  %s\n",	l1a_type,sl1a_type.c_str());
            fprintf(stdout,"r_has_buf          = %4i\n",		r_has_buf);
            fprintf(stdout,"r_buf_stalled      = %4i\n",		r_buf_stalled);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=6;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"bd_status_ok       = %4.1i\n",	bd_status_vec[0]);
            fprintf(stdout,"vstat_5p0vs        = %4.1i\n",	bd_status_vec[1]);
            fprintf(stdout,"vstat_3p3v         = %4.1i\n",	bd_status_vec[2]);
            fprintf(stdout,"vstat_1p8v         = %4.1i\n",	bd_status_vec[3]);
            fprintf(stdout,"vstat_1p5v         = %4.1i\n",	bd_status_vec[4]);
            fprintf(stdout,"_t_crit            = %4.1i\n",	bd_status_vec[5]);
            fprintf(stdout,"vsm_ok             = %4.1i\n",	bd_status_vec[6]);
            fprintf(stdout,"vsm_aborted        = %4.1i\n",	bd_status_vec[7]);
            fprintf(stdout,"vsm_cksum_ok       = %4.1i\n",	bd_status_vec[8]);
            fprintf(stdout,"vsm_wdcnt_ok       = %4.1i\n",	bd_status_vec[9]);
            fprintf(stdout,"jsm_ok             = %4.1i\n",	bd_status_vec[10]);
            fprintf(stdout,"jsm_aborted        = %4.1i\n",	bd_status_vec[11]);
            fprintf(stdout,"jsm_cksum_ok       = %4.1i\n",	bd_status_vec[12]);
            fprintf(stdout,"jsm_wdcnt_ok       = %4.1i\n",	bd_status_vec[13]);
            fprintf(stdout,"sm_tck_fpga_ok     = %4.1i\n",	bd_status_vec[14]);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=7;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"revcode            = %4.4X  ",	revcode);
            fprintf(stdout,"Decodes as ");
            fprintf(stdout,"%2.2i/",							id_rev_month);
            fprintf(stdout,"%2.2i/",							id_rev_day);
            fprintf(stdout,"%2.2i xc2v",						id_rev_year);
            fprintf(stdout,"%1.1X000\n",						id_rev_fpga);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            if(header_only_short) goto display_trailer;

            // Full Header-mode words 8-41: Event counters
            iframe=8;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_bxn_counter_ff   = %4.3X\n",	r_bxn_counter_ff);
            fprintf(stdout,"r_tmb_clct0_discard= %4.1X\n",	r_tmb_clct0_discard);
            fprintf(stdout,"r_tmb_clct1_discard= %4.1X\n",	r_tmb_clct1_discard);
            fprintf(stdout,"clock_lock_lost    = %4.1X\n",	clock_lock_lost);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=9;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_pretrig_cnt_lsb  = %4.4X\n",	r_pretrig_counter_lsb);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=10;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_pretrig_cnt_msb  = %4.4X  ",	r_pretrig_counter_msb);
            fprintf(stdout,"Full pretrig_countr= %9i\n",		pretrig_counter);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=11;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_clct_cnt_lsb     = %4.4X\n",	r_clct_counter_lsb);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=12;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_clct_cnt_msb     = %4.4X  ",	r_clct_counter_msb);
            fprintf(stdout,"Full clct_counter  = %9i\n",		clct_counter);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=13;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_trig_cnt_lsb     = %4.4X\n",	r_trig_counter_lsb);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=14;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_trig_cnt_msb     = %4.4X  ",	r_trig_counter_msb);
            fprintf(stdout,"Full trig_counter  = %9i\n",		trig_counter);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=15;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_alct_cnt_lsb     = %4.4X\n",	r_alct_counter_lsb);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=16;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_alct_cnt_msb     = %4.4X  ",	r_alct_counter_msb);
            fprintf(stdout,"Full alct_counter  = %9i\n",		alct_counter);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=17;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_orbit_cnt_lsb    = %4.4X\n",	r_orbit_counter_lsb);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=18;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_orbit_cnt_msb    = %4.4X  ",	r_orbit_counter_msb);
            fprintf(stdout,"Full orbit_counter = %9.8X  =",	uptime_counter);
            fprintf(stdout,"%6i seconds\n",					uptime_sec);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            // CLCT Raw Hits Size
            iframe=19;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_ncfebs           = %4.1X\n",	r_ncfebs);
            fprintf(stdout,"r_fifo_tbins       = %4i\n",		r_fifo_tbins);
            fprintf(stdout,"fifo_pretrig       = %4i\n",		fifo_pretrig);
            fprintf(stdout,"scope_exists       = %4.1X\n",	scope_exists);
            fprintf(stdout,"miniscope_exists   = %4.1X\n",	miniscope_exists);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            // CLCT Configuration
            iframe=20;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"hit_thresh_pretrig = %4.1X\n",	hit_thresh_pretrig);
            fprintf(stdout,"pid_thresh_pretrig = %4.1X\n",	pid_thresh_pretrig);
            fprintf(stdout,"hit_thresh_postdrf = %4.1X\n",	hit_thresh_postdrf);
            fprintf(stdout,"pid_thresh_postdrf = %4.1X\n",	pid_thresh_postdrf);
            fprintf(stdout,"stagger_csc        = %4.1X\n",	stagger_csc);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=21;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"triad_persist      = %4.1X\n",	triad_persist);
            fprintf(stdout,"dmb_thresh         = %4.1X\n",	dmb_thresh);
            fprintf(stdout,"alct_delay         = %4.1X\n",	alct_delay);
            fprintf(stdout,"clct_window        = %4.1X\n",	clct_window);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=22;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);

            fprintf(stdout,"r_trig_source_vec  = %4.4X  ",	r_trig_source_vec);
            fprintf(stdout,"Decodes as ");
            for (i=8;i>=0;--i) fprintf(stdout,"%1i",			(r_trig_source_vec>>i)&0x1);
            fprintf(stdout,"\n");

            fprintf(stdout,"r_layers_hit       = %4.4X  ",	r_layers_hit);
            fprintf(stdout,"Decodes as ");
            for (i=5;i>=0;--i) fprintf(stdout,"%1i",			(r_layers_hit>>i)&0x1);
            fprintf(stdout,"\n");
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=23;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);

            fprintf(stdout,"r_active_feb_ff    = %4.4X  ",	r_active_feb_ff);
            fprintf(stdout,"Decodes as ");
            for (i=4;i>=0;--i) fprintf(stdout,"%1i",			(r_active_feb_ff>>i)&0x1);
            fprintf(stdout,"\n");

            fprintf(stdout,"r_febs_read        = %4.4X  ",	r_febs_read);
            fprintf(stdout,"Decodes as ");
            for (i=4;i>=0;--i) fprintf(stdout,"%1i",			(r_febs_read>>i)&0x1);
            fprintf(stdout,"\n");

            fprintf(stdout,"r_l1a_match_win    = %4.1X\n",	r_l1a_match_win);
            fprintf(stdout,"active_feb_src     = %4.1X\n",	active_feb_src);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);


            // CLCT+ALCT Match Status
            iframe=24;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_tmb_match        = %4.1X\n",	r_tmb_match);
            fprintf(stdout,"r_tmb_alct_only    = %4.1X\n",	r_tmb_alct_only);
            fprintf(stdout,"r_tmb_clct_only    = %4.1X\n",	r_tmb_clct_only);
            fprintf(stdout,"r_tmb_match_win    = %4.1X\n",	r_tmb_match_win);
            fprintf(stdout,"r_no_alct_tmb      = %4.1X\n",	r_no_alct_tmb);
            fprintf(stdout,"r_one_alct_tmb     = %4.1X\n",	r_one_alct_tmb);
            fprintf(stdout,"r_one_clct_tmb     = %4.1X\n",	r_one_clct_tmb);
            fprintf(stdout,"r_two_alct_tmb     = %4.1X\n",	r_two_alct_tmb);
            fprintf(stdout,"r_two_clct_tmb     = %4.1X\n",	r_two_clct_tmb);
            fprintf(stdout,"r_dupe_alct_tmb    = %4.1X\n",	r_dupe_alct_tmb);
            fprintf(stdout,"r_dupe_clct_tmb    = %4.1X\n",	r_dupe_clct_tmb);
            fprintf(stdout,"r_rank_err_tmb     = %4.1X\n",	r_rank_err_tmb);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            // CLCT Trigger Data
            iframe=25;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_clct0_tmb_lsb    = %4.4X\n",	r_clct0_tmb_lsb);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=26;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_clct1_tmb_lsb    = %4.4X\n",	r_clct1_tmb_lsb);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=27;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_clct0_tmb_msb    = %4.2X\n",	r_clct0_tmb_msb);
            fprintf(stdout,"r_clct1_tmb_msb    = %4.2X\n",	r_clct1_tmb_msb);
            fprintf(stdout,"r_clct0_invp       = %4.1X\n",	r_clct0_invp);
            fprintf(stdout,"r_clct1_invp       = %4.1X\n",	r_clct1_invp);
            fprintf(stdout,"r_clct1_busy       = %4.1X\n",	r_clct1_busy);
            fprintf(stdout,"perr_cfeb_ff       = %4.1X  ",	perr_cfeb_ff);
            fprintf(stdout,"Decodes as ");
            for (i=4;i>=0;--i) fprintf(stdout,"%1i",			(perr_cfeb_ff>>i)&0x1);
            fprintf(stdout,"\n");
            fprintf(stdout,"perr_rpc_ff        = %4.1X\n",	perr_rpc_ff);
            fprintf(stdout,"perr_ff            = %4.1X\n",	perr_ff);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            // ALCT Trigger Data
            iframe=28;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_alct0_valid      = %4.1X\n",	r_alct0_valid);
            fprintf(stdout,"r_alct0_quality    = %4.1X\n",	r_alct0_quality);
            fprintf(stdout,"r_alct0_amu        = %4.1X\n",	r_alct0_amu);
            fprintf(stdout,"r_alct0_key        = %4i\n",		r_alct0_key);
            fprintf(stdout,"r_alct_pretrig_win = %4.1X\n",	r_alct_pretrig_win);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=29;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_alct1_valid      = %4.1X\n",	r_alct1_valid);
            fprintf(stdout,"r_alct1_quality    = %4.1X\n",	r_alct1_quality);
            fprintf(stdout,"r_alct1_amu        = %4.1X\n",	r_alct1_amu);
            fprintf(stdout,"r_alct1_key        = %4i\n",		r_alct1_key);
            fprintf(stdout,"drift_delay        = %4i\n",		drift_delay);
            fprintf(stdout,"h_bcb_read_enable  = %4.1X\n",	h_bcb_read_enable);
            fprintf(stdout,"hs_layer_trig      = %4.1X\n",	hs_layer_trig);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=30;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_alct_bxn         = %4.2X\n",	r_alct_bxn);
            fprintf(stdout,"alct_ecc_err       = %4.1X\n",	alct_ecc_err);
            fprintf(stdout,"cfeb_badbits_found = %4.1X\n",	cfeb_badbits_found);
            fprintf(stdout,"cfeb_badbits_blockd= %4.1X\n",	cfeb_badbits_blocked);
            fprintf(stdout,"alct_cfg_done      = %4.1X\n",	alct_cfg_done);
            fprintf(stdout,"bx0_match          = %4.1X\n",	bx0_match);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            // MPC Frames
            iframe=31;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_mpc0_frame0_lsb  = %4.4X\n",	r_mpc0_frame0_lsb);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=32;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_mpc0_frame1_lsb  = %4.4X\n",	r_mpc0_frame1_lsb);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=33;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_mpc1_frame0_lsb  = %4.4X\n",	r_mpc1_frame0_lsb);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=34;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_mpc1_frame1_lsb  = %4.4X\n",	r_mpc1_frame1_lsb);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=35;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_mpc0_frame0_msb  = %4.1X\n",	r_mpc0_frame0_msb);
            fprintf(stdout,"r_mpc0_frame1_msb  = %4.1X\n",	r_mpc0_frame1_msb);
            fprintf(stdout,"r_mpc1_frame0_msb  = %4.1X\n",	r_mpc1_frame0_msb);
            fprintf(stdout,"r_mpc1_frame1_msb  = %4.1X\n",	r_mpc1_frame1_msb);
            fprintf(stdout,"mpc_tx_delay       = %4.1X\n",	mpc_tx_delay);
            fprintf(stdout,"r_mpc_accept       = %4.1X\n",	r_mpc_accept);
            fprintf(stdout,"cfeb_en            = %4.2X  ",	cfeb_en);
            fprintf(stdout,"Decodes as ");
            for (i=4;i>=0;--i) fprintf(stdout,"%1i",			(cfeb_en>>i)&0x1);
            fprintf(stdout,"\n");

            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            // RPC Configuration
            iframe=36;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);

            fprintf(stdout,"rd_rpc_list        = %4.2X  ",	rd_rpc_list);
            fprintf(stdout,"Decodes as ");
            for (i=1;i>=0;--i) fprintf(stdout,"%1i",			(rd_rpc_list>>i)&0x1);
            fprintf(stdout,"\n");

            fprintf(stdout,"rd_nrpcs           = %4.1X\n",	rd_nrpcs);
            fprintf(stdout,"rpc_read_enable    = %4.1X\n",	rpc_read_enable);
            fprintf(stdout,"fifo_tbins_rpc     = %4i\n",		fifo_tbins_rpc);
            fprintf(stdout,"fifo_pretrig_rpc   = %4i\n",		fifo_pretrig_rpc);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            // Buffer Status
            iframe=37;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_wr_buf_adr       = %4.3X\n",	r_wr_buf_adr);
            fprintf(stdout,"r_wr_buf_ready     = %4.1X\n",	r_wr_buf_ready);
            fprintf(stdout,"wr_buf_ready       = %4.1X\n",	wr_buf_ready);
            fprintf(stdout,"buf_q_full         = %4.1X\n",	buf_q_full);
            fprintf(stdout,"buf_q_empty        = %4.1X\n",	buf_q_empty);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=38;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"r_buf_fence_dist   = %4.3X%5i\n",	r_buf_fence_dist,r_buf_fence_dist);
            fprintf(stdout,"buf_q_ovf_err      = %4.1X\n",	buf_q_ovf_err);
            fprintf(stdout,"buf_q_udf_err      = %4.1X\n",	buf_q_udf_err);
            fprintf(stdout,"buf_q_adr_err      = %4.1X\n",	buf_q_adr_err);
            fprintf(stdout,"buf_stalled_once   = %4.1X\n",	buf_stalled_once);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            // Spare Frames
            iframe=39;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"buf_fence_cnt      = %4i\n",		buf_fence_cnt);
            fprintf(stdout,"reverse_hs_csc     = %4.1X\n",	reverse_hs_csc);
            fprintf(stdout,"reverse_hs_me1a    = %4.1X\n",	reverse_hs_me1a);
            fprintf(stdout,"reverse_hs_me1b    = %4.1X\n",	reverse_hs_me1b);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=40;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"buf_fence_cnt_peak = %4i\n",		buf_fence_cnt_peak);
            fprintf(stdout,"r_trig_source_vec9 = %4.1X\n",	r_trig_source_vec9);
            fprintf(stdout,"r_trig_source_vec10= %4.1X\n",	r_trig_source_vec10);
            fprintf(stdout,"tmb_trig_pulse     = %4.1X\n",	tmb_trig_pulse);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=41;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"tmb_allow_alct     = %4.1X\n",	tmb_allow_alct);
            fprintf(stdout,"tmb_allow_clct     = %4.1X\n",	tmb_allow_clct);
            fprintf(stdout,"tmb_allow_match    = %4.1X\n",	tmb_allow_match);
            fprintf(stdout,"tmb_allow_alct_ro  = %4.1X\n",	tmb_allow_alct_ro);
            fprintf(stdout,"tmb_allow_clct_ro  = %4.1X\n",	tmb_allow_clct_ro);
            fprintf(stdout,"tmb_allow_match_ro = %4.1X\n",	tmb_allow_match_ro);
            fprintf(stdout,"tmb_alct_ro        = %4.1X\n",	tmb_alct_ro);
            fprintf(stdout,"tmb_clct_ro        = %4.1X\n",	tmb_clct_ro);
            fprintf(stdout,"tmb_match_ro       = %4.1X\n",	tmb_match_ro);
            fprintf(stdout,"tmb_trig_keep      = %4.1X\n",	tmb_trig_keep);
            fprintf(stdout,"tmb_nontrig_keep   = %4.1X\n",	tmb_nontrig_keep);
            fprintf(stdout,"lyr_thresh_pretrig = %4.1X\n",	lyr_thresh_pretrig);
            fprintf(stdout,"layer_trig_en      = %4.1X\n",	layer_trig_en);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            // EOB Frame
            iframe=42;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"eob                = %4.4X\n",	eob);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            // EOC Frame
            iframe=last_frame-6;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"eoc                = %4.3X\n",	eoc);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            //------------------------------------------------------------------------------
            //	Display Filler Frames
            //------------------------------------------------------------------------------
            if(header_filler) {
                iframe=last_frame-5;
                fprintf(stdout,"\n");
                fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
                fprintf(stdout,"opt2aaa            = %4.4X\n",	opt2aaa);
                fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

                iframe=last_frame-4;
                fprintf(stdout,"\n");
                fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
                fprintf(stdout,"opt5555            = %4.4X\n",	opt5555);
                fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);
            }

            //------------------------------------------------------------------------------
            //	Display Trailer Frames
            //------------------------------------------------------------------------------
display_trailer:
            iframe=last_frame-3;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"lctype3            = %4.1X\n",	lctype3);
            fprintf(stdout,"eof                = %4.3X\n",	eof);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=last_frame-2;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"crc22lsb           = %4.3X\n",	crc22lsb);
            fprintf(stdout,"lctype2            = %4.1X\n",	lctype2);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=last_frame-1;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"crc22msb           = %4.3X\n",	crc22msb);
            fprintf(stdout,"lctype1            = %4.1X\n",	lctype1);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            iframe=last_frame;
            fprintf(stdout,"\n");
            fprintf(stdout,"Header Frame%4i%3.3s %5.5X\n",	iframe,x,vf_data[iframe]);
            fprintf(stdout,"frame_cnt          = %4i\n",		frame_cnt);
            fprintf(stdout,"lctype0            = %4.1X\n",	lctype0);
            fprintf(stdout,"ddu                = %4.1X\n",	ddu[iframe]);

            if(header_only_short) goto exit;
            //------------------------------------------------------------------------------
            //	Display decoded LCT data
            //------------------------------------------------------------------------------
            // CLCT0
            fprintf(stdout,"\n");
            fprintf(stdout,"CLCT0 Decode      %7.7X\n",		clct0);
            fprintf(stdout,"clct0_vpf          = %4i\n",		clct0_vpf);
            fprintf(stdout,"clct0_nhit         = %4i\n",		clct0_nhit);
            fprintf(stdout,"clct0_pat          = %4X\n",		clct0_pat);
            fprintf(stdout,"clct0_key          = %4i\n",		clct0_key);
            fprintf(stdout,"clct0_cfeb         = %4i\n",		clct0_cfeb);
            fprintf(stdout,"clct0_fullkey      = %4i\n",		clct0_fullkey);

            // CLCT1
            fprintf(stdout,"\n");
            fprintf(stdout,"CLCT1 Decode      %7.7X\n",		clct1);
            fprintf(stdout,"clct1_vpf          = %4i\n",		clct1_vpf);
            fprintf(stdout,"clct1_nhit         = %4i\n",		clct1_nhit);
            fprintf(stdout,"clct1_pat          = %4X\n",		clct1_pat);
            fprintf(stdout,"clct1_key          = %4i\n",		clct1_key);
            fprintf(stdout,"clct1_cfeb         = %4i\n",		clct1_cfeb);
            fprintf(stdout,"clct1_fullkey      = %4i\n",		clct1_fullkey);

            // Common
            fprintf(stdout,"\n");
            fprintf(stdout,"clctc_bxn          = %4.3X\n",	clctc_bxn);
            fprintf(stdout,"clctc_sync         = %4i\n",		clctc_sync);

            //------------------------------------------------------------------------------
            //	Display decoded MPC data
            //------------------------------------------------------------------------------
            // MPC0
            fprintf(stdout,"\n");
            fprintf(stdout,"MPC0 Decode From Header\n");
            fprintf(stdout,"mpc_alct0_key      = %4i\n",		mpc_alct0_key);
            fprintf(stdout,"mpc_clct0_pat      = %4.1X\n",	mpc_clct0_pat);
            fprintf(stdout,"mpc_lct0_quality   = %4i\n",		mpc_lct0_quality);
            fprintf(stdout,"mpc_lct0_vpf       = %4.1X\n",	mpc_lct0_vpf);

            fprintf(stdout,"mpc_clct0_key      = %4i\n",		mpc_clct0_key);
            fprintf(stdout,"mpc_clct0_bend     = %4.1X\n",	mpc_clct0_bend);
            fprintf(stdout,"mpc_sync_err0      = %4.1X\n",	mpc_sync_err0);
            fprintf(stdout,"mpc_alct0_bxn      = %4.1X\n",	mpc_alct0_bxn);
            fprintf(stdout,"mpc_bx0_clct       = %4i\n",		mpc_bx0_clct);
            fprintf(stdout,"mpc_csc_id0        = %4i\n",		mpc_csc_id0);

            // MPC1
            fprintf(stdout,"\n");
            fprintf(stdout,"MPC1 Decode From Header\n");
            fprintf(stdout,"mpc_alct1_key      = %4i\n",		mpc_alct1_key);
            fprintf(stdout,"mpc_clct1_pat      = %4.1X\n",	mpc_clct1_pat);
            fprintf(stdout,"mpc_lct1_quality   = %4i\n",		mpc_lct1_quality);
            fprintf(stdout,"mpc_lct1_vpf       = %4.1X\n",	mpc_lct1_vpf);

            fprintf(stdout,"mpc_clct1_key      = %4i\n",		mpc_clct1_key);
            fprintf(stdout,"mpc_clct1_bend     = %4.1X\n",	mpc_clct1_bend);
            fprintf(stdout,"mpc_sync_err1      = %4.1X\n",	mpc_sync_err1);
            fprintf(stdout,"mpc_alct1_bxn      = %4.1X\n",	mpc_alct1_bxn);
            fprintf(stdout,"mpc_bx0_alct       = %4i\n",		mpc_bx0_alct);
            fprintf(stdout,"mpc_csc_id1        = %4i\n",		mpc_csc_id1);

            //------------------------------------------------------------------------------
            //	Display CFEB raw hits triads
            //------------------------------------------------------------------------------
            if (header_only_short || header_only_long) {
                fprintf(stdout,"Skipping triad display for header-only event\n");
                goto check_scope;
            }

            //ntbins=r_fifo_tbins;
            ntbinspre=fifo_pretrig;

            // Display cfeb and ids column markers
            fprintf(stdout,"\n");
            fprintf(stdout,"     Raw Hits Triads\n");

            fprintf(stdout,"Cfeb-");
            for (icfeb=0; icfeb < mxcfeb; ++icfeb) { fprintf(stdout,"|"); // display cfeb columns
                for (ids=0;   ids   < mxds;   ++ids  )   fprintf(stdout,"%1.1i",icfeb);}
                fprintf(stdout,"|\n");

                fprintf(stdout,"Ds---");
                for (icfeb=0; icfeb < mxcfeb; ++icfeb) { 
                    fprintf(stdout,"%s|",x);	// display ids columns
                    for (ids=0;   ids   < mxds;   ++ids  )   fprintf(stdout,"%1.1i",ids%10);}
                    fprintf(stdout,"|\n");
                    fprintf(stdout,"Ly Tb\n");

                    // Display raw hits
                    for (ilayer=0; ilayer <= mxly-1;         ++ilayer)        {
                        for (itbin=0;  itbin  <= r_fifo_tbins-1; ++itbin ) { fprintf(stdout,"%1i %2i ",ilayer,itbin);

                            for (ids_abs=0;ids_abs<=39;++ids_abs) {
                                if (ids_abs%8==0) {fprintf(stdout,"|");}
                                fprintf(stdout,"%1.1x",read_pat[itbin][ilayer][ids_abs]);
                            }	// close for ids_abs
                            fprintf(stdout,"|\n");
                        }	// close itbin
                        fprintf(stdout,"\n");
                    }	// close ilayer

                    //------------------------------------------------------------------------------
                    // Compare read-back triads to generated triads if running on reference TMB
                    //------------------------------------------------------------------------------
                    if (err_check) {
                        triad_error= false;

                        for (ilayer=0;  ilayer<mxly;           ++ilayer ) {
                            for (itbin=0;   itbin<=r_fifo_tbins-1; ++itbin  ) {
                                for (ids_abs=0; ids_abs<mxdsabs;       ++ids_abs) {

                                    wrtbin     = itbin-ntbinspre;
                                    triad_read = read_pat[itbin][ilayer][ids_abs];

                                    if (wrtbin >=0 ) triad_write = itriad[wrtbin][ids_abs][ilayer];
                                    else             triad_write = 0;

                                    triad_skipped = (triad_read==0xE) && (triad_write==0);
                                    if ((triad_write!=triad_read) && !triad_skipped) {
                                        triad_error =true;

                                        fprintf(stdout,
                                                "Triad readback match error: triad_read=%2X triad_write=%2X ilayer=%3i itbin=%3i ids_abs=%3i ntbinspre=%3i\n",
                                                triad_read,triad_write,ilayer,itbin,ids_abs,ntbinspre);
                                        fprintf(stdout,
                                                "Triad readback match error: triad_read=%2X triad_write=%2X ilayer=%3i itbin=%3i ids_abs=%3i ntbinspre=%3i\n",
                                                triad_read,triad_write,ilayer,itbin,ids_abs,ntbinspre);
                                    }	// close if triad_write

                                }	// close ids_abs
                            }	// close itbin
                        }	// close ilayer

                        if (!triad_error) fprintf(stdout,"Triad readback OK\n");
                    }	// close if !scp_playback

                    //------------------------------------------------------------------------------
                    //	Scope readout
                    //------------------------------------------------------------------------------
check_scope:
                    // Scan for 06B05 marker
                    if(scope_exists !=1) {
                        fprintf(stdout,"Skipping scope readout because scope_exists=%1X\n",scope_exists);
                        goto skip_scope;
                    }

                    for (iframe=0; iframe<=last_frame; ++iframe) {
                        if(vf_data[iframe] == 0x06B05) {
                            iscp_begin=iframe;
                            fprintf(stdout,"06B05 scope marker found at frame=%5i\n",iscp_begin);
                            goto extract_scope;
                        }	// close if vf_data
                    }	// close iframe
                    fprintf(stdout,"No 06B05 scope marker found\n");
                    goto skip_scope;

                    // Extract scp data
extract_scope:
                    iscp_end=iscp_begin+frame_cntex_scope-1;
                    if(iscp_end > last_frame) {
                        fprintf(stdout,"Not enough scp data, aborting scp read\n");
                        goto skip_scope;
                    }

                    if(vf_data[iscp_end] == 0x6E05)
                        fprintf(stdout,"06E05 scope marker found at frame=%5i\n",iscp_end);
                    else {
                        fprintf(stdout,"Missing 6E05 marker at adr=%5i. Aborting scope read\n",iscp_end);
                        //	goto skip_scope;	////////////////////// TEMPORARY SKIP
                    }

                    iscp=0;
                    for (iframe=iscp_begin+1; iframe<=iscp_end-1; ++iframe) {	//excludes 6B05 and 6E05 markers
                        scp_raw_data[iscp]=vf_data[iframe];
                        if(iscp > (512*160/16-1)) 
                            pause ("iscp ovf in decode_raw_hits.for wtf?");
                        fprintf(stdout,"scp debug: %5i%5i%5.4X\n",iscp,iframe,scp_raw_data[iscp]);
                        iscp++;
                    }

                    // Load scope arrays, display channel graph
                    fprintf(stdout,"Decode/display raw hits scope data\n");
                    scp_arm			= false;
                    scp_readout		= false;
                    scp_raw_decode	= true;
                    scp_silent		= false;
                    scp_playback	= true;

                    scope160c(scp_ctrl_adr,scp_rdata_adr,scp_arm,scp_readout,scp_raw_decode,scp_silent,scp_playback,scp_raw_data);

skip_scope:
                    //------------------------------------------------------------------------------
                    //	Miniscope readout
                    //------------------------------------------------------------------------------
                    // Scan for 06B07 marker
                    if(miniscope_exists !=1) {
                        fprintf(stdout,"Skipping miniscope readout because miniscope_exists=%1X\n",miniscope_exists);
                        goto skip_miniscope;
                    }

                    for (iframe=0; iframe<=last_frame; ++iframe) {
                        if(vf_data[iframe] == 0x06B07) {
                            iscp_begin=iframe;
                            fprintf(stdout,"06B07 miniscope marker found at frame=%5i\n",iscp_begin);
                            goto extract_miniscope;
                        }	// close if vf_data
                    }	// close iframe
                    fprintf(stdout,"No 06B07 scope marker found\n");
                    goto skip_miniscope;

                    // Extract scp data
extract_miniscope:
                    iscp_end=iscp_begin+frame_cntex_miniscope+frame_cntex_b07e07-1;
                    if(iscp_end > last_frame) {
                        fprintf(stdout,"Not enough miniscp data, aborting miniscp read\n");
                        goto skip_miniscope;
                    }

                    if(vf_data[iscp_end] == 0x6E07)
                        fprintf(stdout,"06E07 miniscope marker found at frame=%5i\n",iscp_end);
                    else {
                        fprintf(stdout,"Missing 6E07 marker at adr=%5i. Aborting miniscope read\n",iscp_end);
                    }

                    iscp=0;
                    for (iframe=iscp_begin+1; iframe<=iscp_end-1; ++iframe) {	//excludes 6B07 and 6E07 markers
                        miniscope_data[iscp]=vf_data[iframe];
                        fprintf(stdout,"miniscp debug: %5i%5i%5.4X\n",iscp,iframe,miniscope_data[iscp]);
                        iscp++;
                        if(iscp >= 32) pause ("miniscope iscp ovf in decode_raw_hits.for wtf?");
                    }

                    // Load miniscope arrays, display channel graph
                    fprintf(stdout,"Decode/display miniscope data\n");

                    miniscope16(fifo_tbins_mini,miniscope_data);

skip_miniscope:

                    //------------------------------------------------------------------------------
                    // All done...wheee
                    //------------------------------------------------------------------------------
exit:
                    fprintf(stdout,"\n");

                    // Check error flags
                    for (i=0; i<MXERF; ++ i) {
                        if(error_flag[i]!=0) {
                            fprintf(stdout,  "Errs: Error flag [%2i]=%i %s\n",i,error_flag[i],error_msg[i].c_str());
                        }
                        fprintf(stdout,  "Errs: Error flag [%2i]=%i %s\n",i,error_flag[i],error_msg[i].c_str());
                    } //close for i<MXERF

                    if(header_ok)	
                        fprintf(stdout, "Header format OK\n");
                    else 			
                        fprintf(stdout, "Header format has errors\n");

                    return;
        } //close decode_readout()

        //------------------------------------------------------------------------------
        //	CLCT Pattern Finder Emulator
        //
        // Algorithm: 9-Pattern Front-end 80 MHz pattern-unit duplexing
        //
        // Process 5 CFEBs:
        //		Input	32 1/2-Strips x 6 CSC Layers x 5 CFEBs
        //		Output	Best 2 of 160 CLCTs
        //			   +DMB pre-trigger signals
        //
        //------------------------------------------------------------------------------
        void TMB::pattern_finder ( 
                // Inputs
                int hs[6][160], 
                int &csc_type, 
                int &clct_sep, 
                int &adjcfeb_dist,
                int	&layer_trig_en,
                int	cfeb_en[5],

                int &hit_thresh_pretrig,
                int &pid_thresh_pretrig,
                int &dmb_thresh_pretrig,
                int &lyr_thresh_pretrig,

                // Outputs
                int cfeb_active[5],
                int &nlayers_hit,
                int	&layer_trig,

                int &hs_key_1st,
                int &hs_pid_1st,
                int &hs_hit_1st,

                int &hs_key_2nd,
                int &hs_pid_2nd,
                int &hs_hit_2nd) {
                    //------------------------------------------------------------------------------
                    // Constants
                    //------------------------------------------------------------------------------
                    const int	MXCFEB		= 	5;				// Number of CFEBs on CSC
                    const int	MXLY		=	6;				// Number Layers in CSC
                    const int	MXHS		=	32;				// Number of 1/2-Strips per layer on 1 CFEB
                    const int	MXHSX		=	MXCFEB*MXHS;	// Number of 1/2-Strips per layer on 5 CFEBs
                    const int	MXKEYBX		=	8;				// Number of 1/2-strip key bits on 5 CFEBs
                    const int	MXPIDB		=	4;				// Pattern ID bits

                    //------------------------------------------------------------------------------
                    // Local
                    //------------------------------------------------------------------------------
                    int	i;
                    int ihs;

                    int	csc_me1ab;
                    int	stagger_hs_csc;
                    int	reverse_hs_csc;
                    int	reverse_hs_me1a;
                    int	reverse_hs_me1b;

                    //-------------------------------------------------------------------------------------------------------------------
                    // Re-Map input array into verilog pattern_finder format
                    //-------------------------------------------------------------------------------------------------------------------
                    // Alias stage0 array names
                    int	*cfeb0_ly0hs=&hs[0][0], *cfeb1_ly0hs=&hs[0][32], *cfeb2_ly0hs=&hs[0][64], *cfeb3_ly0hs=&hs[0][96], *cfeb4_ly0hs=&hs[0][128];
                    int	*cfeb0_ly1hs=&hs[1][0], *cfeb1_ly1hs=&hs[1][32], *cfeb2_ly1hs=&hs[1][64], *cfeb3_ly1hs=&hs[1][96], *cfeb4_ly1hs=&hs[1][128];
                    int	*cfeb0_ly2hs=&hs[2][0], *cfeb1_ly2hs=&hs[2][32], *cfeb2_ly2hs=&hs[2][64], *cfeb3_ly2hs=&hs[2][96], *cfeb4_ly2hs=&hs[2][128];
                    int	*cfeb0_ly3hs=&hs[3][0], *cfeb1_ly3hs=&hs[3][32], *cfeb2_ly3hs=&hs[3][64], *cfeb3_ly3hs=&hs[3][96], *cfeb4_ly3hs=&hs[3][128];
                    int	*cfeb0_ly4hs=&hs[4][0], *cfeb1_ly4hs=&hs[4][32], *cfeb2_ly4hs=&hs[4][64], *cfeb3_ly4hs=&hs[4][96], *cfeb4_ly4hs=&hs[4][128];
                    int	*cfeb0_ly5hs=&hs[5][0], *cfeb1_ly5hs=&hs[5][32], *cfeb2_ly5hs=&hs[5][64], *cfeb3_ly5hs=&hs[5][96], *cfeb4_ly5hs=&hs[5][128];

                    int	*cfebs_ly0hs=&hs[0][0];
                    int	*cfebs_ly1hs=&hs[1][0];
                    int	*cfebs_ly2hs=&hs[2][0];
                    int	*cfebs_ly3hs=&hs[3][0];
                    int	*cfebs_ly4hs=&hs[4][0];
                    int	*cfebs_ly5hs=&hs[5][0];

                    int	me1234_ly0hs[MXHS*5];
                    int	me1234_ly1hs[MXHS*5];
                    int	me1234_ly2hs[MXHS*5];
                    int	me1234_ly3hs[MXHS*5];
                    int	me1234_ly4hs[MXHS*5];
                    int	me1234_ly5hs[MXHS*5];

                    int	me1b_ly0hs[MXHS*4];
                    int	me1b_ly1hs[MXHS*4];
                    int	me1b_ly2hs[MXHS*4];
                    int	me1b_ly3hs[MXHS*4];
                    int	me1b_ly4hs[MXHS*4];
                    int	me1b_ly5hs[MXHS*4];

                    int	me1a_ly0hs[MXHS*1];
                    int	me1a_ly1hs[MXHS*1];
                    int	me1a_ly2hs[MXHS*1];
                    int	me1a_ly3hs[MXHS*1];
                    int	me1a_ly4hs[MXHS*1];
                    int	me1a_ly5hs[MXHS*1];

                    if (debug_) {
                        fprintf(stdout,"dbg: ly0="); for (i=0; i<MXHS; ++i) fprintf(stdout,"%1i",cfeb0_ly0hs[i]); fprintf(stdout,"\n");
                        fprintf(stdout,"dbg: ly1="); for (i=0; i<MXHS; ++i) fprintf(stdout,"%1i",cfeb0_ly1hs[i]); fprintf(stdout,"\n");
                        fprintf(stdout,"dbg: ly2="); for (i=0; i<MXHS; ++i) fprintf(stdout,"%1i",cfeb0_ly2hs[i]); fprintf(stdout,"\n");
                        fprintf(stdout,"dbg: ly3="); for (i=0; i<MXHS; ++i) fprintf(stdout,"%1i",cfeb0_ly3hs[i]); fprintf(stdout,"\n");
                        fprintf(stdout,"dbg: ly4="); for (i=0; i<MXHS; ++i) fprintf(stdout,"%1i",cfeb0_ly4hs[i]); fprintf(stdout,"\n");
                        fprintf(stdout,"dbg: ly5="); for (i=0; i<MXHS; ++i) fprintf(stdout,"%1i",cfeb0_ly5hs[i]); fprintf(stdout,"\n");
                    }

                    //-------------------------------------------------------------------------------------------------------------------
                    // Generate mask for marking adjacent cfeb as hit if nearby keys are over thresh
                    //-------------------------------------------------------------------------------------------------------------------
                    int adjcfeb_mask_nm1[MXHS];		// Adjacent CFEB active feb flag mask
                    int	adjcfeb_mask_np1[MXHS];

                    for (ihs=0; ihs<=31; ++ihs) {
                        adjcfeb_mask_nm1[ihs]	 = (ihs<adjcfeb_dist) ? 1:0;
                        adjcfeb_mask_np1[31-ihs] = (ihs<adjcfeb_dist) ? 1:0;
                    }

                    //-------------------------------------------------------------------------------------------------------------------
                    // Stage 4A1: CSC_TYPE_A Normal CSC
                    //-------------------------------------------------------------------------------------------------------------------
                    if (csc_type==0xA)
                    {

                        // Orientation flags
                        csc_me1ab	    = 0;			// 1= ME1A or ME1B CSC
                        stagger_hs_csc  = 1;			// 1=Staggered CSC non-me1
                        reverse_hs_csc  = 1;			// 1=Reversed  CSC non-me1
                        reverse_hs_me1a = 0;			// 1=reverse me1a hstrips prior to pattern sorting
                        reverse_hs_me1b = 0;			// 1=reverse me1b hstrips prior to pattern sorting

                        for (i=0; i<MXHS*5; ++i)
                        {
                            me1234_ly0hs[i] = cfebs_ly0hs[i];
                            me1234_ly1hs[i] = cfebs_ly1hs[i];
                            me1234_ly2hs[i] = cfebs_ly2hs[i];
                            me1234_ly3hs[i] = cfebs_ly3hs[i];
                            me1234_ly4hs[i] = cfebs_ly4hs[i];
                            me1234_ly5hs[i] = cfebs_ly5hs[i];
                        }
                    }	// close  if csc_type

                    //-------------------------------------------------------------------------------------------------------------------
                    // Stage 4A2: CSC_TYPE_B Reversed CSC
                    //-------------------------------------------------------------------------------------------------------------------
                    else if (csc_type==0xB)
                    {

                        // Orientation flags
                        csc_me1ab	    = 0;			// 1= ME1A or ME1B CSC
                        stagger_hs_csc  = 1;			// 1=Staggered CSC non-me1
                        reverse_hs_csc  = 1;			// 1=Reversed  CSC non-me1
                        reverse_hs_me1a = 0;			// 1=reverse me1a hstrips prior to pattern sorting
                        reverse_hs_me1b = 0;			// 1=reverse me1b hstrips prior to pattern sorting

                        // Reverse all CFEBs and reverse layers
                        for (i=0; i<MXHS*5; ++i)
                        {
                            me1234_ly5hs[i] = cfebs_ly0hs[MXHS*5-1-i];
                            me1234_ly4hs[i] = cfebs_ly1hs[MXHS*5-1-i];
                            me1234_ly3hs[i] = cfebs_ly2hs[MXHS*5-1-i];
                            me1234_ly2hs[i] = cfebs_ly3hs[MXHS*5-1-i];
                            me1234_ly1hs[i] = cfebs_ly4hs[MXHS*5-1-i];
                            me1234_ly0hs[i] = cfebs_ly5hs[MXHS*5-1-i];
                        }	// close for i
                    }	// close  if csc_type

                    //-------------------------------------------------------------------------------------------------------------------
                    // Stage 4A3: CSC_TYPE_C Normal ME1B reversed ME1A
                    //-------------------------------------------------------------------------------------------------------------------
                    else if (csc_type==0xC)
                    {

                        // Orientation flags
                        csc_me1ab		= 1;			// 1= ME1A or ME1B CSC
                        stagger_hs_csc  = 0;			// 1=Staggered CSC non-me1
                        reverse_hs_csc  = 0;			// 1=Reversed  CSC non-me1
                        reverse_hs_me1a = 1;			// 1=reverse me1a hstrips prior to pattern sorting
                        reverse_hs_me1b = 0;			// 1=reverse me1b hstrips prior to pattern sorting

                        // Reversed ME1A cfebs
                        for (i=0; i<MXHS; ++i)
                        {
                            me1a_ly0hs[i] = cfeb4_ly0hs[MXHS-1-i];
                            me1a_ly1hs[i] = cfeb4_ly1hs[MXHS-1-i];
                            me1a_ly2hs[i] = cfeb4_ly2hs[MXHS-1-i];
                            me1a_ly3hs[i] = cfeb4_ly3hs[MXHS-1-i];
                            me1a_ly4hs[i] = cfeb4_ly4hs[MXHS-1-i];
                            me1a_ly5hs[i] = cfeb4_ly5hs[MXHS-1-i];
                        }	// close for i

                        // Normal ME1B cfebs
                        for (i=0; i<MXHS*4; ++i)
                        {
                            me1b_ly0hs[i] = cfebs_ly0hs[i];
                            me1b_ly1hs[i] = cfebs_ly1hs[i];
                            me1b_ly2hs[i] = cfebs_ly2hs[i];
                            me1b_ly3hs[i] = cfebs_ly3hs[i];
                            me1b_ly4hs[i] = cfebs_ly4hs[i];
                            me1b_ly5hs[i] = cfebs_ly5hs[i];
                        }	// close for i
                    }	// close  if csc_type

                    //-------------------------------------------------------------------------------------------------------------------
                    // Stage 4A4: CSC_TYPE_D Normal ME1A reversed ME1B
                    //-------------------------------------------------------------------------------------------------------------------
                    else if (csc_type==0xD)
                    {

                        // Orientation flags
                        csc_me1ab	    = 1;			// 1= ME1A or ME1B CSC
                        stagger_hs_csc  = 0;			// 1=Staggered CSC non-me1
                        reverse_hs_csc  = 0;			// 1=Reversed  CSC non-me1
                        reverse_hs_me1a = 0;			// 1=reverse me1a hstrips prior to pattern sorting
                        reverse_hs_me1b = 1;			// 1=reverse me1b hstrips prior to pattern sorting

                        // Normal ME1A cfebs
                        for (i=0; i<MXHS; ++i)
                        {
                            me1a_ly0hs[i] = cfeb4_ly0hs[i];
                            me1a_ly1hs[i] = cfeb4_ly1hs[i];
                            me1a_ly2hs[i] = cfeb4_ly2hs[i];
                            me1a_ly3hs[i] = cfeb4_ly3hs[i];
                            me1a_ly4hs[i] = cfeb4_ly4hs[i];
                            me1a_ly5hs[i] = cfeb4_ly5hs[i];
                        }	// close for i

                        // Reversed ME1B cfebs
                        for (i=0; i<MXHS*4; ++i)
                        {
                            me1b_ly0hs[i] = cfebs_ly0hs[MXHS*4-1-i];
                            me1b_ly1hs[i] = cfebs_ly1hs[MXHS*4-1-i];
                            me1b_ly2hs[i] = cfebs_ly2hs[MXHS*4-1-i];
                            me1b_ly3hs[i] = cfebs_ly3hs[MXHS*4-1-i];
                            me1b_ly4hs[i] = cfebs_ly4hs[MXHS*4-1-i];
                            me1b_ly5hs[i] = cfebs_ly5hs[MXHS*4-1-i];
                        }	// close for i
                    }	// close  if csc_type

                    //-------------------------------------------------------------------------------------------------------------------
                    // Stage 4A5: CSC_TYPE_X Undefined
                    //-------------------------------------------------------------------------------------------------------------------
                    else
                    {
                        pause("csc_type undefined in pattern_finder");
                        (*MyOutput_) << "\ncsc_type=" << csc_type << std::endl; 
                    }

                    //-------------------------------------------------------------------------------------------------------------------
                    // Stage 4B: Correct for CSC layer stagger: 565656 is a straight track, becomes 555555 on key layer 2
                    //
                    //	ly0hs:   -2 -1 | 00 01 02 03 04 05 06 ... 152 153 154 155 156 157 158 159 | 160 no shift
                    //	ly1hs:   -1 00 | 01 02 03 04 05 06 07 ... 153 154 155 156 157 158 159 160 | 161 
                    //	ly2hs:   -2 -1 | 00 01 02 03 04 05 06 ... 152 153 154 155 156 157 158 159 | 160 no shift, key layer
                    //	ly3hs:   -1 00 | 01 02 03 04 05 06 07 ... 153 154 155 156 157 158 159 160 | 161 
                    //	ly4hs:   -2 -1 | 00 01 02 03 04 05 06 ... 152 153 154 155 156 157 158 159 | 160 no shift
                    //	ly5hs:   -1 00 | 01 02 03 04 05 06 07 ... 153 154 155 156 157 158 159 160 | 161 
                    //-------------------------------------------------------------------------------------------------------------------
                    // Create hs arrays with 0s padded at left and right csc edges
                    const int k=5;				// Shift negative array indexes positive to compensate for pattern bends off the edges
                    const int j=0;				// Shift negative array indexes positive to compensate for stagger

                    int ly0hs_pad[k+MXHSX+j+k]={0};
                    int ly1hs_pad[k+MXHSX+j+k]={0};
                    int ly2hs_pad[k+MXHSX+j+k]={0};
                    int ly3hs_pad[k+MXHSX+j+k]={0};
                    int ly4hs_pad[k+MXHSX+j+k]={0};
                    int ly5hs_pad[k+MXHSX+j+k]={0};

                    if (stagger_hs_csc)			// Stagger correction
                    {
                        for (i=0; i<MXHSX; ++i) {
                            ly0hs_pad[i-0+j+k] = me1234_ly0hs[i];
                            ly1hs_pad[i-1+j+k] = me1234_ly1hs[i];
                            ly2hs_pad[i-0+j+k] = me1234_ly2hs[i];
                            ly3hs_pad[i-1+j+k] = me1234_ly3hs[i];
                            ly4hs_pad[i-0+j+k] = me1234_ly4hs[i];
                            ly5hs_pad[i-1+j+k] = me1234_ly5hs[i];
                        }}
                    else						// No stagger correction
                    {
                        for (i=0; i<MXHSX; ++i) {
                            ly0hs_pad[i-0+j+k] = (i>=128) ? me1a_ly0hs[i%32] : me1b_ly0hs[i%128];
                            ly1hs_pad[i-0+j+k] = (i>=128) ? me1a_ly1hs[i%32] : me1b_ly1hs[i%128];
                            ly2hs_pad[i-0+j+k] = (i>=128) ? me1a_ly2hs[i%32] : me1b_ly2hs[i%128];
                            ly3hs_pad[i-0+j+k] = (i>=128) ? me1a_ly3hs[i%32] : me1b_ly3hs[i%128];
                            ly4hs_pad[i-0+j+k] = (i>=128) ? me1a_ly4hs[i%32] : me1b_ly4hs[i%128];
                            ly5hs_pad[i-0+j+k] = (i>=128) ? me1a_ly5hs[i%32] : me1b_ly5hs[i%128];
                        }}

                        if (debug_) {
                            fprintf(stdout,"dbg: ly0hs_pad="); for (i=0; i<(k+MXHSX+j+k); ++i) fprintf(stdout,"%1i",ly0hs_pad[i]); fprintf(stdout,"\n");
                            fprintf(stdout,"dbg: ly1hs_pad="); for (i=0; i<(k+MXHSX+j+k); ++i) fprintf(stdout,"%1i",ly1hs_pad[i]); fprintf(stdout,"\n");
                            fprintf(stdout,"dbg: ly2hs_pad="); for (i=0; i<(k+MXHSX+j+k); ++i) fprintf(stdout,"%1i",ly2hs_pad[i]); fprintf(stdout,"\n");
                            fprintf(stdout,"dbg: ly3hs_pad="); for (i=0; i<(k+MXHSX+j+k); ++i) fprintf(stdout,"%1i",ly3hs_pad[i]); fprintf(stdout,"\n");
                            fprintf(stdout,"dbg: ly4hs_pad="); for (i=0; i<(k+MXHSX+j+k); ++i) fprintf(stdout,"%1i",ly4hs_pad[i]); fprintf(stdout,"\n");
                            fprintf(stdout,"dbg: ly5hs_pad="); for (i=0; i<(k+MXHSX+j+k); ++i) fprintf(stdout,"%1i",ly5hs_pad[i]); fprintf(stdout,"\n");
                        }

                        //-------------------------------------------------------------------------------------------------------------------
                        // Stage 4C:  Layer-trigger mode
                        //-------------------------------------------------------------------------------------------------------------------
                        // Layer Trigger Mode, delay 1bx for FF
                        int layer_or_s0[MXLY]={0};

                        for (i=0; i<MXHSX; ++i)
                        {
                            layer_or_s0[0] = layer_or_s0[0] | cfebs_ly0hs[i];
                            layer_or_s0[1] = layer_or_s0[1] | cfebs_ly1hs[i];
                            layer_or_s0[2] = layer_or_s0[2] | cfebs_ly2hs[i];
                            layer_or_s0[3] = layer_or_s0[3] | cfebs_ly3hs[i];
                            layer_or_s0[4] = layer_or_s0[4] | cfebs_ly4hs[i];
                            layer_or_s0[5] = layer_or_s0[5] | cfebs_ly5hs[i];
                        }

                        // Sum number of layers hit into a binary pattern number
                        nlayers_hit=0;

                        for (i=0; i<=5; ++i) {
                            if (layer_or_s0[i]==1) nlayers_hit++;
                        }

                        layer_trig = (nlayers_hit >= lyr_thresh_pretrig);

                        if (debug_) {
                            fprintf(stdout,"dbg: layer_trig =%1i\n",layer_trig );
                            fprintf(stdout,"dbg: nlayers_hit=%1i\n",nlayers_hit);
                        }

                        //-------------------------------------------------------------------------------------------------------------------
                        // Stage 4D: 1/2-Strip Pattern Finder
                        //			 Finds number of hits in pattern templates for each key 1/2-strip.
                        //
                        //			hs	0123456789A
                        //	ly0[10:0]	xxxxxkxxxxx    5+1+5 =11
                        //	ly1[ 7:3]	   xxkxx       2+1+2 = 5
                        //	ly2[ 5:5]	     k         0+1+0 = 1
                        //	ly3[ 7:3]	   xxkxx       2+1+2 = 5
                        //	ly4[ 9:1]	 xxxxkxxxx     4+1+4 = 9
                        //	ly5[10:0]	xxxxxkxxxxx    5+1+5 =11
                        //                                                                   11111111 11111
                        //              nnnnn            77777777 88888     77777 88888888   55555555 66666
                        //          hs  54321 01234567   23456789 01234     56789 01234567   23456789 01234
                        //	ly0[10:0]	00000|aaaaaaaa...aaaaaaaa|bbbbb     aaaaa|bbbbbbbb...bbbbbbbb|00000
                        //	ly1[ 7:3]	   0s|aaaaaaaa...aaaaaaaa|bb           aa|bbbbbbbb...bbbbbbb0|00
                        //	ly2[ 5:5]	     |aaaaaaaa...aaaaaaaa|               |bbbbbbbb...bbbbbbbb|
                        //	ly3[ 7:3]	   0s|aaaaaaaa...aaaaaaaa|bb           aa|bbbbbbbb...bbbbbbb0|00
                        //	ly4[ 9:1]	 0000|aaaaaaaa...aaaaaaaa|bbbb       aaaa|bbbbbbbb...bbbbbbbb|0000
                        //	ly5[10:0]	0000s|aaaaaaaa...aaaaaaaa|bbbbb     aaaaa|bbbbbbbb...bbbbbbb0|00000
                        //
                        //-------------------------------------------------------------------------------------------------------------------
                        // Find pattern hits for each 1/2-strip key
                        int hs_hit [MXHSX];
                        int hs_pid [MXHSX];

                        for (ihs=0; ihs<MXHSX; ++ihs)
                        {
                            pattern_unit(
                                    &ly0hs_pad[ihs],
                                    &ly1hs_pad[ihs],
                                    &ly2hs_pad[ihs],	//key on ly2
                                    &ly3hs_pad[ihs],
                                    &ly4hs_pad[ihs],
                                    &ly5hs_pad[ihs],
                                    hs_hit[ihs],
                                    hs_pid[ihs]);
                            if (debug_) 
                                fprintf(stdout,"dbg: hs_hit[%3i]=%1i hs_pid[%3i]=%1X\n",ihs,hs_hit[ihs],ihs,hs_pid[ihs]);
                        }

                        // Convert s0 pattern IDs and hits into sortable pattern numbers, [6:4]=nhits, [3:0]=pattern id
                        int hs_pat[MXHSX];

                        for (ihs=0; ihs<MXHSX; ++ihs)
                        {
                            hs_pat[ihs] = (hs_hit[ihs]<<4) | hs_pid[ihs];
                        }

                        //-------------------------------------------------------------------------------------------------------------------
                        // Stage 5A: Pre-Trigger Look-ahead
                        // 			 Set active FEB bit ASAP if any pattern is over threshold. 
                        //			 It comes out before the priority encoder result
                        //-------------------------------------------------------------------------------------------------------------------
                        // Alias stage0 array names
                        int	(&hs_hit_pre_s0)[160](hs_hit);
                        int	(&hs_pid_pre_s0)[160](hs_pid);

                        // Flag keys with pattern hits over threshold, use fast-out hit numbers before s0 latch
                        int	hs_key_hit0[MXHS], hs_key_pid0[MXHS], hs_key_dmb0[MXHS];
                        int	hs_key_hit1[MXHS], hs_key_pid1[MXHS], hs_key_dmb1[MXHS];
                        int	hs_key_hit2[MXHS], hs_key_pid2[MXHS], hs_key_dmb2[MXHS];
                        int	hs_key_hit3[MXHS], hs_key_pid3[MXHS], hs_key_dmb3[MXHS];
                        int	hs_key_hit4[MXHS], hs_key_pid4[MXHS], hs_key_dmb4[MXHS];

                        // Flag keys with pattern hits over threshold, use fast-out hit numbers before s0 latch
                        for (ihs=0; ihs<MXHS; ++ ihs)
                        {
                            if (csc_type==0xA || csc_type==0xC)										// Unreversed CSC or unreversed ME1B
                            {
                                hs_key_hit0[ihs] = (hs_hit_pre_s0[ihs+MXHS*0] >= hit_thresh_pretrig);	// Normal CSC
                                hs_key_hit1[ihs] = (hs_hit_pre_s0[ihs+MXHS*1] >= hit_thresh_pretrig);
                                hs_key_hit2[ihs] = (hs_hit_pre_s0[ihs+MXHS*2] >= hit_thresh_pretrig);
                                hs_key_hit3[ihs] = (hs_hit_pre_s0[ihs+MXHS*3] >= hit_thresh_pretrig);
                                hs_key_hit4[ihs] = (hs_hit_pre_s0[ihs+MXHS*4] >= hit_thresh_pretrig);

                                hs_key_pid0[ihs] = (hs_pid_pre_s0[ihs+MXHS*0] >= pid_thresh_pretrig);
                                hs_key_pid1[ihs] = (hs_pid_pre_s0[ihs+MXHS*1] >= pid_thresh_pretrig);
                                hs_key_pid2[ihs] = (hs_pid_pre_s0[ihs+MXHS*2] >= pid_thresh_pretrig);
                                hs_key_pid3[ihs] = (hs_pid_pre_s0[ihs+MXHS*3] >= pid_thresh_pretrig);
                                hs_key_pid4[ihs] = (hs_pid_pre_s0[ihs+MXHS*4] >= pid_thresh_pretrig);

                                hs_key_dmb0[ihs] = (hs_hit_pre_s0[ihs+MXHS*0] >= dmb_thresh_pretrig);
                                hs_key_dmb1[ihs] = (hs_hit_pre_s0[ihs+MXHS*1] >= dmb_thresh_pretrig);
                                hs_key_dmb2[ihs] = (hs_hit_pre_s0[ihs+MXHS*2] >= dmb_thresh_pretrig);
                                hs_key_dmb3[ihs] = (hs_hit_pre_s0[ihs+MXHS*3] >= dmb_thresh_pretrig);
                                hs_key_dmb4[ihs] = (hs_hit_pre_s0[ihs+MXHS*4] >= dmb_thresh_pretrig);
                            }
                            else if (csc_type==0xB) 												// Reversed CSC
                            {
                                hs_key_hit0[ihs] = (hs_hit_pre_s0[MXHS*5-1-ihs] >= hit_thresh_pretrig);	// Reversed CSC
                                hs_key_hit1[ihs] = (hs_hit_pre_s0[MXHS*4-1-ihs] >= hit_thresh_pretrig);
                                hs_key_hit2[ihs] = (hs_hit_pre_s0[MXHS*3-1-ihs] >= hit_thresh_pretrig);
                                hs_key_hit3[ihs] = (hs_hit_pre_s0[MXHS*2-1-ihs] >= hit_thresh_pretrig);
                                hs_key_hit4[ihs] = (hs_hit_pre_s0[MXHS*1-1-ihs] >= hit_thresh_pretrig);

                                hs_key_pid0[ihs] = (hs_pid_pre_s0[MXHS*5-1-ihs] >= pid_thresh_pretrig);
                                hs_key_pid1[ihs] = (hs_pid_pre_s0[MXHS*4-1-ihs] >= pid_thresh_pretrig);
                                hs_key_pid2[ihs] = (hs_pid_pre_s0[MXHS*3-1-ihs] >= pid_thresh_pretrig);
                                hs_key_pid3[ihs] = (hs_pid_pre_s0[MXHS*2-1-ihs] >= pid_thresh_pretrig);
                                hs_key_pid4[ihs] = (hs_pid_pre_s0[MXHS*1-1-ihs] >= pid_thresh_pretrig);

                                hs_key_dmb0[ihs] = (hs_hit_pre_s0[MXHS*5-1-ihs] >= dmb_thresh_pretrig);
                                hs_key_dmb1[ihs] = (hs_hit_pre_s0[MXHS*4-1-ihs] >= dmb_thresh_pretrig);
                                hs_key_dmb2[ihs] = (hs_hit_pre_s0[MXHS*3-1-ihs] >= dmb_thresh_pretrig);
                                hs_key_dmb3[ihs] = (hs_hit_pre_s0[MXHS*2-1-ihs] >= dmb_thresh_pretrig);
                                hs_key_dmb4[ihs] = (hs_hit_pre_s0[MXHS*1-1-ihs] >= dmb_thresh_pretrig);
                            }
                            else																	// Reversed ME1B
                            {
                                hs_key_hit0[ihs] = (hs_hit_pre_s0[MXHS*4-1-ihs] >= hit_thresh_pretrig);	// Reversed ME1B, not reversed ME1A
                                hs_key_hit1[ihs] = (hs_hit_pre_s0[MXHS*3-1-ihs] >= hit_thresh_pretrig);
                                hs_key_hit2[ihs] = (hs_hit_pre_s0[MXHS*2-1-ihs] >= hit_thresh_pretrig);
                                hs_key_hit3[ihs] = (hs_hit_pre_s0[MXHS*1-1-ihs] >= hit_thresh_pretrig);
                                hs_key_hit4[ihs] = (hs_hit_pre_s0[ihs+MXHS*4]   >= hit_thresh_pretrig);

                                hs_key_pid0[ihs] = (hs_pid_pre_s0[MXHS*4-1-ihs] >= pid_thresh_pretrig);
                                hs_key_pid1[ihs] = (hs_pid_pre_s0[MXHS*3-1-ihs] >= pid_thresh_pretrig);
                                hs_key_pid2[ihs] = (hs_pid_pre_s0[MXHS*2-1-ihs] >= pid_thresh_pretrig);
                                hs_key_pid3[ihs] = (hs_pid_pre_s0[MXHS*1-1-ihs] >= pid_thresh_pretrig);
                                hs_key_pid4[ihs] = (hs_pid_pre_s0[ihs+MXHS*4]   >= pid_thresh_pretrig);

                                hs_key_dmb0[ihs] = (hs_hit_pre_s0[MXHS*4-1-ihs] >= dmb_thresh_pretrig);
                                hs_key_dmb1[ihs] = (hs_hit_pre_s0[MXHS*3-1-ihs] >= dmb_thresh_pretrig);
                                hs_key_dmb2[ihs] = (hs_hit_pre_s0[MXHS*2-1-ihs] >= dmb_thresh_pretrig);
                                hs_key_dmb3[ihs] = (hs_hit_pre_s0[MXHS*1-1-ihs] >= dmb_thresh_pretrig);
                                hs_key_dmb4[ihs] = (hs_hit_pre_s0[ihs+MXHS*4]   >= dmb_thresh_pretrig);
                            }
                        }

                        // Output active FEB signal, and adjacent FEBs if hit is near board boundary
                        int	cfebnm1_hit[5];	// Adjacent CFEB-1 has a pattern over threshold
                        int	cfebnp1_hit[5];	// Adjacent CFEB+1 has a pattern over threshold

                        int hs_key_hitpid0[MXHS];
                        int hs_key_hitpid1[MXHS];
                        int hs_key_hitpid2[MXHS];
                        int hs_key_hitpid3[MXHS];
                        int hs_key_hitpid4[MXHS];
                        int cfeb_hit[MXCFEB];

                        for (i=0; i<MXHS; ++i) {
                            hs_key_hitpid0[i] = hs_key_hit0[i] & hs_key_pid0[i];	// hits on key satify both hit and pid thresholds
                            hs_key_hitpid1[i] = hs_key_hit1[i] & hs_key_pid1[i];
                            hs_key_hitpid2[i] = hs_key_hit2[i] & hs_key_pid2[i];
                            hs_key_hitpid3[i] = hs_key_hit3[i] & hs_key_pid3[i];
                            hs_key_hitpid4[i] = hs_key_hit4[i] & hs_key_pid4[i];
                        }

                        int cfeb_layer_trigger = layer_trig && layer_trig_en;

                        cfeb_hit[0] = (arrayOr(hs_key_hitpid0) || cfeb_layer_trigger) && cfeb_en[0];
                        cfeb_hit[1] = (arrayOr(hs_key_hitpid1) || cfeb_layer_trigger) && cfeb_en[1];
                        cfeb_hit[2] = (arrayOr(hs_key_hitpid2) || cfeb_layer_trigger) && cfeb_en[2];
                        cfeb_hit[3] = (arrayOr(hs_key_hitpid3) || cfeb_layer_trigger) && cfeb_en[3];
                        cfeb_hit[4] = (arrayOr(hs_key_hitpid4) || cfeb_layer_trigger) && cfeb_en[4];

                        cfebnm1_hit[1]	= arrayOr(arrayAnd(hs_key_hitpid1, adjcfeb_mask_nm1));
                        cfebnm1_hit[2]	= arrayOr(arrayAnd(hs_key_hitpid2, adjcfeb_mask_nm1));
                        cfebnm1_hit[3]	= arrayOr(arrayAnd(hs_key_hitpid3, adjcfeb_mask_nm1));
                        cfebnm1_hit[4]	= arrayOr(arrayAnd(hs_key_hitpid4, adjcfeb_mask_nm1)) && !csc_me1ab;	// Turn off adjacency for me1ab

                        cfebnp1_hit[0]	= arrayOr(arrayAnd(hs_key_hitpid0, adjcfeb_mask_np1));
                        cfebnp1_hit[1]	= arrayOr(arrayAnd(hs_key_hitpid1, adjcfeb_mask_np1));
                        cfebnp1_hit[2]	= arrayOr(arrayAnd(hs_key_hitpid2, adjcfeb_mask_np1));
                        cfebnp1_hit[3]	= arrayOr(arrayAnd(hs_key_hitpid3, adjcfeb_mask_np1)) && !csc_me1ab;	// Turn off adjacency for me1ab

                        // Output active FEB signal, and adjacent FEBs if hit is near board boundary
                        cfeb_active[0]	=	(cfeb_hit[0] || cfebnm1_hit[1] || arrayOr(hs_key_dmb0)) && cfeb_en[0];
                        cfeb_active[1]	=	(cfeb_hit[1] || cfebnp1_hit[0] || cfebnm1_hit[2] || arrayOr(hs_key_dmb1)) && cfeb_en[1];
                        cfeb_active[2]	=	(cfeb_hit[2] || cfebnp1_hit[1] || cfebnm1_hit[3] || arrayOr(hs_key_dmb2)) && cfeb_en[2];
                        cfeb_active[3]	=	(cfeb_hit[3] || cfebnp1_hit[2] || cfebnm1_hit[4] || arrayOr(hs_key_dmb3)) && cfeb_en[3];
                        cfeb_active[4]	=	(cfeb_hit[4] || cfebnp1_hit[3]                   || arrayOr(hs_key_dmb4)) && cfeb_en[4];

                        //------------------------------------------------------------------------------
                        // Stage 5B: 1/2-Strip Priority Encoder
                        // 			 Select the 1st best pattern from 160 Key 1/2-Strips
                        //------------------------------------------------------------------------------
                        // Best 1 of 160 1/2-strip patterns
                        int	hs_pat_1st=0;	// pat[6:4]=nhits, pat[3:0]=pattern id

                        hs_key_1st=0;
                        hs_pid_1st=0;
                        hs_hit_1st=0;

                        for (ihs=0; ihs<MXHSX; ++ihs)
                        {
                            if (hs_pat[ihs]>hs_pat_1st)
                            {
                                hs_pat_1st=hs_pat[ihs];
                                hs_key_1st=ihs;
                            }
                        }

                        hs_pid_1st = (hs_pat_1st >> 0     ) & 0xF;
                        hs_hit_1st = (hs_pat_1st >> MXPIDB) & 0x7;

                        if (debug_) {
                            fprintf(stdout,"dbg: hs_key_1st=%3i\n",hs_key_1st);
                            fprintf(stdout,"dbg: hs_pid_1st=%3X\n",hs_pid_1st);
                            fprintf(stdout,"dbg: hs_hit_1st=%3i\n",hs_hit_1st);
                        }

                        //------------------------------------------------------------------------------
                        // Stage 6B: Mark key 1/2-strips near the 1st CLCT key as 
                        // busy to exclude them from 2nd CLCT priority encoding
                        //------------------------------------------------------------------------------
                        int	nspan;
                        int	pspan;
                        int	clct0_is_on_me1a;
                        int	hs_key_s2;

                        nspan = clct_sep;
                        pspan = clct_sep;
                        hs_key_s2 = hs_key_1st;

                        // CSC Type A or B delimiters for excluding 2nd clct span hs0-159
                        if (csc_type==0xA || csc_type==0xB) {
                            busy_max = (hs_key_s2 <= 159-pspan) ? hs_key_s2+pspan : 159;	// Limit busy list to range 0-159
                            busy_min = (hs_key_s2 >= nspan    ) ? hs_key_s2-nspan : 0;
                        }

                        // CSC Type C or D delimiters for excluding 2nd clct span ME1B hs0-127  ME1A hs128-159
                        else if (csc_type==0xC || csc_type==0xD) {

                            clct0_is_on_me1a = hs_key_1st >> (MXKEYBX-1);

                            if (clct0_is_on_me1a) {		// CLCT0 is on ME1A cfeb4, limit blanking region to 128-159
                                busy_max = (hs_key_s2 <= 159-pspan) ? hs_key_s2+pspan : 159;
                                busy_min = (hs_key_s2 >= 128+nspan) ? hs_key_s2-nspan : 128;
                            }
                            else {						// CLCT0 is on ME1B cfeb0-cfeb3, limit blanking region to 0-127
                                busy_max = (hs_key_s2 <= 127-pspan) ? hs_key_s2+pspan : 127;
                                busy_min = (hs_key_s2 >=     nspan) ? hs_key_s2-nspan : 0;
                            }
                        }

                        // CSC Type missing
                        else
                            pause("CSC_TYPE undefined for 2nd clct delimiters in pattern_finder: Halting");

                        // Latch busy key 1/2-strips for excluding 2nd clct
                        int	busy_key[MXHSX];
                        int	ikey;

                        for (ikey=0; ikey<MXHSX; ++ikey) {
                            busy_key[ikey] = (ikey>=busy_min && ikey<=busy_max);
                        }

                        if (debug_) {
                            fprintf(stdout,"\n");
                            fprintf(stdout,"dbg: busy_min=%3i\n",busy_min);
                            fprintf(stdout,"dbg: busy_max=%3i\n",busy_max);
                            fprintf(stdout,"dbg: busy_key="); for (i=0; i<MXHSX; ++i) fprintf(stdout,"%1i",busy_key[i]); fprintf(stdout,"\n");
                        }

                        //-------------------------------------------------------------------------------------------------------------------
                        // Stage 7A: 1/2-Strip Priority Encoder
                        // 			Find 2nd best of 160 patterns, excluding busy region around 1st best key
                        //-------------------------------------------------------------------------------------------------------------------
                        // Best 1 of 160 1/2-strip patterns
                        int hs_key_s5=0;
                        int hs_pat_s5=0;	// pat[6:4]=nhits, pat[3:0]=pattern id
                        int hs_pid_s5=0;
                        int hs_hit_s5=0;
                        int	hs_bsy_s5=0;

                        for (ihs=0; ihs<MXHSX; ++ihs)
                        {
                            if (hs_pat[ihs]>hs_pat_s5 && !busy_key[ihs])
                            {
                                hs_pat_s5 = hs_pat[ihs];
                                hs_key_s5 = ihs;
                                hs_bsy_s5 = busy_key[ihs];
                            }
                        }

                        // Latch final 2nd CLCT
                        bool	blank_2nd;
                        int		hs_bsy_2nd;
                        int		clct_blanking=1;

                        hs_hit_s5    = (hs_pat_s5 >> MXPIDB);
                        blank_2nd    = (hs_hit_s5==0 && clct_blanking==1);

                        if (blank_2nd) {
                            hs_pid_2nd	= 0;
                            hs_hit_2nd	= 0;
                            hs_key_2nd	= 0;
                            hs_bsy_2nd	= hs_bsy_s5;
                        }
                        else {									// else assert final 2nd clct
                            hs_pid_2nd	= (hs_pat_s5 >> 0) & 0xF;
                            hs_hit_2nd	= (hs_pat_s5 >> 4) & 0x7;
                            hs_key_2nd	=  hs_key_s5;
                            hs_bsy_2nd	=  hs_bsy_s5;
                        }
                        if (hs_bsy_2nd!=0) pause("pattern_finder hs_busy_2nd!=0 wtf?!");

                        if (debug_) {
                            fprintf(stdout,"dbg: hs_key_2nd=%3i\n",hs_key_2nd);
                            fprintf(stdout,"dbg: hs_pid_2nd=%3X\n",hs_pid_2nd);
                            fprintf(stdout,"dbg: hs_hit_2nd=%3i\n",hs_hit_2nd);
                        }

                        return;
                } //close pattern_finder

        //------------------------------------------------------------------------------
        // Pause emulator cuz C sux
        //------------------------------------------------------------------------------
        std::string s; 
        void TMB::stop (std::string s) {
            (*MyOutput_) << "\n STOP: " << s.c_str() << std::endl;
            exit(EXIT_FAILURE);
        }

        //------------------------------------------------------------------------------
        // Pause emulator cuz C sux
        //------------------------------------------------------------------------------
        void TMB::pause (std::string s) {
            (*MyOutput_) << "\n PAUSE: " << s.c_str() << std::endl;
            return;
        }
        
        //------------------------------------------------------------------------------
        // LCT Quality
        //
        // 01/17/08	Initial
        // 01/17/08 Q=4 reserved, Q=3-1 shifted down
        //------------------------------------------------------------------------------

        void TMB::lct_quality(int &ACC, int &A, int &C, int &A4, int &C4, int &P, int &CPAT, int &Q) {
            //------------------------------------------------------------------------------------------
            // Ports
            //	input			ACC;		// ALCT accelerator muon bit
            //	input			A;			// bit: ALCT was found
            //	input			C;			// bit: CLCT was found
            //	input			A4;			// bit (N_A>=4), where N_A=number of ALCT layers
            //	input			C4;			// bit (N_C>=4), where N_C=number of CLCT layers
            //	input	[3:0]	P;			// 4-bit CLCT pattern number that is presently 1 for n-layer triggers, 2-10 for current patterns, 11-15 "for future expansion".
            //	input			CPAT;		// bit for cathode .pattern trigger., i.e. (P>=2  &&  P<=10) at present
            //	output	[3:0]	Q;			// 4-bit TMB quality output
            //
            // Quality-by-quality definition
            //	reg [3:0] Q;
            //
            //	always @* begin

            if		(C4 && (P == 10)          && A4 && !ACC)	Q=15;	// HQ muon, straight
            else if	(C4 && (P == 8 || P == 9) && A4 && !ACC)	Q=14;	// HQ muon, slight bend
            else if	(C4 && (P == 6 || P == 7) && A4 && !ACC)	Q=13;	// HQ muon, more	"
            else if	(C4 && (P == 4 || P == 5) && A4 && !ACC)	Q=12;	// HQ muon, more	"
            else if	(C4 && (P == 2 || P == 3) && A4 && !ACC)	Q=11;	// HQ muon, more	"
            //														Q=10;	// reserved for HQ muons with future patterns
            //														Q=9;	// reserved for HQ muons with future patterns
            else if	(C4 && CPAT             && A4 && ACC)		Q=8;	// HQ muon, but accel ALCT
            else if	(C4 && CPAT             && A  && !A4)		Q=7;	// HQ cathode, but marginal anode
            else if	(C  && !C4 && CPAT && A4 )					Q=6;	// HQ anode, but marginal cathode
            else if	(C  && !C4 && CPAT && A && !A4)				Q=5;	// marginal anode and cathode
            //														Q=4;	// reserved for LQ muons with 2D information in the future
            else if	(C  && A && (P == 1))						Q=3;	// any match but layer CLCT
            else if(C  && !A)									Q=2;	// some CLCT, no ALCT (unmatched)
            else if(A  && !C)									Q=1;	// some ALCT, no CLCT (unmatched)
            else												Q=0;	// should never be assigned

            //	endmodule
            fprintf(stdout,"ACC=%3i A=%3i C=%3i A4=%3i C4=%3i P=%3i CPAT=%3i,Q=%3i\n",ACC,A,C,A4,C4,P,CPAT,Q);
            return;
        } //close lct_quality (...

        //------------------------------------------------------------------------------
        //	TMB Internal Miniscope Readout
        // 
        //	05/01/09 Initial
        //	06/28/10 New channel assignments
        //	06/28/10 skip 1st tbin if it contains the wordcount
        //------------------------------------------------------------------------------
        void TMB::miniscope16 (int ntbins, int miniscope_data[16]) {

            const int		NCHANNELS	= 16;
            const int		MXTBINS		= 32;			// tbins per channel
            //const int		MXDSP		= 32;			// max tbins to display
            const bool		DISP_ALL	= false;		// true= display hex channel binary levels, false=blank them

            int				itbin;
            int				ich;
            int				ibit;
            int				idigit;
            int				ndisp;

            int				scope_ch[MXTBINS] = {0};
            int				ihex[MXTBINS]     = {0};

            static bool		scp_first_pass    = true;
            bool			skip_1st_tbin     = true;
            int				last_bit;
            int				ndigits;
            bool			chblank;
            int				irow;
            int				it;
            int				tb0;

            char			state[8]={'s','i','p','t','f','h','6','7'};

            //------------------------------------------------------------------------------
            // Channel labels
            //------------------------------------------------------------------------------
            class label
            {
                public:
                    int		nbits;
                    int		bit;
                    std::string	tag;
            };
            static label ch[NCHANNELS];

            if (scp_first_pass) {
                //	Channel has nbits      This is bit              Channel name tag
                //                 |                 |              |
                ch[ 0].nbits = 1;	ch[ 0].bit = 0;	ch[ 0].tag="any_cfeb_hit       ";

                ch[ 1].nbits = 3;	ch[ 1].bit = 0;	ch[ 1].tag="clct_state_machine ";
                ch[ 2].nbits = 3;	ch[ 2].bit = 1;	ch[ 2].tag="clct_state_machine ";
                ch[ 3].nbits = 3;	ch[ 3].bit = 2;	ch[ 3].tag="clct_state_machine ";

                ch[ 4].nbits = 1;	ch[ 4].bit = 0;	ch[ 4].tag="clct0_vpf          ";
                ch[ 5].nbits = 1;	ch[ 5].bit = 0;	ch[ 5].tag="clct1_vpf          ";
                ch[ 6].nbits = 1;	ch[ 6].bit = 0;	ch[ 6].tag="alct0_vpf          ";
                ch[ 7].nbits = 1;	ch[ 7].bit = 0;	ch[ 7].tag="alct1_vpf          ";
                ch[ 8].nbits = 1;	ch[ 8].bit = 0;	ch[ 8].tag="clct_window        ";
                ch[ 9].nbits = 1;	ch[ 9].bit = 0;	ch[ 9].tag="wr_push_rtmb       ";

                ch[10].nbits = 1;	ch[10].bit = 0;	ch[10].tag="tmb_push_dly       ";
                ch[11].nbits = 1;	ch[11].bit = 0;	ch[11].tag="l1a_pulse          ";
                ch[12].nbits = 1;	ch[12].bit = 0;	ch[12].tag="l1a_window_open    ";
                ch[13].nbits = 1;	ch[13].bit = 0;	ch[13].tag="l1a_push_me        ";

                ch[14].nbits = 1;	ch[14].bit = 0;	ch[14].tag="tmb_special        ";
                ch[15].nbits = 1;	ch[15].bit = 0;	ch[15].tag="ddu_special        ";

                scp_first_pass=false;
            }

            //------------------------------------------------------------------------------
            //	Display
            //------------------------------------------------------------------------------
            fprintf(stdout,"\n");
            ndisp = std::min(ntbins,MXTBINS);
            tb0   = (skip_1st_tbin) ? 1:0;

            // Display tbin numbers or x if 1st channel blanked
            for (irow =0; irow <=1;       ++irow ) {
                fprintf(stdout,"                          ");
                for (itbin=tb0; itbin<=ndisp-1; ++itbin) {
                    if  (irow==0) it = itbin/16;
                    else          it = itbin%16;
                    fprintf(stdout,"%X",it);
                }	// close itbin
                fprintf(stdout,"\n");
            }	// close irow

            // Construct waveform
            for (ich=0;     ich  <=NCHANNELS-1; ++ich)	{		// Loop over scope channels
                for (itbin=tb0; itbin<=ndisp-1;     ++itbin)	{		// Time bins per channel

                    // Construct binary waveforms for single-bit channels	
                    ibit=(miniscope_data[itbin] >> (ich % 16)) & 0x1;	// Logic levels vs tbin for this channel
                    if(ibit==0) scope_ch[itbin]='_';					// Display symbol for logic 0					
                    if(ibit==1) scope_ch[itbin]='-';					// Display symbol for logic 1	

                    // Build integer for special channel groups
                    if (ch[ich].nbits > 1) {
                        if (ch[ich].bit == 0) ihex[itbin]=0;
                        ihex[itbin] = ihex[itbin] | (ibit << ch[ich].bit);
                    }
                } //close itbin

                // Display binary waveforms
                chblank=(ch[ich].nbits!=1) && !DISP_ALL;		// Dont display channels that are hex digits

                if(!chblank) {
                    fprintf(stdout,"ch%3.2i  %s",ich,ch[ich].tag.c_str());
                    for(itbin=tb0;itbin<ndisp;++itbin) fprintf(stdout,"%c",scope_ch[itbin]);
                    fprintf(stdout,"\n");
                }

                // Display hex integers for special channel groups
                if (ch[ich].nbits > 1) {
                    last_bit=(ch[ich].nbits == (ch[ich].bit + 1));
                    if (last_bit) {
                        ndigits=(ch[ich].nbits+3)/4;
                        for (idigit=ndigits-1; idigit>=0; --idigit) {
                            fprintf(stdout,"ch%3.2i  %s",ich,ch[ich].tag.c_str());
                            for(itbin=tb0;itbin<ndisp;++itbin) fprintf(stdout,"%1.1X",(ihex[itbin] >> (4*idigit)) & 0xF);
                            fprintf(stdout,"\n");
                        }}}

                        // Display machine state ascii
                        if(ich==3) {
                            fprintf(stdout,"ch%3.2i  %s",ich,ch[ich].tag.c_str());
                            for(itbin=tb0;itbin<ndisp;++itbin) fprintf(stdout,"%c",state[ihex[itbin]]);
                            fprintf(stdout,"\n");
                        }	// close if ich
            }	// close ich

            fprintf(stdout,"\n");
            return;
        } //close miniscope16()


        //------------------------------------------------------------------------------
        //	CLCT Pattern Unit Emulator
        //
        //	Finds:	  Best matching pattern template and number of layers hit on that pattern for 1 key 1/2-strip
        //	Returns:  Best matching pattern template ID, and number of hits on the pattern
        //
        //	03/30/10 Initial translation from verilog
        //	09/07/10 Mod for vs2008
        //------------------------------------------------------------------------------

        void TMB::pattern_unit (
                int ly0[], int ly1[], int ly2[], int ly3[], int ly4[], int ly5[], // Inputs
                int &pat_nhits, int &pat_id) // Outputs
        {
            A=10;

            //------------------------------------------------------------------------------
            // Local
            //------------------------------------------------------------------------------

            const int	MXLY	= 6;			// Number of CSC layers
            const int	MXPID	= 0xA+1;		// Number of patterns
            int			pat[MXPID][MXLY];
            int			nhits_array[MXPID];

            int			nhits_s3;
            int			pid_s3;
            int			pid;


#ifdef debug
            int i;
            printf(stdout,"\n");
            printf(stdout,"dbg: pattern_unit:\n");
            printf(stdout,"dbg: hs ="); for (i=0; i<=0xA; ++i) printf(stdout,"%1X",i     ); printf(stdout,"\n");
            printf(stdout,"dbg: ly0="); for (i=0; i<=0xA; ++i) printf(stdout,"%1i",ly0[i]); printf(stdout,"\n");
            printf(stdout,"dbg: ly1="); for (i=0; i<=0xA; ++i) printf(stdout,"%1i",ly1[i]); printf(stdout,"\n");
            printf(stdout,"dbg: ly2="); for (i=0; i<=0xA; ++i) printf(stdout,"%1i",ly2[i]); printf(stdout,"\n");
            printf(stdout,"dbg: ly3="); for (i=0; i<=0xA; ++i) printf(stdout,"%1i",ly3[i]); printf(stdout,"\n");
            printf(stdout,"dbg: ly4="); for (i=0; i<=0xA; ++i) printf(stdout,"%1i",ly4[i]); printf(stdout,"\n");
            printf(stdout,"dbg: ly5="); for (i=0; i<=0xA; ++i) printf(stdout,"%1i",ly5[i]); printf(stdout,"\n");
#endif

            //------------------------------------------------------------------------------------------------------------------------
            // Finds best 1-of-9 1/2-strip patterns for 1 key 1/2-strip 
            // Returns pattern number 2-10 and number of layers hit on that pattern 0-6.
            // Pattern LSB = bend direction
            // Hit pattern LUTs for 1 layer: - = don't care, xx= one hit or the other or both
            //
            // Pattern Templates:
            //
            // Pattern       id=2        id=3        id=4        id=5        id=6        id=7        id=8        id=9        idA
            // Bend dir      bd=0        bd=1        bd=0        bd=1        bd=0        bd=1        bd=0        bd=1        bd=0
            //               |           |           |           |           |           |           |           |           |
            // ly0      --------xxx xxx-------- -------xxx- -xxx------- ------xxx-- --xxx------ -----xxx--- ---xxx----- ----xxx----
            // ly1      ------xx--- ---xx------ ------xx--- ---xx------ -----xx---- ----xx----- -----xx---- ----xx----- -----x-----
            // ly2 key  -----x----- -----x----- -----x----- -----x----- -----x----- -----x----- -----x----- -----x----- -----x-----
            // ly3      ---xxx----- -----xxx--- ---xx------ ------xx--- ----xx----- -----xx---- ----xx----- -----xx---- -----x-----
            // ly4      -xxx------- -------xxx- -xxx------- -------xxx- ---xx------ ------xx--- ---xxx----- -----xxx--- ----xxx----
            // ly5      xxx-------- --------xxx -xxx------- -------xxx- --xxx------ ------xxx-- ---xxx----- -----xxx--- ----xxx----
            //               |           |           |           |           |           |           |           |           |
            // Extent   0123456789A 0123456789A 0123456789A 0123456789A 0123456789A 0123456789A 0123456789A 0123456789A 0123456789A
            // Avg.bend - 8.0 hs    + 8.0 hs    -6.0 hs     +6.0 hs     -4.0 hs     +4.0 hs     -2.0 hs     +2.0 hs      0.0 hs
            // Min.bend -10.0 hs    + 6.0 hs    -8.0 hs     +4.0 hs     -6.0 hs     +2.0 hs     -4.0 hs      0.0 hs     -1.0 hs
            // Max.bend - 6.0 hs    +10.0 hs    -4.0 hs     +8.0 hs     -2.0 hs     +6.0 hs      0.0 hs     +4.0 hs     +1.0 hs
            //------------------------------------------------------------------------------------------------------------------------
            // Pattern A								       0123456789A
            pat[A][0] = ly0[4]|ly0[5]|ly0[6];		// ly0 ----xxx----
            pat[A][1] =        ly1[5];				// ly1 -----x-----
            pat[A][2] =        ly2[5];				// ly2 -----x-----
            pat[A][3] =        ly3[5];				// ly3 -----x-----
            pat[A][4] = ly4[4]|ly4[5]|ly4[6];		// ly4 ----xxx---
            pat[A][5] = ly5[4]|ly5[5]|ly5[6];		// ly5 ----xxx---

            // Pattern 9										       0123456789A
            pat[9][0] = ly0[3]|ly0[4]|ly0[5];				// ly0 ---xxx-----
            pat[9][1] =        ly1[4]|ly1[5];				// ly1 ----xx-----
            pat[9][2] =               ly2[5];				// ly2 -----x-----
            pat[9][3] =               ly3[5]|ly3[6];		// ly3 -----xx----
            pat[9][4] =               ly4[5]|ly4[6]|ly4[7];	// ly4 -----xxx---
            pat[9][5] =               ly5[5]|ly5[6]|ly5[7];	// ly5 -----xxx---

            // Pattern 8										       0123456789A
            pat[8][0] =               ly0[5]|ly0[6]|ly0[7];	// ly0 -----xxx---
            pat[8][1] =               ly1[5]|ly1[6];		// ly1 -----xx----
            pat[8][2] =               ly2[5];				// ly2 -----x-----
            pat[8][3] =        ly3[4]|ly3[5];				// ly3 ----xx-----
            pat[8][4] = ly4[3]|ly4[4]|ly4[5];				// ly4 ---xxx-----
            pat[8][5] = ly5[3]|ly5[4]|ly5[5];				// ly5 ---xxx-----

            // Pattern 7														       0123456789A
            pat[7][0] = ly0[2]|ly0[3]|ly0[4];								// ly0 --xxx------
            pat[7][1] =               ly1[4]|ly1[5];						// ly1 ----xx-----
            pat[7][2] =                      ly2[5];						// ly2 -----x-----
            pat[7][3] =                      ly3[5]|ly3[6];					// ly3 -----xx----
            pat[7][4] =                             ly4[6]|ly4[7];			// ly4 ------xx---
            pat[7][5] =                             ly5[6]|ly5[7]|ly5[8];	// ly5 ------xxx--

            // Pattern 6														       0123456789A
            pat[6][0] =                             ly0[6]|ly0[7]|ly0[8];	// ly0 ------xxx--
            pat[6][1] =                      ly1[5]|ly1[6];					// ly1 -----xx----
            pat[6][2] =                      ly2[5];						// ly2 -----x-----
            pat[6][3] =               ly3[4]|ly3[5];						// ly3 ----xx-----
            pat[6][4] =        ly4[3]|ly4[4];								// ly4 ---xx------
            pat[6][5] = ly5[2]|ly5[3]|ly5[4];								// ly5 --xxx------

            // Pattern 5																	       0123456789A
            pat[5][0] = ly0[1]|ly0[2]|ly0[3];											// ly0 -xxx-------
            pat[5][1] =               ly1[3]|ly1[4];									// ly1 ---xx------
            pat[5][2] =                             ly2[5];								// ly2 -----x-----
            pat[5][3] =                                    ly3[6]|ly3[7];				// ly3 ------xx---
            pat[5][4] =                                           ly4[7]|ly4[8]|ly4[9];	// ly4 -------xxx-
            pat[5][5] =                                           ly5[7]|ly5[8]|ly5[9];	// ly5 -------xxx-

            // Pattern 4																	       0123456789A
            pat[4][0] =                                            ly0[7]|ly0[8]|ly0[9];// ly0 -------xxx-
            pat[4][1] =                                     ly1[6]|ly1[7];				// ly1 ------xx---
            pat[4][2] =                              ly2[5];							// ly2 -----x-----
            pat[4][3] =               ly3[3]|ly3[4];									// ly3 ---xx------
            pat[4][4] = ly4[1]|ly4[2]|ly4[3];											// ly4 -xxx-------
            pat[4][5] = ly5[1]|ly5[2]|ly5[3];											// ly5 -xxx-------

            // Pattern 3																					       0123456789A
            pat[3][0] = ly0[0]|ly0[1]|ly0[2];															// ly0 xxx--------
            pat[3][1] =                      ly1[3]|ly1[4];												// ly1 ---xx------
            pat[3][2] =                                    ly2[5];										// ly2 -----x-----
            pat[3][3] =                                    ly3[5]|ly3[6]|ly3[7];						// ly3 -----xxx---
            pat[3][4] =                                                  ly4[7]|ly4[8]|ly4[9];			// ly4 -------xxx-
            pat[3][5] =                                                         ly5[8]|ly5[9]|ly5[A];	// ly5 --------xxx

            // Pattern 2																					       0123456789A
            pat[2][0] =                                                         ly0[8]|ly0[9]|ly0[A];	// ly0 --------xxx
            pat[2][1] =                                           ly1[6]|ly1[7];						// ly1 ------xx---
            pat[2][2] =                                    ly2[5];										// ly2 -----x-----
            pat[2][3] =                      ly3[3]|ly3[4]|ly3[5];										// ly3 ---xxx-----
            pat[2][4] =        ly4[1]|ly4[2]|ly4[3];													// ly4 -xxx-------
            pat[2][5] = ly5[0]|ly5[1]|ly5[2];															// ly5 xxx--------

            // Count number of layers hit for each pattern
            for (pid=0x2; pid<=0xA; ++pid) {
                nhits_array[pid] = count1s(pat[pid]);
#ifdef debug
                printf(stdout,"dbg: pid=%1X nhits=%1i\n",pid,nhits_array[pid]);
#endif
            }

            // Best 1 of 8 Priority Encoder, perfers higher pattern number if hits are equal
            nhits_s3 = 0;
            pid_s3   = 0;

            for (pid=0x2; pid<=0xA; ++ pid) {
                if (nhits_array[pid]>=nhits_s3)
                    nhits_s3 = nhits_array[pid];
                pid_s3   = pid;
            }

            // Add 2 to pid to shift to range 2-10, not needed in c++ version
            pat_nhits = nhits_s3;
            pat_id	  = pid_s3;

            return;
        }
        //------------------------------------------------------------------------------------------
        // End pattern_unit
        //------------------------------------------------------------------------------------------

        //------------------------------------------------------------------------------
        // vme_write:  Writes wr_data to adr 
        //------------------------------------------------------------------------------
        int TMB::vme_write(unsigned long &adr, unsigned short &wr_data) {
            int reg = static_cast<int>(adr);                    //typecast long adr to int
            int value = static_cast<int>(wr_data);              //typecast short wr_data to int
            WriteRegister(reg, value);                      //write to VME register using emuLib native 
            return EXIT_SUCCESS;
        }

        //------------------------------------------------------------------------------
        // vme_read: reads rd_data from adr
        //------------------------------------------------------------------------------
        int TMB::vme_read(unsigned long &adr, unsigned short &rd_data) {
            int reg = static_cast<int>(adr);                    //typecast long adr to int
            rd_data = (unsigned short) TMB::ReadRegister(reg);  //read VME register using emuLib 
            return EXIT_SUCCESS;
        }

        //------------------------------------------------------------------------------
        // End Trigger Tests 
        //------------------------------------------------------------------------------

        int TMB::tmb_read_delays(int device) {

            int data=0;

            // device = 0  = CFEB 0 Clock
            //        = 1  = CFEB 1 clock
            //        = 2  = CFEB 2 clock
            //        = 3  = CFEB 3 clock
            //        = 4  = CFEB 4 clock
            //        = 5  = ALCT rx clock
            //        = 6  = ALCT tx clock
            //        = 7  = DMB tx clock
            //        = 8  = RAT clock
            //        = 9  = TMB1 clock
            //        = 10 = MPC clock
            //        = 11 = DCC clock (CFEB duty cycle correction)
            //        = 12 = RPC 0 clock
            //        = 13 = RPC 1 clock

            if (device==0) data = (ReadRegister(vme_ddd1_adr)>>12) & 0xf; 
            if (device==1) data = (ReadRegister(vme_ddd2_adr)>> 0) & 0xf; 
            if (device==2) data = (ReadRegister(vme_ddd2_adr)>> 4) & 0xf; 
            if (device==3) data = (ReadRegister(vme_ddd2_adr)>> 8) & 0xf; 
            if (device==4) data = (ReadRegister(vme_ddd2_adr)>>12) & 0xf; 
            if (device==5) data = (ReadRegister(vme_ddd0_adr)>> 4) & 0xf; 
            if (device==6) data = (ReadRegister(vme_ddd0_adr)>> 0) & 0xf; 
            if (device==7) data = (ReadRegister(vme_ddd0_adr)>> 8) & 0xf; 
            if (device==8) data = (ReadRegister(vme_ddd0_adr)>>12) & 0xf; 
            if (device==9) data = (ReadRegister(vme_ddd1_adr)>> 0) & 0xf; 
            if (device==10) data =(ReadRegister(vme_ddd1_adr)>> 4) & 0xf; 
            if (device==11) data =(ReadRegister(vme_ddd1_adr)>> 8) & 0xf; 
            if (device==12) data =(ReadRegister(rat_3d_delays_adr)>> 0) & 0xf; 
            if (device==13) data =(ReadRegister(rat_3d_delays_adr)>> 4) & 0xf; 

            return data;
        }

        void TMB::new_clk_delays(unsigned short int time,int device)
        {
            // device = 0  = CFEB 0 Clock
            //        = 1  = CFEB 1 clock
            //        = 2  = CFEB 2 clock
            //        = 3  = CFEB 3 clock
            //        = 4  = CFEB 4 clock
            //        = 5  = ALCT TOF clock delay
            //        = 7  = DMB tx clock
            //        = 8  = RAT clock
            //        = 9  = TMB1 clock
            //        = 10 = MPC clock
            //        = 11 = DCC clock (CFEB duty cycle correction)
            //        = 12 = RPC 0 clock
            //        = 13 = RPC 1 clock
            //        = 1000 = CFEB [0-5] Clock (all CFEB's)
            //
            //printf(" here write to delay registers \n");
            //
            if ( device == 0 ) {
                SetCfeb0TOFDelay(time);
                WriteRegister(vme_ddd1_adr);
            } 
            if ( device == 1 ) {
                SetCfeb1TOFDelay(time);
                WriteRegister(vme_ddd2_adr);
            } 
            if ( device == 2 ) {
                SetCfeb2TOFDelay(time);
                WriteRegister(vme_ddd2_adr);
            } 
            if ( device == 3 ) {
                SetCfeb3TOFDelay(time);
                WriteRegister(vme_ddd2_adr);
            } 
            if ( device == 4 ) {
                SetCfeb4TOFDelay(time);
                WriteRegister(vme_ddd2_adr);
            } 
            if ( device == 5 ) {
                SetAlctTOFDelay(time);
                WriteRegister(vme_ddd0_adr);
            } 
            if ( device == 7 ) {
                SetDmbTxDelay(time);
                WriteRegister(vme_ddd0_adr);
            } 
            if ( device == 8 ) {
                SetRatTmbDelay(time);
                WriteRegister(vme_ddd0_adr);
            } 
            if ( device == 9 ) {
                SetTmb1Phase(time);
                WriteRegister(vme_ddd1_adr);
            } 
            if ( device == 12 ) {
                SetRpc0RatDelay(time);
                WriteRegister(rat_3d_delays_adr);
            } 
            if ( device == 1000 ) {
                SetCfeb0TOFDelay(time);
                WriteRegister(vme_ddd1_adr);
                //
                SetCfeb1TOFDelay(time);
                SetCfeb2TOFDelay(time);
                SetCfeb3TOFDelay(time);
                SetCfeb4TOFDelay(time);
                WriteRegister(vme_ddd2_adr);
            } 
            //
            FireDDDStateMachine();
            //
            return;
        }
        //
        void TMB::FireDDDStateMachine() {
            //
            // The values for the DDD delay chips have already been set.  Fire the state machine
            // to set the values correctly.
            //
            // Start and stop 3d3444 state machine 
            WriteRegister(vme_dddsm_adr,0x20);
            WriteRegister(vme_dddsm_adr,0x21);
            WriteRegister(vme_dddsm_adr,0x20);
            //
            ReadRegister(vme_dddsm_adr);
            //
            int iloop = 0;
            //
            while ( read_ddd_state_machine_busy_ == 1 ) {
                //
                if (debug_) PrintTMBRegister(vme_dddsm_adr);
                //
                ReadRegister(vme_dddsm_adr);
                //
                iloop++;
                if(iloop>10){
                    std::cout << " tmb_clk_delays: DDD state machine busy so quit" << std::endl;
                    return;
                }
            }
            //
            //
            ReadRegister(vme_dddsm_adr);
            //
            if( read_ddd_state_machine_verify_ok_ != 1){
                PrintTMBRegister(vme_dddsm_adr);
                std::cout << " tmb_clk_delays: something is wrong. Can NOT be verified" << std::endl;
            }
            //
            return;
        }

        void TMB::ExtClctTrigFromCCBonly() {

            (*MyOutput_) << "Enable CLCT external trigger from TTC (through CCB)" << std::endl;

            int data = ReadRegister(seq_trig_en_adr);

            (*MyOutput_) << "TMB Sequencer trigger source before = " << std::hex << data << std::endl;

            data = 0x0020;                                 //allow CLCT external triggers from CCB

            WriteRegister(seq_trig_en_adr,data);

            data = ReadRegister(seq_trig_en_adr);

            (*MyOutput_) << "TMB Sequencer trigger source after = " << std::hex << data << std::endl;

            return;
        }
        /////////////////////////////////////////////////////////////////////
        // hot channel masks and comparator badbits registers
        /////////////////////////////////////////////////////////////////////
        void TMB::SetDistripHotChannelMask(int layer,long long int mask) {
            //
            // mask=10-hex characters for the 40 distrips right->left LSB->MSB.  
            // So, to mask off channel 0, mask= 0xfffffffffe
            //
            mask &= 0x000000ffffffffffLL;  //clean mask before processing
            //
            if (debug_) 
                std::cout << "TMB: Setting Distrip hot channel mask for Layer " << std::dec << layer 
                    << " (LSB->MSB right->left): " << std::hex << mask << std::endl;
            //
            for (int channel=39; channel>=0; channel--) {
                int on_or_off = (mask >> channel) & 0x1;
                //
                if (debug_) {
                    std::cout << on_or_off;
                    if ((channel%4) == 0) std::cout << " ";
                }
                //
                SetDistripHotChannelMask(layer,channel,on_or_off);
            }
            if (debug_) 
                std::cout << std::endl;
            //
            return;
        }
        //
        long long int TMB::GetDistripHotChannelMask(int layer) {
            //
            // return value = 10-hex characters for the 40 distrips right->left LSB->MSB.  
            // If channel 0 is off: return = 0xfffffffffe
            //
            // There must be a cleaner way to do this... but it is working so I leave it alone...
            //
            // split it into upper and lower bits because going to ulong will result in an exception, below...
            std::bitset<20> msb_mask;  
            std::bitset<20> lsb_mask;  
            //
            if (debug_)
                std::cout << "TMB: Getting Distrip hot channel mask for Layer " << std::dec << layer 
                    << " (LSB->MSB right->left): ";
            //
            for (int channel=39; channel>=20; channel--) {
                int msb_index = channel - 20;
                msb_mask.set(msb_index, (GetDistripHotChannelMask(layer,channel)==1) );
            }
            //
            for (int channel=19; channel>=0; channel--) 
                lsb_mask.set(channel, (GetDistripHotChannelMask(layer,channel)==1) );
            //
            int highest = (msb_mask.to_ulong() & 0x000fffff);
            int lowest =  (lsb_mask.to_ulong() & 0x000fffff);
            //
            // have to cast both parts of this mask in order to make it work...
            long long int mask;
            mask = ((long long) lowest | ((long long) highest << 20));
            //
            if (debug_) {
                std::cout << msb_mask << " " << lsb_mask << std::endl;
                std::cout << " = 0x" << std::hex << highest << lowest << " = 0x" << mask << std::endl;
            }
            //
            return mask;
        }
        //
        void TMB::WriteDistripHotChannelMasks(){
            //
            WriteRegister(hcm001_adr);
            WriteRegister(hcm023_adr); 
            WriteRegister(hcm045_adr); 
            WriteRegister(hcm101_adr); 
            WriteRegister(hcm123_adr); 
            WriteRegister(hcm145_adr); 
            WriteRegister(hcm201_adr); 
            WriteRegister(hcm223_adr); 
            WriteRegister(hcm245_adr); 
            WriteRegister(hcm301_adr); 
            WriteRegister(hcm323_adr); 
            WriteRegister(hcm345_adr); 
            WriteRegister(hcm401_adr); 
            WriteRegister(hcm423_adr); 
            WriteRegister(hcm445_adr); 
            //
            return;
        }
        //
        void TMB::ReadDistripHotChannelMasks(){
            //
            ReadRegister(hcm001_adr);
            ReadRegister(hcm023_adr); 
            ReadRegister(hcm045_adr); 
            ReadRegister(hcm101_adr); 
            ReadRegister(hcm123_adr); 
            ReadRegister(hcm145_adr); 
            ReadRegister(hcm201_adr); 
            ReadRegister(hcm223_adr); 
            ReadRegister(hcm245_adr); 
            ReadRegister(hcm301_adr); 
            ReadRegister(hcm323_adr); 
            ReadRegister(hcm345_adr); 
            ReadRegister(hcm401_adr); 
            ReadRegister(hcm423_adr); 
            ReadRegister(hcm445_adr); 
            //
            return;
        }
        //
        void TMB::SetCFEBBadBitsReset(int cfeb_badbits_reset) {
            //
            // set the reset bit for all 5 CFEB's..
            //.
            cfeb_badbits_reset_ = 0;
            for (int cfeb=0; cfeb<5; cfeb++) 
                cfeb_badbits_reset_ |= (cfeb_badbits_reset & 0x1) << cfeb;
            //
            return;
        }
        //
        int TMB::GetCFEBBadBitsReset() {
            //
            // return a single value which has been set for all 5 CFEB's..
            //
            int return_value = 1;
            for (int cfeb=0; cfeb<5; cfeb++) 
                return_value &= (cfeb_badbits_reset_ >> cfeb) & 0x1;
            //
            return return_value;
        }
        //
        int TMB::GetReadCFEBBadBitsReset() {
            //
            // return a single value which has been set for all 5 CFEB's..
            //
            int return_value = 1;
            for (int cfeb=0; cfeb<5; cfeb++) 
                return_value &= (read_cfeb_badbits_reset_ >> cfeb) & 0x1;
            //
            return return_value;
        }
        //
        void TMB::SetCFEBBadBitsBlock(int cfeb_badbits_block) {
            //
            // set the block bit for all 5 CFEB's..
            //.
            cfeb_badbits_block_ = 0;
            for (int cfeb=0; cfeb<5; cfeb++) 
                cfeb_badbits_block_ |= (cfeb_badbits_block & 0x1) << cfeb;
            //
            return;
        }
        //
        int TMB::GetCFEBBadBitsBlock() {
            //
            // return a single value which has been set for all 5 CFEB's..
            //
            //  std::cout << "In software, CFEB Bad Bits Block = 0x" << cfeb_badbits_block_<< std::endl;
            int return_value = 1;
            for (int cfeb=0; cfeb<5; cfeb++) {
                return_value &= (cfeb_badbits_block_ >> cfeb) & 0x1;
                //    std::cout << "after bit " << cfeb << "... return value = " << return_value << std::endl;
            }
            //
            return return_value;
        }
        //
        int TMB::GetReadCFEBBadBitsBlock() {
            //
            // return a single value which has been set for all 5 CFEB's..
            //
            //  std::cout << "Read CFEB Bad Bits Block = 0x" << read_cfeb_badbits_block_<< std::endl;
            int return_value = 1;
            for (int cfeb=0; cfeb<5; cfeb++) {
                return_value &= (read_cfeb_badbits_block_ >> cfeb) & 0x1;
                //    std::cout << "after bit " << cfeb << "... return value = " << return_value << std::endl;
            }
            //
            return return_value;
        }
        //
        void TMB::ReadComparatorBadBits(){
            //
            ReadRegister(badbits001_adr);
            ReadRegister(badbits023_adr); 
            ReadRegister(badbits045_adr); 
            ReadRegister(badbits101_adr); 
            ReadRegister(badbits123_adr); 
            ReadRegister(badbits145_adr); 
            ReadRegister(badbits201_adr); 
            ReadRegister(badbits223_adr); 
            ReadRegister(badbits245_adr); 
            ReadRegister(badbits301_adr); 
            ReadRegister(badbits323_adr); 
            ReadRegister(badbits345_adr); 
            ReadRegister(badbits401_adr); 
            ReadRegister(badbits423_adr); 
            ReadRegister(badbits445_adr); 
            //
            return;
        }
        //
        ////////////////////////////////////////////////////////
        // Digital Serial Numbers
        ////////////////////////////////////////////////////////
        std::bitset<64> TMB::dsnRead(int type) {
            //type = 0 = TMB
            //     = 1 = Mezzanine DSN
            //     = 2 = RAT DSN
            //
            std::bitset<64> dsn;
            //
            int offset;
            offset = type*5; 
            //
            int wr_data, rd_data;
            //
            int initial_state=0;
            // ** need to specifically enable RAT to read back DSN **
            if (type == 2) {  
                initial_state = ReadRegister(vme_ratctrl_adr);  //initial RAT state
                //
                wr_data = initial_state & 0xfffd;    //0=sync_mode, 1=posneg, 2=loop_tmb, 3=free_tx0, 4=dsn enable
                wr_data |= 0x0010;                   //enable the dsn bit
                //
                WriteRegister(vme_ratctrl_adr,wr_data);
            }
            //
            // init pulse >480usec
            wr_data = 0x0005; 
            wr_data <<= offset; //send it to correct component
            rd_data = dsnIO(wr_data);
            //
            // ROM Read command = serial 0x33:
            for (int i=0; i<=7; i++) {
                int idata = (0x33>>i) & 0x1;
                wr_data = (idata<<1) | 0x1; //send "serial write pulse" with "serial SM start"
                wr_data <<= offset; 
                rd_data = dsnIO(wr_data);
            }
            //
            // Read 64 bits of ROM data = 0x3 64 times
            for (int i=0; i<=63; i++) {
                wr_data = 0x0003; 
                wr_data <<= offset;
                rd_data = dsnIO(wr_data);
                //
                // pack data into dsn[]
                dsn[i] = (rd_data >> (4+offset)) & 0x1;
            }
            //
            // ** Return the RAT to its initial state **
            if (type == 2) 
                WriteRegister(vme_ratctrl_adr,initial_state);
            //
            return dsn;
        }
        //
        int TMB::dsnIO(int writeData){
            //Single I/O cycle for Digital Serial Number...
            //called by dsnRead...
            //
            int readData;
            //
            // write the desired data word:
            WriteRegister(vme_dsn_adr,writeData);
            //
            int tmb_busy,mez_busy,rat_busy;
            int busy = 1;
            int nbusy = 1;
            //
            while (busy && nbusy<101) {
                readData = ReadRegister(vme_dsn_adr);
                //
                // check busy on all components:
                tmb_busy = (readData>>3) & 0x1;
                mez_busy = (readData>>8) & 0x1;
                rat_busy = (readData>>13) & 0x1;
                busy = tmb_busy | mez_busy | rat_busy;
                //
                if (nbusy%10 == 0) {
                    (*MyOutput_) << "dsnIO: DSN state machine busy, nbusy = "
                        << nbusy << ", readData = " 
                        << std::hex << readData << std::dec << std::endl;  
                }
                nbusy++;
                udelay(20);
            }
            //
            // end previous cycle
            WriteRegister(vme_dsn_adr,0x0000);
            //
            return readData;
        }
        //
        ////////////////////////////////////////////////////////////////////////////
        // read on-board Voltages and temperatures
        ////////////////////////////////////////////////////////////////////////////
        void TMB::ADCvoltages() { 
            //
            // user can use this method and then the getters for the different
            // values (5.0V, 5.0 current, etc.) for the ADC readings...
            //
            float adc_voltage[13] = {};
            ADCvoltages(adc_voltage);
            return;
        }
        //
        void TMB::ADCvoltages(float * voltage){
            //
            //Read the ADC of the voltage values ->
            //voltage[0] = +5.0V TMB
            //       [1] = +3.3V TMB; for 2013 OTMB baseboard, this is "MEZ +3.3V"
            //       [2] = +1.5V core
            //       [3] = +1.5V TT
            //       [4] = +1.0V TT
            //       [5] = +5.0V Current (A) TMB
            //       [6] = +3.3V Current (A) TMB
            //       [7] = +1.5V core Current (A) TMB
            //       [8] = +1.5V TT Current (A) TMB; for 2013 OTMB baseboard, this is "TMB+RAT 3.3V"
            //       [9] = if SH921 set 1-2, +1.8V RAT current (A)
            //           = if SH921 set 2-3, +3.3V RAT
            //      [10] = +1.8V RAT core
            //      [11] = reference Voltage * 0.5
            //      [12] = ground (0V)
            //      [13] = reference voltage (= ADC maximized)
            //      [14] = COMMAND:  ADC power down
            //
            for (int chip=0; chip<15; chip++) {
                //
                int adc_data = 0;
                //
                // Force a transition from ChipSelect= 1 -> 0 in order to tell the ADC you are going to set a chip address
                SetVoltageADCDataIn(0);
                SetVoltageADCSerialClock(0);
                SetVoltageADCChipSelect(1);
                WriteRegister(vme_adc_adr);
                udelay(100);
                //
                SetVoltageADCChipSelect(0);
                //
                // Clock in the address for a chip at the same time you clock out the data from the previous chip (d[11:8]=address)
                int twelve_bit_address = 0x000 | (chip << 8);  
                //
                // ... for the 14th loop (to get the 13th chip's data), don't clock in "14," because this is the ADC power off command
                if (chip==14) twelve_bit_address = 0; 
                //
                for (int iclk=0; iclk<12; iclk++){
                    int data_in = (twelve_bit_address >> (11-iclk)) & 0x1; //clock in the chip address most-significant bit first
                    SetVoltageADCDataIn(data_in);                          
                    //
                    SetVoltageADCSerialClock(0);   
                    WriteRegister(vme_adc_adr);
                    SetVoltageADCSerialClock(1);   
                    WriteRegister(vme_adc_adr);
                    //
                    ReadRegister(vme_adc_adr);     //the data (from the previous chip) has been clocked out.  Retrieve it.
                    adc_data |= (GetReadVoltageADCDataOut() << (11-iclk));  // pack the data into a 12 bit ADC value
                }
                //
                if (chip>0) 
                    voltage[chip-1] = ((float) adc_data / 4095.)*4.095; //convert adc value to volts
                //
            }
            //
            // don't leave the chip selection set to 0
            SetVoltageADCDataIn(0);
            SetVoltageADCSerialClock(0);
            SetVoltageADCChipSelect(1);
            WriteRegister(vme_adc_adr);
            //
            voltage[0] *= 2.0;                      // 1V/2V
            voltage[5] /= 0.2;                      // 200mV/Amp
            voltage[6] /= 0.2;                      // 200mV/Amp
            voltage[7] /= 0.2;                      // 200mV/Amp
            voltage[8] /= 0.2;                      // 200mV/Amp
            voltage[9] /= 0.2;                      // 200mV/Amp if SH921 set 1-2, else comment out line
            //
            v5p0_	    = voltage[0];	      
            v3p3_	    = voltage[1];
            v1p5core_ = voltage[2];
            v1p5tt_   = voltage[3];
            v1p0_	    = voltage[4];
            a5p0_	    = voltage[5];	      
            a3p3_	    = voltage[6];
            a1p5core_ = voltage[7];
            a1p5tt_   = voltage[8];
            a1p8rat_  = voltage[9];	        // if SH921 set 1-2, loop backplane sends 1.500vtt
            //v3p3rat_= voltage[9];	// if SH921 set 2-3
            v1p8rat_  = voltage[10];
            vref2_    = voltage[11];
            vzero_    = voltage[12];
            vref_     = voltage[13];
            //
            return;
        }
        //
        int TMB::ReadTMBtempPCB() {
            //
            int smb_adr = 0x2a;   // float, float state TMB LM84 chip address
            int command = 0x00;   // "local" temperature read
            int temperature = smb_io(smb_adr,command,1);
            //
            (*MyOutput_) << "TMB temperature (PCB)                 = " << std::dec << temperature
                << " deg C " << std::endl;
            //
            return temperature;
        }
        //
        int TMB::ReadTMBtempFPGA() {
            //
            int smb_adr = 0x2a;   // float, float state TMB LM84 chip address
            int command = 0x01;   // "remote" temperature read
            int temperature = smb_io(smb_adr,command,1);
            //
            (*MyOutput_) << "TMB temperature IC (FPGA)             = " << std::dec << temperature
                << " deg C " << std::endl;
            //
            return temperature;
        }
        //
        int TMB::ReadTMBtCritPCB() {
            //
            int smb_adr = 0x2a;   // float, float state TMB LM84 chip address
            int command = 0x05;   // "local" temperature critical read
            int temperature = smb_io(smb_adr,command,1);
            //
            (*MyOutput_) << "TMB Critical Temperature IC (PCB)     = " << std::dec << temperature
                << " deg C " << std::endl;
            //
            return temperature;
        }
        //
        int TMB::ReadTMBtCritFPGA() {
            //
            int smb_adr = 0x2a;   // float, float state TMB LM84 chip address
            int command = 0x07;   // "remote" temperature critical read
            int temperature = smb_io(smb_adr,command,1);
            //
            (*MyOutput_) << "TMB Critical Temperature (FPGA)       = " << std::dec << temperature
                << " deg C " << std::endl;
            //
            return temperature;
        }
        //
        int TMB::smb_io(int smb_adr, int cmd, int module) {
            //	Generates SMB serial clock and data streams to TMB LM84 chip
            //
            //   -> Returns temperature values in Celcius <-
            //
            //    smb_adr = 0x2a = float, float state TMB LM84 chip address
            //            = 0x18 = gnd, gnd state RAT LM84 chip address
            //
            //    cmd = 0x00 = local temperature command
            //        = 0x01 = remote temperature command
            //        = 0x05 = local tcrit command  
            //        = 0x07 = remote tcrit command  
            //
            //    module = 1 = TMB
            //           = 2 = RAT
            //
            const int adc_adr = vme_adc_adr;
            //
            int smb_data = 0xff;        // null write command
            //
            int write_data,read_data;
            //
            // Current ADC register state:
            int adc_status = ReadRegister(adc_adr);
            //
            // **Step 1 write the command to read the data**
            //
            // ** initialize SMB data stream **
            int sda_bit[29];
            sda_bit[0] = 0;                                // Start
            sda_bit[1] = (smb_adr >> 6) & 1;               // A6
            sda_bit[2] = (smb_adr >> 5) & 1;               // A5
            sda_bit[3] = (smb_adr >> 4) & 1;               // A4
            sda_bit[4] = (smb_adr >> 3) & 1;               // A3
            sda_bit[5] = (smb_adr >> 2) & 1;               // A2
            sda_bit[6] = (smb_adr >> 1) & 1;               // A1
            sda_bit[7] = (smb_adr >> 0) & 1;               // A0
            sda_bit[8] = 0;                                // 0 = write command register                           
            sda_bit[9] = 1;                                // ACK
            sda_bit[10]= (cmd     >> 7) & 1;               // C7 
            sda_bit[11]= (cmd     >> 6) & 1;               // C6 
            sda_bit[12]= (cmd     >> 5) & 1;               // C5 
            sda_bit[13]= (cmd     >> 4) & 1;               // C4 
            sda_bit[14]= (cmd     >> 3) & 1;               // C3 
            sda_bit[15]= (cmd     >> 2) & 1;               // C2 
            sda_bit[16]= (cmd     >> 1) & 1;               // C1 
            sda_bit[17]= (cmd     >> 0) & 1;               // C0 
            sda_bit[18]= 1;                                // ACK
            sda_bit[19]= (smb_data>> 7) & 1;               // D7 write data register
            sda_bit[20]= (smb_data>> 6) & 1;               // D6 write data register
            sda_bit[21]= (smb_data>> 5) & 1;               // D5 write data register
            sda_bit[22]= (smb_data>> 4) & 1;               // D4 write data register
            sda_bit[23]= (smb_data>> 3) & 1;               // D3 write data register
            sda_bit[24]= (smb_data>> 2) & 1;               // D2 write data register
            sda_bit[25]= (smb_data>> 1) & 1;               // D1 write data register
            sda_bit[26]= (smb_data>> 0) & 1;               // D0 write data register
            sda_bit[27]= 1;                                // ACK
            sda_bit[28]= 0;                                // Stop
            //
            // ** Construct SMBclk and SMBdata **
            //
            //	SMB requires that serial data is stable while clock is high,
            //	so data transitions occur while clock is low,
            //	midway between clock falling edge and rising edge
            //
            int nclks = 115;
            //
            int sda_clock,scl_clock;
            int sda,scl;
            //
            int i2c_clock;
            for (i2c_clock=0; i2c_clock<=nclks; i2c_clock++) {  //200kHz
                sda_clock = (int) i2c_clock/4;                //50 kHz
                scl_clock = (int) ( (i2c_clock+1)/2 );        //50 kHz shifted 1/2 of a 100kHz cycle
                //
                scl = scl_clock & 1;                          // 0 0 1 1 0 0 1 1 0 0 1 1 ....
                sda = sda_bit[sda_clock];
                //
                //    (*MyOutput_) << "Before Persistent -> i2c_clock " << i2c_clock << ", scl = " << scl << " sda_bit = " << sda << std::endl;
                //
                if (i2c_clock<3) scl=1;                       // START scl stays high
                if (i2c_clock<2) sda=1;                       // START sda transitions low
                //
                if (i2c_clock>nclks-3) scl=1;                // STOP scl stays high
                if (i2c_clock>nclks-2) sda=1;                // STOP sda transitions high
                //
                //    (*MyOutput_) << "After Persistent  -> i2c_clock " << i2c_clock << ", scl = " << scl << " sda_bit = " << sda << std::endl;
                //
                //** Write serial clock and data to TMB VME interface **
                //
                write_data = adc_status & 0xf9ff;    //clear bits 9 and 10
                write_data |= scl << 9;
                write_data |= sda << 10;
                WriteRegister(adc_adr,write_data);
            }
            //
            // Current ADC register state:
            adc_status = ReadRegister(adc_adr);
            //
            // **Step 2 read the data**
            //
            // ** initialize SMB data stream **
            sda_bit[0] = 0;                                // Start
            sda_bit[1] = (smb_adr >> 6) & 1;               // A6
            sda_bit[2] = (smb_adr >> 5) & 1;               // A5
            sda_bit[3] = (smb_adr >> 4) & 1;               // A4
            sda_bit[4] = (smb_adr >> 3) & 1;               // A3
            sda_bit[5] = (smb_adr >> 2) & 1;               // A2
            sda_bit[6] = (smb_adr >> 1) & 1;               // A1
            sda_bit[7] = (smb_adr >> 0) & 1;               // A0
            sda_bit[8] = 1;                                // 1 = read data register                           
            sda_bit[9] = 1;                                // ACK
            sda_bit[10]= 1;                                // D7 read from LM84, 1=z output from fpga
            sda_bit[11]= 1;                                // D6
            sda_bit[12]= 1;                                // D5
            sda_bit[13]= 1;                                // D4
            sda_bit[14]= 1;                                // D3
            sda_bit[15]= 1;                                // D2
            sda_bit[16]= 1;                                // D1
            sda_bit[17]= 1;                                // D0
            sda_bit[18]= 1;                                // ACK
            sda_bit[19]= 0;                                // Stop
            //
            int d[20];
            int sda_value=0;
            //
            nclks = 79;
            //
            for (i2c_clock=0; i2c_clock<=nclks; i2c_clock++) {  //200kHz
                sda_clock = (int) i2c_clock/4;                //50 kHz
                scl_clock = (int) ( (i2c_clock+1)/2 );        //50 kHz shifted 1/2 of a 100kHz cycle
                //
                scl = scl_clock & 1;                          // 0 0 1 1 0 0 1 1 0 0 1 1 ....
                sda = sda_bit[sda_clock];
                //
                if (i2c_clock<3) scl=1;                       // START scl stays high
                if (i2c_clock<2) sda=1;                       // START sda transitions low
                //
                if (i2c_clock>nclks-3) scl=1;                // STOP scl stays high
                if (i2c_clock>nclks-2) sda=1;                // STOP sda transitions high
                //
                //** Write serial clock and data to TMB VME interface **
                write_data = adc_status & 0xf9ff;    //clear bits 9 and 10
                write_data |= scl << 9;
                write_data |= sda << 10;
                WriteRegister(adc_adr,write_data);
                //
                //** Read Serial data from TMB VME interface **
                // (read on every cycle to keep clock symmetric)
                read_data = ReadRegister(adc_adr);
                if (scl==1) 
                    d[sda_clock] = read_data;
            }
            //
            // pack data into an integer...
            int ishift = 0;
            if (module == 1) ishift = 10;   //data bit from LM84 on TMB
            if (module == 2) ishift = 11;   //data bit from LM84 on RAT
            //
            int i;
            int data = 0;
            for (i=0; i<=31; i++) {
                if (i<=7) {
                    sda_value = (d[17-i]>>ishift) & 0x1;
                    data |= sda_value<<i;          //d[7:0]
                } else {
                    data |= sda_value<<i;          //sign extend if bit 7 indicates negative value      
                }
            }
            //
            //  (*MyOutput_) << "Temperature = " << std::dec << data << " deg C" << std::endl;
            //
            return data;
        }
        //
        ////////////////////////////////////////////////////////////////////////////
        // write/read userPROMs
        ////////////////////////////////////////////////////////////////////////////
        void TMB::ClockOutPromProgram(int prom,
                int number_of_addresses) {
            //
            clocked_out_prom_image_.clear();    
            //
            int enabledProm = prom;
            int disabledProm = (enabledProm + 1) % 2;
            //
            (*MyOutput_) << "TMB:  Clock out 0x" << std::hex << number_of_addresses 
                << " addresses from user PROM " << enabledProm << "... " << std::endl;
            //
            int prom_clk[2];
            int prom_oe[2];
            int prom_nce[2];
            //
            prom_clk[enabledProm]=0;    
            prom_oe[enabledProm] =1;     //enable this prom in vme register
            prom_nce[enabledProm]=0;
            //
            prom_clk[disabledProm]=0;    
            prom_oe[disabledProm] =0;    //disable this prom in vme register
            prom_nce[disabledProm]=1;
            //
            int prom_src=1;
            //
            int write_data = 
                (prom_src   <<14) |        //0=on-board led, 1=enabled PROM
                (prom_nce[1]<<13) |        //PROM 1 /chip_enable
                (prom_oe[1] <<12) |        //PROM 1 output enable
                (prom_clk[1]<<11) |        //PROM 1 clock
                (prom_nce[0]<<10) |        //PROM 0 /chip_enable
                (prom_oe[0] << 9) |        //PROM 0 output enable
                (prom_clk[0]<< 8);         //PROM 0 clock
            //
            WriteRegister(vme_prom_adr,write_data);
            //
            // **Read the data from the selected PROM **
            for (int prom_adr=0; prom_adr<number_of_addresses; prom_adr++) {
                //
                clocked_out_prom_image_.push_back((int) (ReadRegister(vme_prom_adr) & 0xff));
                //    (*MyOutput_) << "VME address " << std::hex << vme_prom_adr
                //    		 << ", read prom " << enabledProm 
                //		 << ", address " << prom_adr 
                //		 << ", data = " << clocked_out_prom_image_.at(prom_adr) 
                //		 << std::endl;
                //
                // ** Toggle the clock to advance the address **
                prom_clk[enabledProm]=1;
                write_data = 
                    (prom_src   <<14) |        //0=on-board led, 1=enabled PROM
                    (prom_nce[1]<<13) |        //PROM 1 /chip_enable
                    (prom_oe[1] <<12) |        //PROM 1 output enable
                    (prom_clk[1]<<11) |        //PROM 1 clock
                    (prom_nce[0]<<10) |        //PROM 0 /chip_enable
                    (prom_oe[0] << 9) |        //PROM 0 output enable
                    (prom_clk[0]<< 8);         //PROM 0 clock
                WriteRegister(vme_prom_adr,write_data);
                //
                prom_clk[enabledProm]=0;
                write_data = 
                    (prom_src   <<14) |        //0=on-board led, 1=enabled PROM
                    (prom_nce[1]<<13) |        //PROM 1 /chip_enable
                    (prom_oe[1] <<12) |        //PROM 1 output enable
                    (prom_clk[1]<<11) |        //PROM 1 clock
                    (prom_nce[0]<<10) |        //PROM 0 /chip_enable
                    (prom_oe[0] << 9) |        //PROM 0 output enable
                    (prom_clk[0]<< 8);         //PROM 0 clock
                WriteRegister(vme_prom_adr,write_data);  
            }
            //
            // ** Turn PROMs off **
            prom_clk[enabledProm]=0;
            prom_oe[enabledProm] =0;    //disable this prom in VME register
            prom_nce[enabledProm]=1;
            //
            prom_src=0;
            //
            write_data = 
                (prom_src   <<14) |        //0=on-board led, 1=enabled PROM
                (prom_nce[1]<<13) |        //PROM 1 /chip_enable
                (prom_oe[1] <<12) |        //PROM 1 output enable
                (prom_clk[1]<<11) |        //PROM 1 clock
                (prom_nce[0]<<10) |        //PROM 0 /chip_enable
                (prom_oe[0] << 9) |        //PROM 0 output enable
                (prom_clk[0]<< 8);         //PROM 0 clock

            WriteRegister(vme_prom_adr,write_data);
            //
            return;
        }
        //
        void TMB::ClearTMBVmeWriteVecs() {
            //
            //  theController->Clear_VmeWriteVecs();
            //
            // Clear the vectors which hold the information to be written to the userPROM
            tmb_write_vme_address_.clear();
            tmb_write_data_lsb_.clear();
            tmb_write_data_msb_.clear();
            //
            return;
        }
        //
        bool TMB::OkTMBVmeWrite(unsigned vme) {
            //
            bool ok_to_write_to_this_register = false;
            //
            // Allow writes from user prom only to specific VME addresses:
            for (unsigned int index=0; index<TMBConfigurationRegister.size(); index++) {
                //
                //    std::cout << "register " << index << " to write to = " << TMBConfigurationRegister.at(index) << std::endl;
                //
                if ( (vme & 0xfff) == (TMBConfigurationRegister.at(index) & 0xfff)) {
                    ok_to_write_to_this_register = true;      
                    break;
                }
                //
            } 
            //
            return ok_to_write_to_this_register;
        }
        //
        //---------------------------------------------------------------------
        // The following would be better out of VMEController... 
        // Leave them there now because EMUjtag uses "scan" to do its VME commands
        //
        void TMB::SetALCTOkVMEWriteAddress(bool address_ok) {
            //
            theController->Set_OkVmeWriteAddress(address_ok);
            //
            return;
        }
        //
        void TMB::SetALCTFillVmeWriteVecs(bool fill_vectors_or_not) {
            //
            theController->Set_FillVmeWriteVecs(fill_vectors_or_not);
            //
            return;
        }
        //
        bool TMB::GetALCTFillVmeWriteVecs() {
            //
            return theController->Get_FillVmeWriteVecs();
            //
        }
        //
        std::vector<int> TMB::GetALCTVecVmeAddress() { 
            //
            return theController->Get_VecVmeAddress(); 
            //
        }
        //
        std::vector<int> TMB::GetALCTVecDataLsb() { 
            //
            return theController->Get_VecDataLsb(); 
            //
        }
        //
        std::vector<int> TMB::GetALCTVecDataMsb() { 
            //
            return theController->Get_VecDataMsb(); 
            //
        }
        //
        void TMB::ClearALCTVmeWriteVecs() {
            //
            theController->Clear_VmeWriteVecs();
            //
            return;
        }
        //---------------------------------------------------------------------
        //
        ////////////////////////////////////////////////////////////////////////////
        // Read TMB registers
        ////////////////////////////////////////////////////////////////////////////
        void TMB::DumpAllRegisters() {
            //
            (*MyOutput_) << "TMB register dump:" << std::endl;
            (*MyOutput_) << "addr  value" << std::endl;
            (*MyOutput_) << "----  -----" << std::endl;
            for (int register_address=0; register_address <= LARGEST_VME_ADDRESS; register_address+=2) {
                //
                int register_value = ReadRegister(register_address);
                (*MyOutput_) << " " << std::hex  
                    << ( (register_address >> 8) & 0xf ) 
                    << ( (register_address >> 4) & 0xf ) 
                    << ( (register_address >> 0) & 0xf ) 
                    << "   " << std::hex
                    << ( (register_value   >>12) & 0xf )
                    << ( (register_value   >> 8) & 0xf )
                    << ( (register_value   >> 4) & 0xf )
                    << ( (register_value   >> 0) & 0xf ) << std::endl;
            }
            //
            return;
        }
        //
        void TMB::ReadTMBConfiguration() {
            //
            FirmwareDate();
            FirmwareYear();
            FirmwareVersion();
            FirmwareRevCode();
            //
            unsigned short int BootData;
            tmb_get_boot_reg(&BootData);
            //
            //  (*MyOutput_) << "addr    data" << std::endl;
            //  (*MyOutput_) << "====   ======" << std::endl;
            //
            for (unsigned int index=0; index<TMBConfigurationRegister.size(); index++) {
                //
                unsigned long int VMEregister = TMBConfigurationRegister.at(index);
                //
                if (VMEregister != vme_usr_jtag_adr) {     // skip the user jtag register
                    //
                    //      (*MyOutput_) << "0x" << std::hex
                    //		   << ((VMEregister >> 4) & 0xf) 
                    //		   << ((VMEregister >> 0) & 0xf);
                    //      (*MyOutput_) << "   ";
                    //
                    //      int config_data = 
                    ReadRegister(VMEregister);
                    //
                    //      (*MyOutput_) << "0x" << std::hex  
                    //		   << ((config_data >>12) & 0xf) 
                    //		   << ((config_data >> 8) & 0xf) 
                    //		   << ((config_data >> 4) & 0xf) 
                    //		   << ((config_data >> 0) & 0xf);
                    //      (*MyOutput_) << std::endl;		
                }
            }
            //
            //
            return;
        }
        //
        void TMB::ReadVMEStateMachine() {
            //
            ReadRegister(vme_sm_ctrl_adr);
            ReadRegister(vme_sm_wdcnt_adr);
            ReadRegister(vme_sm_cksum_adr);
            ReadRegister(num_vme_sm_adr_adr);
            //
            return;
        }
        //
        void TMB::ReadJTAGStateMachine() {
            //
            ReadRegister(jtag_sm_ctrl_adr);
            ReadRegister(jtag_sm_cksum_adr);
            ReadRegister(jtag_sm_wdcnt_adr);
            //
            unsigned short int BootData;
            tmb_get_boot_reg(&BootData);
            //
            return;
        }
        //
        void TMB::ReadRawHitsHeader() {
            //
            ReadRegister(tmb_stat_adr);
            //
            return;
        }
        //
        void TMB::ReadDDDStateMachine() {
            //
            ReadRegister(vme_dddsm_adr);
            //
            return;
        }
        //
        //
        ////////////////////////////////////////////////////////////////////////////
        // TMB configuration register definitions and defaults
        ////////////////////////////////////////////////////////////////////////////
        void TMB::DefineTMBConfigurationRegisters_(){ 
            //
            TMBConfigurationRegister.clear();
            //
            // Registers used for TMB configuration....
            //
            // Enable/configure inputs and injectors:
            TMBConfigurationRegister.push_back(vme_loopbk_adr);       //0x0e enable ALCT LVDS rx/tx 
            TMBConfigurationRegister.push_back(alct_inj_adr  );       //0x32 mask ALCT 
            TMBConfigurationRegister.push_back(alct_stat_adr );       //0x38 TMB to ALCT data delay
            TMBConfigurationRegister.push_back(cfeb_inj_adr  );       //0x42 enable CFEB inputs  
            TMBConfigurationRegister.push_back(rpc_cfg_adr   );       //0xB6 enable RPC  
            TMBConfigurationRegister.push_back(rpc_inj_adr   );       //0xBC mask RPC  
            //
            // trigger and signal delays:
            TMBConfigurationRegister.push_back(seq_trig_dly0_adr);    //0x6A ALCT*CLCT pretrigger source delays  
            TMBConfigurationRegister.push_back(rpc_raw_delay_adr);    //0xBA RPC Raw Hits delay  
            //
            // (CLCT) pretrigger configuration:
            TMBConfigurationRegister.push_back(seq_trig_en_adr   );   //0x68 sequencer trigger source enables
            TMBConfigurationRegister.push_back(seq_clct_adr      );   //0x70 CLCT sequencer configuration
            TMBConfigurationRegister.push_back(seqmod_adr        );   //0xAC sequencer Trigger modifiers
            TMBConfigurationRegister.push_back(layer_trg_mode_adr);   //0xF0 Layer-Trigger mode
            //
            // (CLCT) pattern finding configuration:
            TMBConfigurationRegister.push_back(pattern_find_pretrg_adr);   //0xF4 CLCT pattern-finder operation 
            TMBConfigurationRegister.push_back(clct_separation_adr    );   //0xF6 CLCT separation 
            //
            // TMB trigger configuration:
            TMBConfigurationRegister.push_back(tmbtim_adr  );   //0xB2 ALCT*CLCT trigger coincidence timing, MPC tx delay 
            TMBConfigurationRegister.push_back(tmb_trig_adr);   //0x86 TMB trigger configuration/MPC accept, delays
            //
            // TMB/RPC readout:
            TMBConfigurationRegister.push_back(seq_fifo_adr );         //0x72 sequencer fifo configuration
            TMBConfigurationRegister.push_back(rpc_tbins_adr);         //0xC4 RPC FIFO time bins    
            TMBConfigurationRegister.push_back(non_trig_readout_adr);  //0xCC Readout of non-triggering data, ME1/1 firmware tags
            TMBConfigurationRegister.push_back(l1a_lookback_adr);      //0x100 L1A priority enable
            TMBConfigurationRegister.push_back(miniscope_adr);         //0x10C Miniscope Readout
            //
            // L1A/BX0 receipt:
            TMBConfigurationRegister.push_back(seq_l1a_adr   );    //0x74 L1A accept window width/delay
            TMBConfigurationRegister.push_back(seq_offset_adr);    //0x76 L1A, TMB BXN offsets
            TMBConfigurationRegister.push_back(bx0_delay_adr );    //0xCA BX0 delay
            //
            // special modifiers:
            TMBConfigurationRegister.push_back(ccb_trig_adr);         //0x2c configure request l1a from CCB  
            TMBConfigurationRegister.push_back(alct_cfg_adr);         //0x30 configure ALCT   
            //
            // clock (communication) phases:
            TMBConfigurationRegister.push_back(vme_ddd0_adr        );  //0x16 phases: ALCT tof, ALCTtx, DMBtx, RAT/TMB
            TMBConfigurationRegister.push_back(vme_ddd1_adr        );  //0x18 phases: ALCTrx, CFEB tof, TMB1, CFEB0 tof
            TMBConfigurationRegister.push_back(vme_ddd2_adr        );  //0x1a phases: CFEB4 tof, CFEB3 tof, CFEB2 tof, CFEB1 tof
            TMBConfigurationRegister.push_back(rat_3d_delays_adr   );  //0xE6 phases: RPC1/RAT, RPC0/RAT 
            TMBConfigurationRegister.push_back(phaser_alct_rxd_adr );  //0x10E digital phase shifter: alct_rx
            TMBConfigurationRegister.push_back(phaser_alct_txd_adr );  //0x110 digital phase shifter: alct_tx
            TMBConfigurationRegister.push_back(phaser_cfeb0_rxd_adr);  //0x112 digital phase shifter: cfeb0_rx
            TMBConfigurationRegister.push_back(phaser_cfeb1_rxd_adr);  //0x114 digital phase shifter: cfeb1_rx
            TMBConfigurationRegister.push_back(phaser_cfeb2_rxd_adr);  //0x116 digital phase shifter: cfeb2_rx
            TMBConfigurationRegister.push_back(phaser_cfeb3_rxd_adr);  //0x118 digital phase shifter: cfeb3_rx
            TMBConfigurationRegister.push_back(phaser_cfeb4_rxd_adr);  //0x11A digital phase shifter: cfeb4_rx
            TMBConfigurationRegister.push_back(cfeb0_3_interstage_adr);//0x11C CFEB to TMB data delay: cfeb[0-3]
            TMBConfigurationRegister.push_back(cfeb4_interstage_adr)  ;//0x11E CFEB to TMB data delay: cfeb4
            //
            // hot channel masks:
            TMBConfigurationRegister.push_back(hcm001_adr);  //0x4A distrip hot channel mask CFEB 0 layers 0,1 
            TMBConfigurationRegister.push_back(hcm023_adr);  //0x4C distrip hot channel mask CFEB 0 layers 2,3 
            TMBConfigurationRegister.push_back(hcm045_adr);  //0x4E distrip hot channel mask CFEB 0 layers 4,5 
            TMBConfigurationRegister.push_back(hcm101_adr);  //0x50 distrip hot channel mask CFEB 1 layers 0,1 
            TMBConfigurationRegister.push_back(hcm123_adr);  //0x52 distrip hot channel mask CFEB 1 layers 2,3 
            TMBConfigurationRegister.push_back(hcm145_adr);  //0x54 distrip hot channel mask CFEB 1 layers 4,5 
            TMBConfigurationRegister.push_back(hcm201_adr);  //0x56 distrip hot channel mask CFEB 2 layers 0,1 
            TMBConfigurationRegister.push_back(hcm223_adr);  //0x58 distrip hot channel mask CFEB 2 layers 2,3 
            TMBConfigurationRegister.push_back(hcm245_adr);  //0x5A distrip hot channel mask CFEB 2 layers 4,5 
            TMBConfigurationRegister.push_back(hcm301_adr);  //0x5C distrip hot channel mask CFEB 3 layers 0,1 
            TMBConfigurationRegister.push_back(hcm323_adr);  //0x5E distrip hot channel mask CFEB 3 layers 2,3 
            TMBConfigurationRegister.push_back(hcm345_adr);  //0x60 distrip hot channel mask CFEB 3 layers 4,5 
            TMBConfigurationRegister.push_back(hcm401_adr);  //0x62 distrip hot channel mask CFEB 4 layers 0,1 
            TMBConfigurationRegister.push_back(hcm423_adr);  //0x64 distrip hot channel mask CFEB 4 layers 2,3 
            TMBConfigurationRegister.push_back(hcm445_adr);  //0x66 distrip hot channel mask CFEB 4 layers 4,5 
            //
            // Automatic masking of bad bits
            TMBConfigurationRegister.push_back(cfeb_badbits_ctrl_adr) ;  //0x122
            //
            // Not put into xml file, but may want to enable scope for test runs...
            //  TMBConfigurationRegister.push_back(scp_ctrl_adr);         //0x98 scope control
            //
            return;
        }
        //
        void TMB::SetTMBRegisterDefaults() {
            //
            // Set the default write values to the configuration registers:
            //
            trgmode_ = CLCT_trigger;  
            //
            //-----------------------------------------------------------------
            //0X0E = ADR_LOOPBK:  Loop-Back Control Register
            //-----------------------------------------------------------------
            enable_alct_rx_ = enable_alct_rx_default;
            enable_alct_tx_ = enable_alct_tx_default;
            //
            //------------------------------------------------------------------
            //0X16 = ADR_DDD0:  3D3444 Chip 0 Delays, 1 step = 2ns
            //------------------------------------------------------------------
            alct_tof_delay_      = alct_tof_delay_default     ;
            dmb_tx_delay_        = dmb_tx_delay_default       ;
            rat_tmb_delay_       = rat_tmb_delay_default      ;
            //
            //------------------------------------------------------------------
            //0X18 = ADR_DDD1:  3D3444 Chip 1 Delays, 1 step = 2ns
            //------------------------------------------------------------------
            tmb1_phase_          = tmb1_phase_default         ;  
            cfeb_tof_delay_      = cfeb_tof_delay_default     ;
            cfeb0_tof_delay_     = cfeb0_tof_delay_default    ;
            //
            //------------------------------------------------------------------
            //0X1A = ADR_DDD2:  3D3444 Chip 2 Delays, 1 step = 2ns
            //------------------------------------------------------------------
            cfeb1_tof_delay_ = cfeb1_tof_delay_default;
            cfeb2_tof_delay_ = cfeb2_tof_delay_default;
            cfeb3_tof_delay_ = cfeb3_tof_delay_default;
            cfeb4_tof_delay_ = cfeb4_tof_delay_default;
            //
            //------------------------------------------------------------------
            //0X1E = ADR_RATCTRL:  RAT Module Control
            //------------------------------------------------------------------
            rpc_sync_   = rpc_sync_default  ;
            shift_rpc_  = shift_rpc_default ;
            rat_dsn_en_ = rat_dsn_en_default;
            //
            //------------------------------------------------------------------
            //0X24 = ADR_ADC:  ADC + power comparator
            //------------------------------------------------------------------
            voltage_adc_data_out_         = voltage_adc_data_out_default         ;
            voltage_adc_serial_clock_     = voltage_adc_serial_clock_default     ;
            voltage_adc_data_in_          = voltage_adc_data_in_default          ;
            voltage_adc_chip_select_      = voltage_adc_chip_select_default      ;
            temperature_adc_serial_clock_ = temperature_adc_serial_clock_default ;
            temperature_adc_serial_data_  = temperature_adc_serial_data_default  ;
            //
            //------------------------------------------------------------------
            //0X2A = ADR_CCB_CFG:  CCB Configuration
            //------------------------------------------------------------------
            ignore_ccb_rx_                 = ignore_ccb_rx_default                ;
            disable_ccb_tx_                = disable_ccb_tx_default               ;
            enable_internal_l1a_           = enable_internal_l1a_default          ;
            enable_alctclct_status_to_ccb_ = enable_alctclct_status_to_ccb_default;
            enable_alct_status_to_ccb_     = enable_alct_status_to_ccb_default    ;
            enable_clct_status_to_ccb_     = enable_clct_status_to_ccb_default    ;
            fire_l1a_oneshot_              = fire_l1a_oneshot_default             ;
            //
            //------------------------------------------------------------------
            //0X2C = ADR_CCB_TRIG:  CCB Trigger Control
            //------------------------------------------------------------------
            alct_ext_trig_l1aen_    = alct_ext_trig_l1aen_default   ;
            clct_ext_trig_l1aen_    = clct_ext_trig_l1aen_default   ;
            request_l1a_            = request_l1a_default           ;
            alct_ext_trig_vme_      = alct_ext_trig_vme_default     ;         
            clct_ext_trig_vme_      = clct_ext_trig_vme_default     ;         
            ext_trig_both_          = ext_trig_both_default         ;         
            ccb_allow_bypass_       = ccb_allow_bypass_default      ;         
            ignore_ccb_startstop_   = ignore_ccb_startstop_default  ;         
            internal_l1a_delay_vme_ = internal_l1a_delay_vme_default;         
            //
            //------------------------------------------------------------------
            //0X30 = ADR_ALCT_CFG:  ALCT Configuration
            //------------------------------------------------------------------
            cfg_alct_ext_trig_en_   = cfg_alct_ext_trig_en_default  ;  
            cfg_alct_ext_inject_en_ = cfg_alct_ext_inject_en_default;
            cfg_alct_ext_trig_      = cfg_alct_ext_trig_default     ;    
            cfg_alct_ext_inject_    = cfg_alct_ext_inject_default   ;  
            alct_seq_cmd_           = alct_seq_cmd_default          ;         
            alct_clock_en_use_ccb_  = alct_clock_en_use_ccb_default ;
            alct_clock_en_use_vme_  = alct_clock_en_use_vme_default ;
            //
            //------------------------------------------------------------------
            //0X32 = ADR_ALCT_INJ:  ALCT Injector Control
            //------------------------------------------------------------------
            alct_clear_      = alct_clear_default     ;
            alct_inject_mux_ = alct_inject_mux_default;
            alct_sync_clct_  = alct_sync_clct_default ;
            alct_inj_delay_  = alct_inj_delay_default ;
            //
            //------------------------------------------------------------------
            //0X38 = ADR_ALCT_STAT:  ALCT Sequencer Control/Status
            //------------------------------------------------------------------
            alct_ecc_en_        = alct_ecc_en_default       ;
            alct_ecc_err_blank_ = alct_ecc_err_blank_default;
            alct_txdata_delay_  = alct_txdata_delay_default ;
            //
            //------------------------------------------------------------------
            //0X42 = ADR_CFEB_INJ:  CFEB Injector Control
            //------------------------------------------------------------------
            disableCLCTInputs_ = 0;                         //remove this?
            enableCLCTInputs_  = enableCLCTInputs_default ;
            cfeb_ram_sel_      = cfeb_ram_sel_default     ;
            cfeb_inj_en_sel_   = cfeb_inj_en_sel_default  ;
            start_pattern_inj_ = start_pattern_inj_default;
            //
            //------------------------------------------------------------------
            //0X4A,4C,4E = ADR_HCM001,HCM023,HCM045 = CFEB0 Hot Channel Masks
            //0X50,52,54 = ADR_HCM101,HCM123,HCM145 = CFEB1 Hot Channel Masks
            //0X56,58,5A = ADR_HCM201,HCM223,HCM245 = CFEB2 Hot Channel Masks
            //0X5C,5E,60 = ADR_HCM301,HCM323,HCM345 = CFEB3 Hot Channel Masks
            //0X62,64,66 = ADR_HCM401,HCM423,HCM445 = CFEB4 Hot Channel Masks
            //------------------------------------------------------------------
            for (int layer=0; layer<MAX_NUM_LAYERS; layer++) 
                for (int distrip=0; distrip<MAX_NUM_DISTRIPS_PER_LAYER; distrip++)
                    hot_channel_mask_[layer][distrip] = hot_channel_mask_default;
            //
            //
            //------------------------------------------------------------------
            //0X68 = ADR_SEQ_TRIG_EN:  Sequencer Trigger Source Enables
            //------------------------------------------------------------------
            clct_pat_trig_en_   = clct_pat_trig_en_default  ;
            alct_pat_trig_en_   = alct_pat_trig_en_default  ;
            match_pat_trig_en_  = match_pat_trig_en_default ;
            adb_ext_trig_en_    = adb_ext_trig_en_default   ;  
            dmb_ext_trig_en_    = dmb_ext_trig_en_default   ;  
            clct_ext_trig_en_   = clct_ext_trig_en_default  ; 
            alct_ext_trig_en_   = alct_ext_trig_en_default  ; 
            vme_ext_trig_       = vme_ext_trig_default      ;  
            ext_trig_inject_    = ext_trig_inject_default   ;  
            all_cfeb_active_    = all_cfeb_active_default   ;  
            cfebs_enabled_      = cfebs_enabled_default     ;  
            cfeb_enable_source_ = cfeb_enable_source_default;
            //
            //------------------------------------------------------------------
            //0X6A = ADR_SEQ_TRIG_DLY0:  Sequencer Trigger Source Delays
            //------------------------------------------------------------------
            alct_pretrig_width_ = alct_pretrig_width_default;
            alct_pretrig_delay_ = alct_pretrig_delay_default;
            alct_pattern_delay_ = alct_pattern_delay_default;
            adb_ext_trig_delay_ = adb_ext_trig_delay_default;
            //
            //------------------------------------------------------------------
            //0X6C = ADR_SEQ_TRIG_DLY1:  Sequencer Trigger Source Delays
            //------------------------------------------------------------------
            dmb_ext_trig_delay_  = dmb_ext_trig_delay_default ;
            clct_ext_trig_delay_ = clct_ext_trig_delay_default;
            alct_ext_trig_delay_ = alct_ext_trig_delay_default;
            //
            //------------------------------------------------------------------
            //0X6E = ADR_SEQ_ID:  Sequencer Board + CSC Ids
            //------------------------------------------------------------------
            tmb_slot_ = this->slot();     //the TMB was instantiated with this value from the parser
            csc_id_   = tmb_slot_/2;      //the index of the CSC served by this peripheral crate
            if (tmb_slot_ > 11 ) csc_id_--;
            run_id_   = run_id_default;
            //
            //------------------------------------------------------------------
            //0X70 = ADR_SEQ_CLCT:  Sequencer CLCT configuration
            //------------------------------------------------------------------
            triad_persist_    = triad_persist_default   ;
            hit_thresh_       = hit_thresh_default      ;
            aff_thresh_       = aff_thresh_default      ; 
            min_hits_pattern_ = min_hits_pattern_default;
            drift_delay_      = drift_delay_default     ;
            pretrigger_halt_  = pretrigger_halt_default ;
            //
            //------------------------------------------------------------------
            //0X72 = ADR_SEQ_FIFO:  Sequencer FIFO configuration
            //------------------------------------------------------------------
            fifo_mode_            = fifo_mode_default           ;
            fifo_tbins_           = fifo_tbins_default          ;
            fifo_pretrig_         = fifo_pretrig_default        ;
            fifo_no_raw_hits_     = fifo_no_raw_hits_default    ;
            cfeb_badbits_readout_ = cfeb_badbits_readout_default;
            //
            //------------------------------------------------------------------
            //0X74 = ADR_SEQ_L1A:  Sequencer L1A configuration
            //------------------------------------------------------------------
            l1adelay_         = l1adelay_default        ;
            l1a_window_size_  = l1a_window_size_default ;
            tmb_l1a_internal_ = tmb_l1a_internal_default;
            //
            //------------------------------------------------------------------
            //0X76 = ADR_SEQ_OFFSET:  Sequencer Counter Offsets
            //------------------------------------------------------------------
            l1a_offset_ = l1a_offset_default;
            bxn_offset_ = bxn_offset_default;
            //
            //------------------------------------------------------------------
            //0X86 = ADR_TMB_TRIG:  TMB Trigger configuration/MPC accept
            //------------------------------------------------------------------
            tmb_sync_err_enable_ = tmb_sync_err_enable_default;
            tmb_allow_alct_      = tmb_allow_alct_default     ;
            tmb_allow_clct_      = tmb_allow_clct_default     ;
            tmb_allow_match_     = tmb_allow_match_default    ;
            mpc_rx_delay_        = mpc_rx_delay_default       ;
            mpc_sel_ttc_bx0_     = mpc_sel_ttc_bx0_default    ;
            mpc_idle_blank_      = mpc_idle_blank_default     ;
            mpc_output_enable_   = mpc_output_enable_default  ;
            //
            //------------------------------------------------------------------
            //0X98 = ADR_SCP_CTRL:  Scope control
            //------------------------------------------------------------------
            scope_in_readout_  =  scope_in_readout_default;
            //
            //------------------------------------------------------------------
            //0XA8 = ADR_ALCTFIFO1:  ALCT Raw Hits RAM control
            //------------------------------------------------------------------
            alct_raw_reset_        = alct_raw_reset_default       ;
            alct_raw_read_address_ = alct_raw_read_address_default;
            alct_demux_mode_       = alct_demux_mode_default      ;
            //
            //------------------------------------------------------------------
            //0XAC = ADR_SEQMOD:  Sequencer Trigger Modifiers
            //------------------------------------------------------------------
            clct_flush_delay_             = clct_flush_delay_default            ;
            wr_buffer_autoclear_          = wr_buffer_autoclear_default         ;
            clct_write_continuous_enable_ = clct_write_continuous_enable_default;
            wrt_buf_required_             = wrt_buf_required_default            ;
            valid_clct_required_          = valid_clct_required_default         ;
            l1a_allow_match_              = l1a_allow_match_default             ;
            l1a_allow_notmb_              = l1a_allow_notmb_default             ;
            l1a_allow_nol1a_              = l1a_allow_nol1a_default             ;
            l1a_allow_alct_only_          = l1a_allow_alct_only_default         ;
            scint_veto_clr_               = scint_veto_clr_default              ;
            //
            //------------------------------------------------------------------
            //0XB2 = ADR_TMBTIM:  TMB Timing for ALCT*CLCT Coincidence
            //------------------------------------------------------------------
            alct_vpf_delay_         = alct_vpf_delay_default        ;
            alct_match_window_size_ = alct_match_window_size_default;
            mpc_tx_delay_           = mpc_tx_delay_default          ;
            //
            //------------------------------------------------------------------
            //0XB6 = ADR_RPC_CFG:  RPC Configuration
            //------------------------------------------------------------------
            rpc_exists_      = rpc_exists_default     ;
            rpc_read_enable_ = rpc_read_enable_default;
            rpc_bxn_offset_  = rpc_bxn_offset_default ;
            rpc_bank_        = rpc_bank_default       ;
            //
            //------------------------------------------------------------------
            //0XBA = ADR_RPC_RAW_DELAY:  RPC Raw Hits Data Delay
            //------------------------------------------------------------------
            rpc0_raw_delay_ = rpc0_raw_delay_default;
            rpc1_raw_delay_ = rpc1_raw_delay_default;
            //
            //------------------------------------------------------------------
            //0XBC = ADR_RPC_INJ:  RPC Injector Control
            //------------------------------------------------------------------
            rpc_mask_all_  = rpc_mask_all_default ; 
            inj_mask_rat_  = inj_mask_rat_default ;
            inj_mask_rpc_  = inj_mask_rpc_default ;
            inj_delay_rat_ = inj_delay_rat_default;
            rpc_inj_sel_   = rpc_inj_sel_default  ;
            rpc_inj_wdata_ = rpc_inj_wdata_default;
            //
            //------------------------------------------------------------------
            //0XC4 = ADR_RPC_TBINS:  RPC FIFO Time Bins
            //------------------------------------------------------------------
            fifo_tbins_rpc_     = fifo_tbins_rpc_default    ;
            fifo_pretrig_rpc_   = fifo_pretrig_rpc_default  ;
            rpc_decouple_       = rpc_decouple_default;
            //
            //------------------------------------------------------------------
            //0XCA = ADR_BX0_DELAY:  BX0 to MPC delays
            //------------------------------------------------------------------
            alct_bx0_delay_  = alct_bx0_delay_default ;
            clct_bx0_delay_  = clct_bx0_delay_default ;
            alct_bx0_enable_ = alct_bx0_enable_default;
            bx0_vpf_test_    = bx0_vpf_test_default   ;
            //
            //-----------------------------------------------------------------------------
            //0XCC = ADR_NON_TRIG_RO:  Non-Triggering Event Enables + ME1/1A(1B) reversal 
            //-----------------------------------------------------------------------------
            tmb_allow_alct_nontrig_readout_   =  tmb_allow_alct_nontrig_readout_default   ;
            tmb_allow_clct_nontrig_readout_   =  tmb_allow_clct_nontrig_readout_default   ;
            tmb_allow_match_nontrig_readout_  =  tmb_allow_match_nontrig_readout_default  ;
            mpc_block_me1a_                   =  mpc_block_me1a_default                   ;
            clct_pretrigger_counter_non_me11_ =  clct_pretrigger_counter_non_me11_default ;
            SetTMBFirmwareCompileType(tmb_firmware_compile_type_default);
            //
            //------------------------------------------------------------------
            //0XD4 = ADR_JTAGSM0:  JTAG State Machine Control (reads JTAG PROM)
            //------------------------------------------------------------------
            jtag_disable_write_to_adr10_ = jtag_disable_write_to_adr10_default;
            //
            //------------------------------------------------------------------
            //0XE6 = ADR_DDDR0:  RAT 3D3444 RPC Delays, 1 step = 2ns
            //------------------------------------------------------------------
            rpc0_rat_delay_ = rpc0_rat_delay_default;
            rpc1_rat_delay_ = rpc1_rat_delay_default;
            //
            //---------------------------------------------------------------------
            //0XF0 = ADR_LAYER_TRIG:  Layer-Trigger Mode
            //---------------------------------------------------------------------
            layer_trigger_en_  = layer_trigger_en_default ; 
            layer_trig_thresh_ = layer_trig_thresh_default;
            clct_throttle_     = clct_throttle_default;
            //
            //---------------------------------------------------------------------
            //0XF4 = ADR_TEMP0:  Pattern Finder Pretrigger
            //---------------------------------------------------------------------
            clct_blanking_                    = clct_blanking_default                   ; 
            clct_pattern_id_thresh_           = clct_pattern_id_thresh_default          ; 
            clct_pattern_id_thresh_postdrift_ = clct_pattern_id_thresh_postdrift_default; 
            adjacent_cfeb_distance_           = adjacent_cfeb_distance_default          ;
            //
            //---------------------------------------------------------------------
            //0XF6 = ADR_TEMP1:  CLCT separation
            //---------------------------------------------------------------------
            clct_separation_src_              = clct_separation_src_default             ; 
            clct_separation_ram_write_enable_ = clct_separation_ram_write_enable_default; 
            clct_separation_ram_adr_          = clct_separation_ram_adr_default         ; 
            min_clct_separation_              = min_clct_separation_default             ; 
            //
            //---------------------------------------------------------------------
            //0X100 = ADR_L1A_LOOKBACK:  L1A Lookback Distance
            //---------------------------------------------------------------------
            l1a_allow_notmb_lookback_ = l1a_allow_notmb_lookback_default;
            inj_wrdata_msb_           = inj_wrdata_msb_default          ; 
            l1a_priority_enable_      = l1a_priority_enable_default     ; 
            //
            //---------------------------------------------------------------------
            //0X104 = ADR_ALCT_SYNC_CTRL:  ALCT Sync Mode Control
            //---------------------------------------------------------------------
            alct_sync_rxdata_dly_   = alct_sync_rxdata_dly_default  ;
            alct_sync_tx_random_    = alct_sync_tx_random_default   ;
            alct_sync_clear_errors_ = alct_sync_clear_errors_default;
            //
            //---------------------------------------------------------------------
            //0X106 = ADR_ALCT_SYNC_TXDATA_1ST:  ALCT Sync Mode Transmit Data 1st
            //---------------------------------------------------------------------
            alct_sync_txdata_1st_ = alct_sync_txdata_1st_default;
            //
            //---------------------------------------------------------------------
            //0X108 = ADR_ALCT_SYNC_TXDATA_2ND:  ALCT Sync Mode Transmit Data 2nd
            //---------------------------------------------------------------------
            alct_sync_txdata_2nd_ = alct_sync_txdata_2nd_default;
            //
            //---------------------------------------------------------------------
            //0X10C = ADR_MINISCOPE:  Internal 16 Channel Digital Scope
            //---------------------------------------------------------------------
            miniscope_enable_  = miniscope_enable_default ; 
            mini_tbins_test_   = mini_tbins_test_default  ; 
            mini_tbins_word_   = mini_tbins_word_default  ; 
            fifo_tbins_mini_   = fifo_tbins_mini_default  ; 
            fifo_pretrig_mini_ = fifo_pretrig_mini_default; 
            //
            //---------------------------------------------------------------------
            //(0X10E,0X110,0X112,0X114,0X116,0X118,0X11A) = ADR_PHASER[0-6]:  
            // digital phase shifter for... alct_rx,alct_tx,cfeb[0-4]_rx
            //---------------------------------------------------------------------
            fire_phaser_                   = fire_phaser_default                  ;
            reset_phase_                   = reset_phase_default                  ; 
            //
            //--------------------------------------------------------------
            //[0X10E] = ADR_PHASER0:  values in the xml file for alct_rx
            //--------------------------------------------------------------
            alct_rx_clock_delay_ = alct_rx_clock_delay_default;
            alct_rx_posneg_      = alct_rx_posneg_default     ;
            //
            //--------------------------------------------------------------
            //[0X110] = ADR_PHASER1:  values in the xml file for alct_tx
            //--------------------------------------------------------------
            alct_tx_clock_delay_ = alct_tx_clock_delay_default;
            alct_tx_posneg_      = alct_tx_posneg_default     ;
            //
            //--------------------------------------------------------------
            //[0X112] = ADR_PHASER2:  values in the xml file for cfeb0_rx
            //--------------------------------------------------------------
            cfeb0_rx_clock_delay_ = cfeb0_rx_clock_delay_default;
            cfeb0_rx_posneg_      = cfeb0_rx_posneg_default     ;
            //
            //--------------------------------------------------------------
            //[0X114] = ADR_PHASER3:  values in the xml file for cfeb1_rx
            //--------------------------------------------------------------
            cfeb1_rx_clock_delay_ = cfeb1_rx_clock_delay_default;
            cfeb1_rx_posneg_      = cfeb1_rx_posneg_default     ;
            //
            //--------------------------------------------------------------
            //[0X116] = ADR_PHASER4:  values in the xml file for cfeb2_rx
            //--------------------------------------------------------------
            cfeb2_rx_clock_delay_ = cfeb2_rx_clock_delay_default;
            cfeb2_rx_posneg_      = cfeb2_rx_posneg_default     ;
            //
            //--------------------------------------------------------------
            //[0X118] = ADR_PHASER5:  values in the xml file for cfeb3_rx
            //--------------------------------------------------------------
            cfeb3_rx_clock_delay_ = cfeb3_rx_clock_delay_default;
            cfeb3_rx_posneg_      = cfeb3_rx_posneg_default     ;
            //
            //--------------------------------------------------------------
            //[0X11A] = ADR_PHASER6:  values in the xml file for cfeb4_rx
            //--------------------------------------------------------------
            cfeb4_rx_clock_delay_ = cfeb4_rx_clock_delay_default;
            cfeb4_rx_posneg_      = cfeb4_rx_posneg_default     ;
            //
            //--------------------------------------------------------------
            // 0X11C = ADR_DELAY0_INT:  CFEB to TMB "interstage" delays
            //--------------------------------------------------------------
            cfeb0_rxd_int_delay_ = cfeb0_rxd_int_delay_default;
            cfeb1_rxd_int_delay_ = cfeb1_rxd_int_delay_default;
            cfeb2_rxd_int_delay_ = cfeb2_rxd_int_delay_default;
            cfeb3_rxd_int_delay_ = cfeb3_rxd_int_delay_default;
            //
            //--------------------------------------------------------------
            // 0X11E = ADR_DELAY1_INT:  CFEB to TMB "interstage" delays
            //--------------------------------------------------------------
            cfeb4_rxd_int_delay_ = cfeb4_rxd_int_delay_default;
            //
            //---------------------------------------------------------------------
            // 0X120 = ADR_SYNC_ERR_CTRL:  Synchronization Error Control
            //---------------------------------------------------------------------
            sync_err_reset_                =  sync_err_reset_default                ;
            clct_bx0_sync_err_enable_      =  clct_bx0_sync_err_enable_default      ;
            alct_ecc_rx_sync_err_enable_   =  alct_ecc_rx_sync_err_enable_default   ;
            alct_ecc_tx_sync_err_enable_   =  alct_ecc_tx_sync_err_enable_default   ;
            bx0_match_sync_err_enable_     =  bx0_match_sync_err_enable_default     ;
            clock_lock_lost_sync_err_enable_=clock_lock_lost_sync_err_enable_default;
            sync_err_blanks_mpc_enable_    =  sync_err_blanks_mpc_enable_default    ;
            sync_err_stops_pretrig_enable_ =  sync_err_stops_pretrig_enable_default ;
            sync_err_stops_readout_enable_ =  sync_err_stops_readout_enable_default ;
            //
            //---------------------------------------------------------------------
            // 0X122 = ADR_CFEB_BADBITS_CTRL:  CFEB badbits control/status
            //---------------------------------------------------------------------
            cfeb_badbits_reset_ = cfeb_badbits_reset_default;
            cfeb_badbits_block_ = cfeb_badbits_block_default;
            //
            //---------------------------------------------------------------------
            // 0X124 = ADR_CFEB_BADBITS_TIMER:  CFEB badbits check interval
            //---------------------------------------------------------------------
            cfeb_badbits_nbx_ = cfeb_badbits_nbx_default;
            //
            //
            return;
        }
        //
        void TMB::SetTMBFirmwareCompileType(int tmb_firmware_compile_type) {
            //
            tmb_firmware_compile_type_ = tmb_firmware_compile_type;
            //
            if (tmb_firmware_compile_type == 0xa) {
                csc_me11_        = 0;
                clct_stagger_    = 1;
                reverse_stagger_ = 0;
                reverse_me1a_    = 0;
                reverse_me1b_    = 0;
                expected_tmb_firmware_compile_type_ = TMB_FIRMWARE_TYPE_A;
                //
            } else if (tmb_firmware_compile_type == 0xb) {
                csc_me11_        = 0;
                clct_stagger_    = 0;
                reverse_stagger_ = 1;
                reverse_me1a_    = 0;
                reverse_me1b_    = 0;
                expected_tmb_firmware_compile_type_ = TMB_FIRMWARE_TYPE_B;
                //
            } else if (tmb_firmware_compile_type == 0xc) {
                csc_me11_        = 1;
                clct_stagger_    = 0;
                reverse_stagger_ = 0;
                reverse_me1a_    = 1;
                reverse_me1b_    = 0;
                expected_tmb_firmware_compile_type_ = TMB_FIRMWARE_TYPE_C;
                //
            } else if (tmb_firmware_compile_type == 0xd) {
                csc_me11_        = 1;
                clct_stagger_    = 0;
                reverse_stagger_ = 0;
                reverse_me1a_    = 0;
                reverse_me1b_    = 1;
                expected_tmb_firmware_compile_type_ = TMB_FIRMWARE_TYPE_D;
                //
            } else {
                csc_me11_        = 0;
                clct_stagger_    = 0;
                reverse_stagger_ = 0;
                reverse_me1a_    = 0;
                reverse_me1b_    = 0;
                expected_tmb_firmware_compile_type_ = 0;
                //
                //    std::ostringstream toerror;
                //    toerror << "TMB slot " << this->slot() << " -> compile type = " << GetTMBFirmwareCompileType() << "not allowed" << std::endl;
                std::cout << "ERROR:  TMB slot " << this->slot() << " -> compile type = " << GetTMBFirmwareCompileType() << " is not valid" << std::endl;
                //    ReportCheck(toerror.str(),false);
                //
            }
            //  std::cout << "TMB slot " << this->slot() << " -> compile type = " << GetTMBFirmwareCompileType() << std::endl;
            //
            return;
        }
        //
        //
        ////////////////////////////////////////////////////////////////////////////////////////
        // Decode registers read from TMB
        ////////////////////////////////////////////////////////////////////////////////////////
        void TMB::DecodeTMBRegister_(unsigned long int address, int data) {
            //
            if ( address == vme_loopbk_adr ) {
                //------------------------------------------------------------------
                //0X0E = ADR_LOOPBK:  Loop-Back Control Register  
                //------------------------------------------------------------------
                read_cfeb_oe_        = ExtractValueFromData(data,cfeb_oe_bitlo       ,cfeb_oe_bithi       );
                read_alct_loop_      = ExtractValueFromData(data,alct_loop_bitlo     ,alct_loop_bithi     );
                read_enable_alct_rx_ = ExtractValueFromData(data,enable_alct_rx_bitlo,enable_alct_rx_bithi);
                read_enable_alct_tx_ = ExtractValueFromData(data,enable_alct_tx_bitlo,enable_alct_tx_bithi);
                read_rpc_loop_rat_   = ExtractValueFromData(data,rpc_loop_rat_bitlo  ,rpc_loop_rat_bithi  );
                read_rpc_loop_tmb_   = ExtractValueFromData(data,rpc_loop_tmb_bitlo  ,rpc_loop_tmb_bithi  );
                read_dmb_loop_       = ExtractValueFromData(data,dmb_loop_bitlo      ,dmb_loop_bithi      );
                read_dmb_oe_         = ExtractValueFromData(data,dmb_oe_bitlo        ,dmb_oe_bithi        );
                read_gtl_loop_       = ExtractValueFromData(data,gtl_loop_bitlo      ,gtl_loop_bithi      );
                read_gtl_oe_         = ExtractValueFromData(data,gtl_oe_bitlo        ,gtl_oe_bithi        );
                //
            } else if ( address == vme_dddsm_adr ) {    
                //------------------------------------------------------------------
                //0X14 = ADR_DDDSM:  3D3444 State Machine Control + DCM Lock Status  
                //------------------------------------------------------------------
                read_ddd_state_machine_start_            = ExtractValueFromData(data,ddd_state_machine_start_bitlo     ,ddd_state_machine_start_bithi     );
                read_ddd_state_machine_manual_           = ExtractValueFromData(data,ddd_state_machine_manual_bitlo    ,ddd_state_machine_manual_bithi    );
                read_ddd_state_machine_latch_            = ExtractValueFromData(data,ddd_state_machine_latch_bitlo     ,ddd_state_machine_latch_bithi     );
                read_ddd_state_machine_serial_in_        = ExtractValueFromData(data,ddd_state_machine_serial_in_bitlo ,ddd_state_machine_serial_in_bithi );
                read_ddd_state_machine_serial_out_       = ExtractValueFromData(data,ddd_state_machine_serial_out_bitlo,ddd_state_machine_serial_out_bithi);
                read_ddd_state_machine_autostart_        = ExtractValueFromData(data,ddd_state_machine_autostart_bitlo ,ddd_state_machine_autostart_bithi );
                read_ddd_state_machine_busy_             = ExtractValueFromData(data,ddd_state_machine_busy_bitlo      ,ddd_state_machine_busy_bithi      );
                read_ddd_state_machine_verify_ok_        = ExtractValueFromData(data,ddd_state_machine_verify_ok_bitlo ,ddd_state_machine_verify_ok_bithi );
                read_ddd_state_machine_clock0_lock_      = ExtractValueFromData(data,ddd_state_machine_clock0_lock_bitlo,
                        ddd_state_machine_clock0_lock_bithi);
                read_ddd_state_machine_clock0d_lock_     = ExtractValueFromData(data,ddd_state_machine_clock0d_lock_bitlo,
                        ddd_state_machine_clock0d_lock_bithi);
                read_ddd_state_machine_clock1_lock_      = ExtractValueFromData(data,ddd_state_machine_clock1_lock_bitlo,
                        ddd_state_machine_clock1_lock_bithi);
                read_ddd_state_machine_clock_alct_lock_  = ExtractValueFromData(data,ddd_state_machine_clock_alct_lock_bitlo,
                        ddd_state_machine_clock_alct_lock_bithi);
                read_ddd_state_machine_clockd_alct_lock_ = ExtractValueFromData(data,ddd_state_machine_clockd_alct_lock_bitlo,
                        ddd_state_machine_clockd_alct_lock_bithi);
                read_ddd_state_machine_clock_cfeb_lock_  = ExtractValueFromData(data,ddd_state_machine_clock_cfeb_lock_bitlo,
                        ddd_state_machine_clock_cfeb_lock_bithi);
                read_ddd_state_machine_clock_dcc_lock_   = ExtractValueFromData(data,ddd_state_machine_clock_dcc_lock_bitlo,
                        ddd_state_machine_clock_dcc_lock_bithi);
                read_ddd_state_machine_clock_rpc_lock_   = ExtractValueFromData(data,ddd_state_machine_clock_rpc_lock_bitlo,
                        ddd_state_machine_clock_rpc_lock_bithi);
                //
            } else if ( address == vme_ddd0_adr ) {
                //------------------------------------------------------------------
                //0X16 = ADR_DDD0:  3D3444 Chip 0 Delays, 1 step = 2ns
                //------------------------------------------------------------------
                read_alct_tof_delay_      = ExtractValueFromData(data,alct_tof_delay_bitlo     ,alct_tof_delay_bithi     );
                read_dmb_tx_delay_        = ExtractValueFromData(data,dmb_tx_delay_bitlo       ,dmb_tx_delay_bithi       );
                read_rat_tmb_delay_       = ExtractValueFromData(data,rat_tmb_delay_bitlo      ,rat_tmb_delay_bithi      );
                //
            } else if ( address == vme_ddd1_adr ) {
                //------------------------------------------------------------------
                //0X18 = ADR_DDD1:  3D3444 Chip 1 Delays, 1 step = 2ns
                //------------------------------------------------------------------
                read_tmb1_phase_          = ExtractValueFromData(data,tmb1_phase_bitlo     ,tmb1_phase_bithi          );
                read_cfeb_tof_delay_      = ExtractValueFromData(data,cfeb_tof_delay_bitlo ,cfeb_tof_delay_bithi      );
                read_cfeb0_tof_delay_     = ExtractValueFromData(data,cfeb0_tof_delay_bitlo,cfeb0_tof_delay_bithi);
                //
            } else if ( address == vme_ddd2_adr ) {
                //------------------------------------------------------------------
                //0X1A = ADR_DDD2:  3D3444 Chip 2 Delays, 1 step = 2ns
                //------------------------------------------------------------------
                read_cfeb1_tof_delay_ = ExtractValueFromData(data,cfeb1_tof_delay_bitlo,cfeb1_tof_delay_bithi);
                read_cfeb2_tof_delay_ = ExtractValueFromData(data,cfeb2_tof_delay_bitlo,cfeb2_tof_delay_bithi);
                read_cfeb3_tof_delay_ = ExtractValueFromData(data,cfeb3_tof_delay_bitlo,cfeb3_tof_delay_bithi);
                read_cfeb4_tof_delay_ = ExtractValueFromData(data,cfeb4_tof_delay_bitlo,cfeb4_tof_delay_bithi);
                //
            } else if ( address == vme_ratctrl_adr ) {
                //------------------------------------------------------------------
                //0X1E = ADR_RATCTRL:  RAT Module Control
                //------------------------------------------------------------------
                read_rpc_sync_   = ExtractValueFromData(data,rpc_sync_bitlo  ,rpc_sync_bithi  );
                read_shift_rpc_  = ExtractValueFromData(data,shift_rpc_bitlo ,shift_rpc_bithi );
                read_rat_dsn_en_ = ExtractValueFromData(data,rat_dsn_en_bitlo,rat_dsn_en_bithi);
                //
            } else if ( address == vme_adc_adr ) {
                //------------------------------------------------------------------
                //0X24 = ADR_ADC:  ADC + power comparator
                //------------------------------------------------------------------
                read_adc_vstat_5p0v_        = ExtractValueFromData(data,adc_vstat_5p0v_bitlo         ,adc_vstat_5p0v_bithi         );
                read_adc_vstat_3p3v_        = ExtractValueFromData(data,adc_vstat_3p3v_bitlo         ,adc_vstat_3p3v_bithi         );
                read_adc_vstat_1p8v_        = ExtractValueFromData(data,adc_vstat_1p8v_bitlo         ,adc_vstat_1p8v_bithi         );
                read_adc_vstat_1p5v_        = ExtractValueFromData(data,adc_vstat_1p5v_bitlo         ,adc_vstat_1p5v_bithi         );
                read_temp_not_critical_ = ExtractValueFromData(data,temp_not_critical_bitlo  ,temp_not_critical_bithi  );
                read_voltage_adc_data_out_     = ExtractValueFromData(data,voltage_adc_data_out_bitlo    ,voltage_adc_data_out_bithi    );
                read_voltage_adc_serial_clock_ = ExtractValueFromData(data,voltage_adc_serial_clock_bitlo,voltage_adc_serial_clock_bithi);
                read_voltage_adc_data_in_      = ExtractValueFromData(data,voltage_adc_data_in_bitlo     ,voltage_adc_data_in_bithi     );
                read_voltage_adc_chip_select_  = ExtractValueFromData(data,voltage_adc_chip_select_bitlo ,voltage_adc_chip_select_bithi );
                read_temperature_adc_serial_clock_ = ExtractValueFromData(data,temperature_adc_serial_clock_bitlo,temperature_adc_serial_clock_bithi);
                read_temperature_adc_serial_data_  = ExtractValueFromData(data,temperature_adc_serial_data_bitlo ,temperature_adc_serial_data_bithi );
                //
            } else if ( address == ccb_cfg_adr ) {
                //------------------------------------------------------------------
                //0X2A = ADR_CCB_CFG:  CCB Configuration
                //------------------------------------------------------------------
                read_ignore_ccb_rx_                 = ExtractValueFromData(data,ignore_ccb_rx_bitlo                ,ignore_ccb_rx_bithi                );
                read_disable_ccb_tx_                = ExtractValueFromData(data,disable_ccb_tx_bitlo               ,disable_ccb_tx_bithi               );
                read_enable_internal_l1a_           = ExtractValueFromData(data,enable_internal_l1a_bitlo          ,enable_internal_l1a_bithi          );
                read_enable_alctclct_status_to_ccb_ = ExtractValueFromData(data,enable_alctclct_status_to_ccb_bitlo,enable_alctclct_status_to_ccb_bithi);
                read_enable_alct_status_to_ccb_     = ExtractValueFromData(data,enable_alct_status_to_ccb_bitlo    ,enable_alct_status_to_ccb_bithi    );
                read_enable_clct_status_to_ccb_     = ExtractValueFromData(data,enable_clct_status_to_ccb_bitlo    ,enable_clct_status_to_ccb_bithi    );
                read_fire_l1a_oneshot_              = ExtractValueFromData(data,fire_l1a_oneshot_bitlo             ,fire_l1a_oneshot_bithi             );
                //
            } else if ( address == ccb_trig_adr ) {
                //------------------------------------------------------------------
                //0X2C = ADR_CCB_TRIG:  CCB Trigger Control
                //------------------------------------------------------------------
                read_alct_ext_trig_l1aen_    = ExtractValueFromData(data,alct_ext_trig_l1aen_bitlo   ,alct_ext_trig_l1aen_bithi   );
                read_clct_ext_trig_l1aen_    = ExtractValueFromData(data,clct_ext_trig_l1aen_bitlo   ,clct_ext_trig_l1aen_bithi   );
                read_request_l1a_            = ExtractValueFromData(data,request_l1a_bitlo           ,request_l1a_bithi           );
                read_alct_ext_trig_vme_      = ExtractValueFromData(data,alct_ext_trig_vme_bitlo     ,alct_ext_trig_vme_bithi     );
                read_clct_ext_trig_vme_      = ExtractValueFromData(data,clct_ext_trig_vme_bitlo     ,clct_ext_trig_vme_bithi     );
                read_ext_trig_both_          = ExtractValueFromData(data,ext_trig_both_bitlo         ,ext_trig_both_bithi         );
                read_ccb_allow_bypass_       = ExtractValueFromData(data,ccb_allow_bypass_bitlo      ,ccb_allow_bypass_bithi      );
                read_ignore_ccb_startstop_   = ExtractValueFromData(data,ignore_ccb_startstop_bitlo  ,ignore_ccb_startstop_bithi  );
                read_internal_l1a_delay_vme_ = ExtractValueFromData(data,internal_l1a_delay_vme_bitlo,internal_l1a_delay_vme_bithi);
                //
            } else if ( address == alct_cfg_adr ) {
                //------------------------------------------------------------------
                //0X30 = ADR_ALCT_CFG:  ALCT Configuration
                //------------------------------------------------------------------
                read_cfg_alct_ext_trig_en_   = ExtractValueFromData(data,cfg_alct_ext_trig_en_bitlo  ,cfg_alct_ext_trig_en_bithi  ); 
                read_cfg_alct_ext_inject_en_ = ExtractValueFromData(data,cfg_alct_ext_inject_en_bitlo,cfg_alct_ext_inject_en_bithi); 
                read_cfg_alct_ext_trig_      = ExtractValueFromData(data,cfg_alct_ext_trig_bitlo     ,cfg_alct_ext_trig_bithi     ); 
                read_cfg_alct_ext_inject_    = ExtractValueFromData(data,cfg_alct_ext_inject_bitlo   ,cfg_alct_ext_inject_bithi   ); 
                read_alct_seq_cmd_           = ExtractValueFromData(data,alct_seq_cmd_bitlo          ,alct_seq_cmd_bithi          ); 
                read_alct_clock_en_use_ccb_  = ExtractValueFromData(data,alct_clock_en_use_ccb_bitlo ,alct_clock_en_use_ccb_bithi ); 
                read_alct_clock_en_use_vme_  = ExtractValueFromData(data,alct_clock_en_use_vme_bitlo ,alct_clock_en_use_vme_bithi ); 
                read_alct_muonic_            = ExtractValueFromData(data,alct_muonic_bitlo           ,alct_muonic_bithi           ); 
                read_cfeb_muonic_            = ExtractValueFromData(data,cfeb_muonic_bitlo           ,cfeb_muonic_bithi           ); 
                //
            } else if ( address == alct_inj_adr ) {
                //------------------------------------------------------------------
                //0X32 = ADR_ALCT_INJ:  ALCT Injector Control
                //------------------------------------------------------------------
                read_alct_clear_      = ExtractValueFromData(data,alct_clear_bitlo     ,alct_clear_bithi     );
                read_alct_inject_mux_ = ExtractValueFromData(data,alct_inject_mux_bitlo,alct_inject_mux_bithi);
                read_alct_sync_clct_  = ExtractValueFromData(data,alct_sync_clct_bitlo ,alct_sync_clct_bithi );
                read_alct_inj_delay_  = ExtractValueFromData(data,alct_inj_delay_bitlo ,alct_inj_delay_bithi );
                //
            } else if ( address == alct_stat_adr ) {
                //------------------------------------------------------------------
                //0X38 = ADR_ALCT_STAT:  ALCT Sequencer Control/Status
                //------------------------------------------------------------------
                read_alct_cfg_done_       = ExtractValueFromData(data,alct_cfg_done_bitlo     ,alct_cfg_done_bithi     );
                read_alct_ecc_en_         = ExtractValueFromData(data,alct_ecc_en_bitlo       ,alct_ecc_en_bithi       );    
                read_alct_ecc_err_blank_  = ExtractValueFromData(data,alct_ecc_err_blank_bitlo,alct_ecc_err_blank_bithi);
                read_alct_sync_ecc_err_   = ExtractValueFromData(data,alct_sync_ecc_err_bitlo ,alct_sync_ecc_err_bithi );
                read_alct_txdata_delay_   = ExtractValueFromData(data,alct_txdata_delay_bitlo ,alct_txdata_delay_bithi );
                //
            } else if ( address == alct_alct0_adr ) {
                //------------------------------------------------------------------
                //0X3A = ADR_ALCT0_RCD:  ALCT 1st Muon received by TMB
                //------------------------------------------------------------------
                read_alct0_valid_   = ExtractValueFromData(data,alct0_valid_bitlo  ,alct0_valid_bithi  );
                read_alct0_quality_ = ExtractValueFromData(data,alct0_quality_bitlo,alct0_quality_bithi);
                read_alct0_amu_     = ExtractValueFromData(data,alct0_amu_bitlo    ,alct0_amu_bithi    );
                read_alct0_key_wg_  = ExtractValueFromData(data,alct0_key_wg_bitlo ,alct0_key_wg_bithi );
                read_alct0_bxn_     = ExtractValueFromData(data,alct0_bxn_bitlo    ,alct0_bxn_bithi    );
                //
            } else if ( address == alct_alct1_adr ) {
                //------------------------------------------------------------------
                //0X3C = ADR_ALCT1_RCD:  ALCT 2nd Muon received by TMB
                //------------------------------------------------------------------
                read_alct1_valid_   = ExtractValueFromData(data,alct1_valid_bitlo  ,alct1_valid_bithi  );
                read_alct1_quality_ = ExtractValueFromData(data,alct1_quality_bitlo,alct1_quality_bithi);
                read_alct1_amu_     = ExtractValueFromData(data,alct1_amu_bitlo    ,alct1_amu_bithi    );
                read_alct1_key_wg_  = ExtractValueFromData(data,alct1_key_wg_bitlo ,alct1_key_wg_bithi );
                read_alct1_bxn_     = ExtractValueFromData(data,alct1_bxn_bitlo    ,alct1_bxn_bithi    );
                //
            } else if ( address == alct_fifo_adr ) {
                //------------------------------------------------------------------
                //0X3E = ADR_ALCT_FIFO:  ALCT FIFO RAM Status
                //------------------------------------------------------------------
                read_alct_raw_busy_       = ExtractValueFromData(data,alct_raw_busy_bitlo      ,alct_raw_busy_bithi      );
                read_alct_raw_done_       = ExtractValueFromData(data,alct_raw_done_bitlo      ,alct_raw_done_bithi      );
                read_alct_raw_word_count_ = ExtractValueFromData(data,alct_raw_word_count_bitlo,alct_raw_word_count_bithi);
                read_alct_raw_msbs_       = ExtractValueFromData(data,alct_raw_msbs_bitlo      ,alct_raw_msbs_bithi      );
                //
            } else if ( address == cfeb_inj_adr ) {
                //------------------------------------------------------------------
                //0X42 = ADR_CFEB_INJ:  CFEB Injector Control
                //------------------------------------------------------------------
                read_enableCLCTInputs_  = ExtractValueFromData(data,enableCLCTInputs_bitlo ,enableCLCTInputs_bithi );
                read_cfeb_ram_sel_      = ExtractValueFromData(data,cfeb_ram_sel_bitlo     ,cfeb_ram_sel_bithi     );
                read_cfeb_inj_en_sel_   = ExtractValueFromData(data,cfeb_inj_en_sel_bitlo  ,cfeb_inj_en_sel_bithi  );
                read_start_pattern_inj_ = ExtractValueFromData(data,start_pattern_inj_bitlo,start_pattern_inj_bithi);
                //
            } else if ( address == hcm001_adr || address == hcm023_adr || address == hcm045_adr ||
                    address == hcm101_adr || address == hcm123_adr || address == hcm145_adr ||
                    address == hcm201_adr || address == hcm223_adr || address == hcm245_adr ||
                    address == hcm301_adr || address == hcm323_adr || address == hcm345_adr ||
                    address == hcm401_adr || address == hcm423_adr || address == hcm445_adr ) {
                //------------------------------------------------------------------
                //0X4A,4C,4E = ADR_HCM001,HCM023,HCM045 = CFEB0 Hot Channel Masks
                //0X50,52,54 = ADR_HCM101,HCM123,HCM145 = CFEB1 Hot Channel Masks
                //0X56,58,5A = ADR_HCM201,HCM223,HCM245 = CFEB2 Hot Channel Masks
                //0X5C,5E,60 = ADR_HCM301,HCM323,HCM345 = CFEB3 Hot Channel Masks
                //0X62,64,66 = ADR_HCM401,HCM423,HCM445 = CFEB4 Hot Channel Masks
                //------------------------------------------------------------------
                for (int bit_in_register=0; bit_in_register<16; bit_in_register++) {
                    //
                    // get the layer and distrip channels covered by this register
                    int layer   = GetHotChannelLayerFromMap_(address,bit_in_register);
                    int distrip = GetHotChannelDistripFromMap_(address,bit_in_register);
                    //
                    read_hot_channel_mask_[layer][distrip] = ExtractValueFromData(data,bit_in_register,bit_in_register);
                }
                //
            } else if ( address == seq_trig_en_adr ) {
                //------------------------------------------------------------------
                //0X68 = ADR_SEQ_TRIG_EN:  Sequencer Trigger Source Enables
                //------------------------------------------------------------------
                read_clct_pat_trig_en_   = ExtractValueFromData(data,clct_pat_trig_en_bitlo  ,clct_pat_trig_en_bithi  );
                read_alct_pat_trig_en_   = ExtractValueFromData(data,alct_pat_trig_en_bitlo  ,alct_pat_trig_en_bithi  );
                read_match_pat_trig_en_  = ExtractValueFromData(data,match_pat_trig_en_bitlo ,match_pat_trig_en_bithi );
                read_adb_ext_trig_en_    = ExtractValueFromData(data,adb_ext_trig_en_bitlo   ,adb_ext_trig_en_bithi   );
                read_dmb_ext_trig_en_    = ExtractValueFromData(data,dmb_ext_trig_en_bitlo   ,dmb_ext_trig_en_bithi   );
                read_clct_ext_trig_en_   = ExtractValueFromData(data,clct_ext_trig_en_bitlo  ,clct_ext_trig_en_bithi  );
                read_alct_ext_trig_en_   = ExtractValueFromData(data,alct_ext_trig_en_bitlo  ,alct_ext_trig_en_bithi  );
                read_vme_ext_trig_       = ExtractValueFromData(data,vme_ext_trig_bitlo      ,vme_ext_trig_bithi      );
                read_ext_trig_inject_    = ExtractValueFromData(data,ext_trig_inject_bitlo   ,ext_trig_inject_bithi   );
                read_all_cfeb_active_    = ExtractValueFromData(data,all_cfeb_active_bitlo   ,all_cfeb_active_bithi   );
                read_cfebs_enabled_      = ExtractValueFromData(data,cfebs_enabled_bitlo     ,cfebs_enabled_bithi     );
                read_cfeb_enable_source_ = ExtractValueFromData(data,cfeb_enable_source_bitlo,cfeb_enable_source_bithi);
                //    
            } else if ( address == seq_trig_dly0_adr ) {
                //------------------------------------------------------------------
                //0X6A = ADR_SEQ_TRIG_DLY0:  Sequencer Trigger Source Delays
                //------------------------------------------------------------------
                read_alct_pretrig_width_ = ExtractValueFromData(data,alct_pretrig_width_bitlo,alct_pretrig_width_bithi);
                read_alct_pretrig_delay_ = ExtractValueFromData(data,alct_pretrig_delay_bitlo,alct_pretrig_delay_bithi);
                read_alct_pattern_delay_ = ExtractValueFromData(data,alct_pattern_delay_bitlo,alct_pattern_delay_bithi);
                read_adb_ext_trig_delay_ = ExtractValueFromData(data,adb_ext_trig_delay_bitlo,adb_ext_trig_delay_bithi);
                //
            } else if ( address == seq_trig_dly1_adr ) {
                //------------------------------------------------------------------
                //0X6C = ADR_SEQ_TRIG_DLY1:  Sequencer Trigger Source Delays
                //------------------------------------------------------------------
                read_dmb_ext_trig_delay_    =  ExtractValueFromData(data,dmb_ext_trig_delay_bitlo ,dmb_ext_trig_delay_bithi );
                read_clct_ext_trig_delay_   =  ExtractValueFromData(data,clct_ext_trig_delay_bitlo,clct_ext_trig_delay_bithi);
                read_alct_ext_trig_delay_   =  ExtractValueFromData(data,alct_ext_trig_delay_bitlo,alct_ext_trig_delay_bithi);
                //
            } else if ( address == seq_id_adr ) {
                //------------------------------------------------------------------
                //0X6E = ADR_SEQ_ID:  Sequencer Board + CSC Ids
                //------------------------------------------------------------------
                read_tmb_slot_ = ExtractValueFromData(data,tmb_slot_bitlo,tmb_slot_bithi);
                read_csc_id_   = ExtractValueFromData(data,csc_id_bitlo  ,csc_id_bithi  );
                read_run_id_   = ExtractValueFromData(data,run_id_bitlo  ,run_id_bithi  );
                //
            } else if ( address == seq_clct_adr ) {
                //------------------------------------------------------------------
                //0X70 = ADR_SEQ_CLCT:  Sequencer CLCT configuration
                //------------------------------------------------------------------
                read_triad_persist_    = ExtractValueFromData(data,triad_persist_bitlo   ,triad_persist_bithi   );
                read_hit_thresh_       = ExtractValueFromData(data,hit_thresh_bitlo      ,hit_thresh_bithi      );
                read_aff_thresh_       = ExtractValueFromData(data,aff_thresh_bitlo      ,aff_thresh_bithi      );
                read_min_hits_pattern_ = ExtractValueFromData(data,min_hits_pattern_bitlo,min_hits_pattern_bithi);
                read_drift_delay_      = ExtractValueFromData(data,drift_delay_bitlo     ,drift_delay_bithi     );
                read_pretrigger_halt_  = ExtractValueFromData(data,pretrigger_halt_bitlo ,pretrigger_halt_bithi );
                //
            } else if ( address == seq_fifo_adr ) {
                //------------------------------------------------------------------
                //0X72 = ADR_SEQ_FIFO:  Sequencer FIFO configuration
                //------------------------------------------------------------------
                read_fifo_mode_            = ExtractValueFromData(data,fifo_mode_bitlo           ,fifo_mode_bithi           );
                read_fifo_tbins_           = ExtractValueFromData(data,fifo_tbins_bitlo          ,fifo_tbins_bithi          );
                read_fifo_pretrig_         = ExtractValueFromData(data,fifo_pretrig_bitlo        ,fifo_pretrig_bithi        );
                read_fifo_no_raw_hits_     = ExtractValueFromData(data,fifo_no_raw_hits_bitlo    ,fifo_no_raw_hits_bithi    );
                read_cfeb_badbits_readout_ = ExtractValueFromData(data,cfeb_badbits_readout_bitlo,cfeb_badbits_readout_bithi);
                //
            } else if ( address == seq_l1a_adr ) {
                //------------------------------------------------------------------
                //0X74 = ADR_SEQ_L1A:  Sequencer L1A configuration
                //------------------------------------------------------------------
                read_l1adelay_         = ExtractValueFromData(data,l1adelay_bitlo        ,l1adelay_bithi        );
                read_l1a_window_size_  = ExtractValueFromData(data,l1a_window_size_bitlo ,l1a_window_size_bithi );
                read_tmb_l1a_internal_ = ExtractValueFromData(data,tmb_l1a_internal_bitlo,tmb_l1a_internal_bithi);
                //
            } else if ( address == seq_offset_adr ) {
                //------------------------------------------------------------------
                //0X76 = ADR_SEQ_OFFSET:  Sequencer Counter Offsets
                //------------------------------------------------------------------
                read_l1a_offset_ = ExtractValueFromData(data,l1a_offset_bitlo,l1a_offset_bithi);
                read_bxn_offset_ = ExtractValueFromData(data,bxn_offset_bitlo,bxn_offset_bithi);
                //    
            } else if ( address == seq_clct0_adr ) {
                //------------------------------------------------------------------
                //0X78 = ADR_SEQ_CLCT0:  Sequencer Latched CLCT0
                //------------------------------------------------------------------
                read_CLCT0_valid_        = ExtractValueFromData(data,CLCT0_valid_bitlo       ,CLCT0_valid_bithi       );
                read_CLCT0_nhit_         = ExtractValueFromData(data,CLCT0_nhit_bitlo        ,CLCT0_nhit_bithi        );
                read_CLCT0_pattern_      = ExtractValueFromData(data,CLCT0_pattern_bitlo     ,CLCT0_pattern_bithi     );
                read_CLCT0_keyHalfStrip_ = ExtractValueFromData(data,CLCT0_keyHalfStrip_bitlo,CLCT0_keyHalfStrip_bithi);
                //    
            } else if ( address == seq_clct1_adr ) {
                //------------------------------------------------------------------
                //0X7A = ADR_SEQ_CLCT1:  Sequencer Latched CLCT1
                //------------------------------------------------------------------
                read_CLCT1_valid_        = ExtractValueFromData(data,CLCT1_valid_bitlo       ,CLCT1_valid_bithi       );
                read_CLCT1_nhit_         = ExtractValueFromData(data,CLCT1_nhit_bitlo        ,CLCT1_nhit_bithi        );
                read_CLCT1_pattern_      = ExtractValueFromData(data,CLCT1_pattern_bitlo     ,CLCT1_pattern_bithi     );
                read_CLCT1_keyHalfStrip_ = ExtractValueFromData(data,CLCT1_keyHalfStrip_bitlo,CLCT1_keyHalfStrip_bithi);
                //    
            } else if ( address == tmb_trig_adr ) {
                //------------------------------------------------------------------
                //0X86 = ADR_TMB_TRIG:  TMB Trigger configuration/MPC accept
                //------------------------------------------------------------------
                read_tmb_sync_err_enable_ = ExtractValueFromData(data,tmb_sync_err_enable_bitlo,tmb_sync_err_enable_bithi);
                read_tmb_allow_alct_      = ExtractValueFromData(data,tmb_allow_alct_bitlo     ,tmb_allow_alct_bithi     );
                read_tmb_allow_clct_      = ExtractValueFromData(data,tmb_allow_clct_bitlo     ,tmb_allow_clct_bithi     );
                read_tmb_allow_match_     = ExtractValueFromData(data,tmb_allow_match_bitlo    ,tmb_allow_match_bithi    );
                read_mpc_rx_delay_        = ExtractValueFromData(data,mpc_rx_delay_bitlo       ,mpc_rx_delay_bithi       );
                read_mpc_accept_          = ExtractValueFromData(data,mpc_accept_bitlo         ,mpc_accept_bithi         );
                read_mpc_reserved_        = ExtractValueFromData(data,mpc_reserved_bitlo       ,mpc_reserved_bithi       );
                read_mpc_sel_ttc_bx0_     = ExtractValueFromData(data,mpc_sel_ttc_bx0_bitlo    ,mpc_sel_ttc_bx0_bithi    );
                read_mpc_idle_blank_      = ExtractValueFromData(data,mpc_idle_blank_bitlo     ,mpc_idle_blank_bithi     );
                read_mpc_output_enable_   = ExtractValueFromData(data,mpc_output_enable_bitlo  ,mpc_output_enable_bithi  );
                //
            } else if ( address == scp_ctrl_adr ) {
                //------------------------------------------------------------------
                //0X98 = ADR_SCP_CTRL:  Scope Control
                //------------------------------------------------------------------
                read_scope_in_readout_   = ExtractValueFromData(data,scope_in_readout_bitlo,scope_in_readout_bithi);
                //
            } else if ( address == alctfifo1_adr ) {
                //------------------------------------------------------------------
                //0XA8 = ADR_ALCTFIFO1:  ALCT Raw Hits RAM control 
                //------------------------------------------------------------------
                read_alct_raw_reset_        = ExtractValueFromData(data,alct_raw_reset_bitlo       ,alct_raw_reset_bithi       );
                read_alct_raw_read_address_ = ExtractValueFromData(data,alct_raw_read_address_bitlo,alct_raw_read_address_bithi);
                read_alct_demux_mode_       = ExtractValueFromData(data,alct_demux_mode_bitlo      ,alct_demux_mode_bithi      );
                //
            } else if ( address == alctfifo2_adr ) {
                //------------------------------------------------------------------
                //0XAA = ADR_ALCTFIFO2:  ALCT Raw Hits RAM data 
                //------------------------------------------------------------------
                read_alct_raw_lsbs_ = ExtractValueFromData(data,alct_raw_lsbs_bitlo,alct_raw_lsbs_bithi);
                //
            } else if ( address == seqmod_adr ) {
                //------------------------------------------------------------------
                //0XAC = ADR_SEQMOD:  Sequencer Trigger Modifiers
                //------------------------------------------------------------------
                read_clct_flush_delay_             = ExtractValueFromData(data,clct_flush_delay_bitlo            ,clct_flush_delay_bithi            );
                read_wr_buffer_autoclear_          = ExtractValueFromData(data,wr_buffer_autoclear_bitlo         ,wr_buffer_autoclear_bithi         );
                read_clct_write_continuous_enable_ = ExtractValueFromData(data,clct_write_continuous_enable_bitlo,clct_write_continuous_enable_bithi);
                read_wrt_buf_required_             = ExtractValueFromData(data,wrt_buf_required_bitlo            ,wrt_buf_required_bithi            );
                read_valid_clct_required_          = ExtractValueFromData(data,valid_clct_required_bitlo         ,valid_clct_required_bithi         );
                read_l1a_allow_match_              = ExtractValueFromData(data,l1a_allow_match_bitlo             ,l1a_allow_match_bithi             );
                read_l1a_allow_notmb_              = ExtractValueFromData(data,l1a_allow_notmb_bitlo             ,l1a_allow_notmb_bithi             );
                read_l1a_allow_nol1a_              = ExtractValueFromData(data,l1a_allow_nol1a_bitlo             ,l1a_allow_nol1a_bithi             );
                read_l1a_allow_alct_only_          = ExtractValueFromData(data,l1a_allow_alct_only_bitlo         ,l1a_allow_alct_only_bithi         );
                read_scint_veto_clr_               = ExtractValueFromData(data,scint_veto_clr_bitlo              ,scint_veto_clr_bithi              );
                read_scint_veto_vme_               = ExtractValueFromData(data,scint_veto_vme_bitlo              ,scint_veto_vme_bithi              );
                //
            } else if ( address == seqsm_adr ) {
                //------------------------------------------------------------------
                //0XAE = ADR_SEQSM:  Sequencer Machine State
                //------------------------------------------------------------------
                read_clct_state_machine_      = ExtractValueFromData(data,clct_state_machine_bitlo    ,clct_state_machine_bithi    );
                read_readout_state_machine_   = ExtractValueFromData(data,readout_state_machine_bitlo ,readout_state_machine_bithi );
                read_buffer_queue_full_       = ExtractValueFromData(data,buffer_queue_full_bitlo     ,buffer_queue_full_bithi     );
                read_buffer_queue_empty_      = ExtractValueFromData(data,buffer_queue_empty_bitlo    ,buffer_queue_empty_bithi    );
                read_buffer_queue_overflow_   = ExtractValueFromData(data,buffer_queue_overflow_bitlo ,buffer_queue_overflow_bithi );
                read_buffer_queue_underflow_  = ExtractValueFromData(data,buffer_queue_underflow_bitlo,buffer_queue_underflow_bithi);
                //
            } else if ( address == seq_clctm_adr ) {
                //------------------------------------------------------------------
                //0XB0 = ADR_SEQCLCTM:  Sequencer CLCT (Most Significant Bits)
                //------------------------------------------------------------------
                read_CLCT_BXN_      = ExtractValueFromData(data,CLCT_BXN_bitlo     ,CLCT_BXN_bithi     );
                read_CLCT_sync_err_ = ExtractValueFromData(data,CLCT_sync_err_bitlo,CLCT_sync_err_bithi);
                //
            } else if ( address == tmbtim_adr ) {
                //------------------------------------------------------------------
                //0XB2 = ADR_TMBTIM:  TMB Timing for ALCT*CLCT Coincidence
                //------------------------------------------------------------------
                read_alct_vpf_delay_         = ExtractValueFromData(data,alct_vpf_delay_bitlo        ,alct_vpf_delay_bithi        );
                read_alct_match_window_size_ = ExtractValueFromData(data,alct_match_window_size_bitlo,alct_match_window_size_bithi);
                read_mpc_tx_delay_           = ExtractValueFromData(data,mpc_tx_delay_bitlo          ,mpc_tx_delay_bithi          );
                //
            } else if ( address == rpc_cfg_adr ) {
                //------------------------------------------------------------------
                //0XB6 = ADR_RPC_CFG:  RPC Configuration
                //------------------------------------------------------------------
                read_rpc_exists_      = ExtractValueFromData(data,rpc_exists_bitlo     ,rpc_exists_bithi     );
                read_rpc_read_enable_ = ExtractValueFromData(data,rpc_read_enable_bitlo,rpc_read_enable_bithi);
                read_rpc_bxn_offset_  = ExtractValueFromData(data,rpc_bxn_offset_bitlo ,rpc_bxn_offset_bithi );
                read_rpc_bank_        = ExtractValueFromData(data,rpc_bank_bitlo       ,rpc_bank_bithi       );
                read_rpc_rbxn_        = ExtractValueFromData(data,rpc_rbxn_bitlo       ,rpc_rbxn_bithi       );
                read_rpc_done_        = ExtractValueFromData(data,rpc_done_bitlo       ,rpc_done_bithi       );
                //
            } else if ( address == rpc_raw_delay_adr ) {
                //------------------------------------------------------------------
                //0XBA = ADR_RPC_RAW_DELAY:  RPC Raw Hits Data Delay
                //------------------------------------------------------------------
                read_rpc0_raw_delay_ = ExtractValueFromData(data,rpc0_raw_delay_bitlo,rpc0_raw_delay_bithi);
                read_rpc1_raw_delay_ = ExtractValueFromData(data,rpc1_raw_delay_bitlo,rpc1_raw_delay_bithi);
                //
            } else if ( address == rpc_inj_adr ) {
                //------------------------------------------------------------------
                //0XBC = ADR_RPC_INJ:  RPC Injector Control
                //------------------------------------------------------------------
                read_rpc_mask_all_  = ExtractValueFromData(data,rpc_mask_all_bitlo ,rpc_mask_all_bithi );  
                read_inj_mask_rat_  = ExtractValueFromData(data,inj_mask_rat_bitlo ,inj_mask_rat_bithi );  
                read_inj_mask_rpc_  = ExtractValueFromData(data,inj_mask_rpc_bitlo ,inj_mask_rpc_bithi );  
                read_inj_delay_rat_ = ExtractValueFromData(data,inj_delay_rat_bitlo,inj_delay_rat_bithi); 
                read_rpc_inj_sel_   = ExtractValueFromData(data,rpc_inj_sel_bitlo  ,rpc_inj_sel_bithi  );   
                read_rpc_inj_wdata_ = ExtractValueFromData(data,rpc_inj_wdata_bitlo,rpc_inj_wdata_bithi); 
                read_rpc_inj_rdata_ = ExtractValueFromData(data,rpc_inj_rdata_bitlo,rpc_inj_rdata_bithi); 
                //
            } else if ( address == rpc_tbins_adr ) {
                //------------------------------------------------------------------
                //0XC4 = ADR_RPC_TBINS:  RPC FIFO Time Bins
                //------------------------------------------------------------------
                read_fifo_tbins_rpc_   = ExtractValueFromData(data,fifo_tbins_rpc_bitlo  ,fifo_tbins_rpc_bithi  );
                read_fifo_pretrig_rpc_ = ExtractValueFromData(data,fifo_pretrig_rpc_bitlo,fifo_pretrig_rpc_bithi);
                read_rpc_decouple_     = ExtractValueFromData(data,rpc_decouple_bitlo    ,rpc_decouple_bithi    );
                //
            } else if ( address == bx0_delay_adr ) {
                //------------------------------------------------------------------
                //0XCA = ADR_BX0_DELAY:  BX0 to MPC delays
                //------------------------------------------------------------------
                read_alct_bx0_delay_  = ExtractValueFromData(data,alct_bx0_delay_bitlo ,alct_bx0_delay_bithi );
                read_clct_bx0_delay_  = ExtractValueFromData(data,clct_bx0_delay_bitlo ,clct_bx0_delay_bithi );
                read_alct_bx0_enable_ = ExtractValueFromData(data,alct_bx0_enable_bitlo,alct_bx0_enable_bithi);
                read_bx0_vpf_test_    = ExtractValueFromData(data,bx0_vpf_test_bitlo   ,bx0_vpf_test_bithi   );
                read_bx0_match_       = ExtractValueFromData(data,bx0_match_bitlo      ,bx0_match_bithi      );
                //
            } else if ( address == non_trig_readout_adr ) {
                //-----------------------------------------------------------------------------
                //0XCC = ADR_NON_TRIG_RO:  Non-Triggering Event Enables + ME1/1A(1B) reversal 
                //-----------------------------------------------------------------------------
                read_tmb_allow_alct_nontrig_readout_   = ExtractValueFromData(data,tmb_allow_alct_nontrig_readout_bitlo  ,tmb_allow_alct_nontrig_readout_bithi  );
                read_tmb_allow_clct_nontrig_readout_   = ExtractValueFromData(data,tmb_allow_clct_nontrig_readout_bitlo  ,tmb_allow_clct_nontrig_readout_bithi  );
                read_tmb_allow_match_nontrig_readout_  = ExtractValueFromData(data,tmb_allow_match_nontrig_readout_bitlo ,tmb_allow_match_nontrig_readout_bithi );
                read_mpc_block_me1a_                   = ExtractValueFromData(data,mpc_block_me1a_bitlo                  ,mpc_block_me1a_bithi                  );
                read_clct_pretrigger_counter_non_me11_ = ExtractValueFromData(data,clct_pretrigger_counter_non_me11_bitlo,clct_pretrigger_counter_non_me11_bithi);
                read_csc_me11_                         = ExtractValueFromData(data,csc_me11_bitlo                        ,csc_me11_bithi                        );
                read_clct_stagger_                     = ExtractValueFromData(data,clct_stagger_bitlo                    ,clct_stagger_bithi                    );
                read_reverse_stagger_                  = ExtractValueFromData(data,reverse_stagger_bitlo                 ,reverse_stagger_bithi                 );
                read_reverse_me1a_                     = ExtractValueFromData(data,reverse_me1a_bitlo                    ,reverse_me1a_bithi                    );
                read_reverse_me1b_                     = ExtractValueFromData(data,reverse_me1b_bitlo                    ,reverse_me1b_bithi                    );
                read_tmb_firmware_compile_type_        = ExtractValueFromData(data,tmb_firmware_compile_type_bitlo       ,tmb_firmware_compile_type_bithi       );
                //
            } else if ( address == jtag_sm_ctrl_adr ) {
                //------------------------------------------------------------------
                //0XD4 = ADR_JTAGSM0:  JTAG State Machine Control (reads JTAG PROM)
                //------------------------------------------------------------------
                read_jtag_state_machine_start_       = ExtractValueFromData(data,jtag_state_machine_start_bitlo      ,jtag_state_machine_start_bithi      );
                read_jtag_state_machine_sreset_      = ExtractValueFromData(data,jtag_state_machine_sreset_bitlo     ,jtag_state_machine_sreset_bithi     );
                read_jtag_state_machine_autostart_   = ExtractValueFromData(data,jtag_state_machine_autostart_bitlo  ,jtag_state_machine_autostart_bithi  );
                read_jtag_state_machine_busy_        = ExtractValueFromData(data,jtag_state_machine_busy_bitlo       ,jtag_state_machine_busy_bithi       );
                read_jtag_state_machine_aborted_     = ExtractValueFromData(data,jtag_state_machine_aborted_bitlo    ,jtag_state_machine_aborted_bithi    );
                read_jtag_state_machine_cksum_ok_    = ExtractValueFromData(data,jtag_state_machine_cksum_ok_bitlo   ,jtag_state_machine_cksum_ok_bithi   );
                read_jtag_state_machine_wdcnt_ok_    = ExtractValueFromData(data,jtag_state_machine_wdcnt_ok_bitlo   ,jtag_state_machine_wdcnt_ok_bithi   );
                read_jtag_state_machine_tck_fpga_ok_ = ExtractValueFromData(data,jtag_state_machine_tck_fpga_ok_bitlo,jtag_state_machine_tck_fpga_ok_bithi);
                read_jtag_state_machine_vme_ready_   = ExtractValueFromData(data,jtag_state_machine_vme_ready_bitlo  ,jtag_state_machine_vme_ready_bithi  );
                read_jtag_state_machine_ok_          = ExtractValueFromData(data,jtag_state_machine_ok_bitlo         ,jtag_state_machine_ok_bithi         );
                read_jtag_state_machine_oe_          = ExtractValueFromData(data,jtag_state_machine_oe_bitlo         ,jtag_state_machine_oe_bithi         );
                read_jtag_disable_write_to_adr10_    = ExtractValueFromData(data,jtag_disable_write_to_adr10_bitlo   ,jtag_disable_write_to_adr10_bithi   );
                read_jtag_state_machine_throttle_    = ExtractValueFromData(data,jtag_state_machine_throttle_bitlo   ,jtag_state_machine_throttle_bithi   );
                //
            } else if ( address == jtag_sm_wdcnt_adr ) {    
                //------------------------------------------------------------------
                //0XD6 = ADR_JTAGSM1:  JTAG State Machine Word Count
                //------------------------------------------------------------------
                read_jtag_state_machine_word_count_ = ExtractValueFromData(data,jtag_state_machine_word_count_bitlo,jtag_state_machine_word_count_bithi);
                //
            } else if ( address == jtag_sm_cksum_adr ) {
                //------------------------------------------------------------------
                //0XD8 = ADR_JTAGSM2:  JTAG State Machine Checksum
                //------------------------------------------------------------------
                read_jtag_state_machine_check_sum_ = ExtractValueFromData(data,jtag_state_machine_check_sum_bitlo,jtag_state_machine_check_sum_bithi);
                read_jtag_state_machine_tck_fpga_  = ExtractValueFromData(data,jtag_state_machine_tck_fpga_bitlo ,jtag_state_machine_tck_fpga_bithi );
                //
            } else if ( address == vme_sm_ctrl_adr ) {
                //------------------------------------------------------------------
                //0XDA = ADR_VMESM0:  VME State Machine Control (reads VME PROM)
                //------------------------------------------------------------------
                read_vme_state_machine_start_     = ExtractValueFromData(data,vme_state_machine_start_bitlo    ,vme_state_machine_start_bithi    );
                read_vme_state_machine_sreset_    = ExtractValueFromData(data,vme_state_machine_sreset_bitlo   ,vme_state_machine_sreset_bithi   );
                read_vme_state_machine_autostart_ = ExtractValueFromData(data,vme_state_machine_autostart_bitlo,vme_state_machine_autostart_bithi);
                read_vme_state_machine_busy_      = ExtractValueFromData(data,vme_state_machine_busy_bitlo     ,vme_state_machine_busy_bithi     );
                read_vme_state_machine_aborted_   = ExtractValueFromData(data,vme_state_machine_aborted_bitlo  ,vme_state_machine_aborted_bithi  );
                read_vme_state_machine_cksum_ok_  = ExtractValueFromData(data,vme_state_machine_cksum_ok_bitlo ,vme_state_machine_cksum_ok_bithi );
                read_vme_state_machine_wdcnt_ok_  = ExtractValueFromData(data,vme_state_machine_wdcnt_ok_bitlo ,vme_state_machine_wdcnt_ok_bithi );
                read_vme_state_machine_jtag_auto_ = ExtractValueFromData(data,vme_state_machine_jtag_auto_bitlo,vme_state_machine_jtag_auto_bithi);
                read_vme_state_machine_vme_ready_ = ExtractValueFromData(data,vme_state_machine_vme_ready_bitlo,vme_state_machine_vme_ready_bithi);
                read_vme_state_machine_ok_        = ExtractValueFromData(data,vme_state_machine_ok_bitlo       ,vme_state_machine_ok_bithi       );
                read_vme_state_machine_path_ok_   = ExtractValueFromData(data,vme_state_machine_path_ok_bitlo  ,vme_state_machine_path_ok_bithi  );
                read_phase_shifter_auto_          = ExtractValueFromData(data,phase_shifter_auto_bitlo         ,phase_shifter_auto_bithi         );
                read_vme_state_machine_throttle_  = ExtractValueFromData(data,vme_state_machine_throttle_bitlo ,vme_state_machine_throttle_bithi );
                //
            } else if ( address == vme_sm_wdcnt_adr ) {
                //------------------------------------------------------------------
                //0XDC = ADR_VMESM1:  VME State Machine Word Count
                //------------------------------------------------------------------
                read_vme_state_machine_word_count_ = ExtractValueFromData(data,vme_state_machine_word_count_bitlo,vme_state_machine_word_count_bithi);
                //
            } else if ( address == vme_sm_cksum_adr ) {
                //------------------------------------------------------------------
                //0XDE = ADR_VMESM2:  VME State Machine Checksum
                //------------------------------------------------------------------
                read_vme_state_machine_check_sum_                     = ExtractValueFromData(data,vme_state_machine_check_sum_bitlo,
                        vme_state_machine_check_sum_bithi);
                read_vme_state_machine_error_missing_header_start_    = ExtractValueFromData(data,vme_state_machine_error_missing_header_start_bitlo,
                        vme_state_machine_error_missing_header_start_bithi);
                read_vme_state_machine_error_missing_header_end_      = ExtractValueFromData(data,vme_state_machine_error_missing_header_end_bitlo,
                        vme_state_machine_error_missing_header_end_bithi);
                read_vme_state_machine_error_missing_data_end_marker_ = ExtractValueFromData(data,vme_state_machine_error_missing_data_end_marker_bitlo,
                        vme_state_machine_error_missing_data_end_marker_bithi);
                read_vme_state_machine_error_missing_trailer_end_     = ExtractValueFromData(data,vme_state_machine_error_missing_trailer_end_bitlo,
                        vme_state_machine_error_missing_trailer_end_bithi);
                read_vme_state_machine_error_word_count_overflow_     = ExtractValueFromData(data,vme_state_machine_error_word_count_overflow_bitlo,
                        vme_state_machine_error_word_count_overflow_bithi);
                //
            } else if ( address == num_vme_sm_adr_adr ) {
                //------------------------------------------------------------------
                //0XE0 = ADR_VMESM3:  Number of VME addresses written by VMESM
                //------------------------------------------------------------------
                read_vme_state_machine_number_of_vme_writes_ = ExtractValueFromData(data,vme_state_machine_number_of_vme_writes_bitlo,
                        vme_state_machine_number_of_vme_writes_bithi);
                //
            } else if ( address == rat_3d_delays_adr ) {
                //------------------------------------------------------------------
                //0XE6 = ADR_DDDR0:  RAT 3D3444 RPC Delays, 1 step = 2ns
                //------------------------------------------------------------------
                read_rpc0_rat_delay_ = ExtractValueFromData(data,rpc0_rat_delay_bitlo,rpc0_rat_delay_bithi);
                read_rpc1_rat_delay_ = ExtractValueFromData(data,rpc1_rat_delay_bitlo,rpc1_rat_delay_bithi);
                //
            } else if ( address == tmb_stat_adr ) {    
                //---------------------------------------------------------------------
                //0XEA = ADR_BDSTATUS:  Board Status Summary (copy of raw-hits header)
                //---------------------------------------------------------------------
                read_bdstatus_ok_     = ExtractValueFromData(data,bdstatus_ok_bitlo    ,bdstatus_ok_bithi    );
                read_vstat_5p0v_      = ExtractValueFromData(data,vstat_5p0v_bitlo     ,vstat_5p0v_bithi     );
                read_vstat_3p3v_      = ExtractValueFromData(data,vstat_3p3v_bitlo     ,vstat_3p3v_bithi     );
                read_vstat_1p8v_      = ExtractValueFromData(data,vstat_1p8v_bitlo     ,vstat_1p8v_bithi     );
                read_vstat_1p5v_      = ExtractValueFromData(data,vstat_1p5v_bitlo     ,vstat_1p5v_bithi     );
                read_nt_crit_         = ExtractValueFromData(data,nt_crit_bitlo        ,nt_crit_bithi        );
                read_vsm_ok_          = ExtractValueFromData(data,vsm_ok_bitlo         ,vsm_ok_bithi         );
                read_vsm_aborted_     = ExtractValueFromData(data,vsm_aborted_bitlo    ,vsm_aborted_bithi    );
                read_vsm_cksum_ok_    = ExtractValueFromData(data,vsm_cksum_ok_bitlo   ,vsm_cksum_ok_bithi   );
                read_vsm_wdcnt_ok_    = ExtractValueFromData(data,vsm_wdcnt_ok_bitlo   ,vsm_wdcnt_ok_bithi   );
                read_jsm_ok_          = ExtractValueFromData(data,jsm_ok_bitlo         ,jsm_ok_bithi         );
                read_jsm_aborted_     = ExtractValueFromData(data,jsm_aborted_bitlo    ,jsm_aborted_bithi    );
                read_jsm_cksum_ok_    = ExtractValueFromData(data,jsm_cksum_ok_bitlo   ,jsm_cksum_ok_bithi   );
                read_jsm_wdcnt_ok_    = ExtractValueFromData(data,jsm_wdcnt_ok_bitlo   ,jsm_wdcnt_ok_bithi   );
                read_jsm_tck_fpga_ok_ = ExtractValueFromData(data,jsm_tck_fpga_ok_bitlo,jsm_tck_fpga_ok_bithi);
                //
            } else if ( address == layer_trg_mode_adr ) {    
                //---------------------------------------------------------------------
                //0XF0 = ADR_LAYER_TRIG:  Layer-Trigger Mode
                //---------------------------------------------------------------------
                read_layer_trigger_en_   = ExtractValueFromData(data,layer_trigger_en_bitlo ,layer_trigger_en_bithi );
                read_layer_trig_thresh_  = ExtractValueFromData(data,layer_trig_thresh_bitlo,layer_trig_thresh_bithi);
                read_number_layers_hit_  = ExtractValueFromData(data,number_layers_hit_bitlo,number_layers_hit_bithi);
                read_clct_throttle_  = ExtractValueFromData(data,clct_throttle_bitlo,clct_throttle_bithi);
                //
            } else if ( address == pattern_find_pretrg_adr ) {    
                //---------------------------------------------------------------------
                //0XF4 = ADR_TEMP0:  Pattern Finder Pretrigger
                //---------------------------------------------------------------------
                read_clct_blanking_                    = ExtractValueFromData(data,clct_blanking_bitlo                   ,clct_blanking_bithi                   );
                read_clct_stagger_                     = ExtractValueFromData(data,clct_stagger_bitlo                    ,clct_stagger_bithi                    );
                read_clct_pattern_id_thresh_           = ExtractValueFromData(data,clct_pattern_id_thresh_bitlo          ,clct_pattern_id_thresh_bithi          );
                read_clct_pattern_id_thresh_postdrift_ = ExtractValueFromData(data,clct_pattern_id_thresh_postdrift_bitlo,clct_pattern_id_thresh_postdrift_bithi);
                read_adjacent_cfeb_distance_           = ExtractValueFromData(data,adjacent_cfeb_distance_bitlo          ,adjacent_cfeb_distance_bithi          );
                //
            } else if ( address == clct_separation_adr ) {    
                //---------------------------------------------------------------------
                //0XF6 = ADR_TEMP1:  CLCT separation
                //---------------------------------------------------------------------
                read_clct_separation_src_              = ExtractValueFromData(data,clct_separation_src_bitlo             ,clct_separation_src_bithi             );
                read_clct_separation_ram_write_enable_ = ExtractValueFromData(data,clct_separation_ram_write_enable_bitlo,clct_separation_ram_write_enable_bithi);
                read_clct_separation_ram_adr_          = ExtractValueFromData(data,clct_separation_ram_adr_bitlo         ,clct_separation_ram_adr_bithi         );
                read_min_clct_separation_              = ExtractValueFromData(data,min_clct_separation_bitlo             ,min_clct_separation_bithi             );
                //
            } else if ( address == clock_status_adr ) {    
                //---------------------------------------------------------------------
                //0XFC = ADR_CCB_STAT1:  CCB Status Register (cont. from 0x2E)
                //---------------------------------------------------------------------
                read_ccb_ttcrx_lock_never_ = ExtractValueFromData(data,ccb_ttcrx_lock_never_bitlo,ccb_ttcrx_lock_never_bithi);
                read_ccb_ttcrx_lost_ever_  = ExtractValueFromData(data,ccb_ttcrx_lost_ever_bitlo ,ccb_ttcrx_lost_ever_bithi );
                read_ccb_qpll_lock_never_  = ExtractValueFromData(data,ccb_qpll_lock_never_bitlo ,ccb_qpll_lock_never_bithi );
                read_ccb_qpll_lost_ever_   = ExtractValueFromData(data,ccb_qpll_lost_ever_bitlo  ,ccb_qpll_lost_ever_bithi  );
                //
            } else if ( address == l1a_lookback_adr ) {    
                //---------------------------------------------------------------------
                //0X100 = ADR_L1A_LOOKBACK:  L1A Lookback Distance
                //---------------------------------------------------------------------
                read_l1a_allow_notmb_lookback_ = ExtractValueFromData(data,l1a_allow_notmb_lookback_bitlo,l1a_allow_notmb_lookback_bithi);
                read_inj_wrdata_msb_           = ExtractValueFromData(data,inj_wrdata_msb_bitlo          ,inj_wrdata_msb_bithi          );
                read_inj_rdata_msb_            = ExtractValueFromData(data,inj_rdata_msb_bitlo           ,inj_rdata_msb_bithi           );
                read_l1a_priority_enable_      = ExtractValueFromData(data,l1a_priority_enable_bitlo     ,l1a_priority_enable_bithi     );
                //
            } else if ( address == alct_sync_ctrl_adr ) {    
                //---------------------------------------------------------------------
                //0X104 = ADR_ALCT_SYNC_CTRL:  ALCT Sync Mode Control
                //---------------------------------------------------------------------
                read_alct_sync_rxdata_dly_        = ExtractValueFromData(data,alct_sync_rxdata_dly_bitlo       ,alct_sync_rxdata_dly_bithi       );
                read_alct_sync_tx_random_         = ExtractValueFromData(data,alct_sync_tx_random_bitlo        ,alct_sync_tx_random_bithi        );
                read_alct_sync_clear_errors_      = ExtractValueFromData(data,alct_sync_clear_errors_bitlo     ,alct_sync_clear_errors_bithi     );
                read_alct_sync_1st_error_         = ExtractValueFromData(data,alct_sync_1st_error_bitlo        ,alct_sync_1st_error_bithi        );
                read_alct_sync_2nd_error_         = ExtractValueFromData(data,alct_sync_2nd_error_bitlo        ,alct_sync_2nd_error_bithi        );
                read_alct_sync_1st_error_latched_ = ExtractValueFromData(data,alct_sync_1st_error_latched_bitlo,alct_sync_1st_error_latched_bithi);
                read_alct_sync_2nd_error_latched_ = ExtractValueFromData(data,alct_sync_2nd_error_latched_bitlo,alct_sync_2nd_error_latched_bithi);
                //
            } else if ( address == alct_sync_txdata_1st_adr ) {    
                //---------------------------------------------------------------------
                //0X106 = ADR_ALCT_SYNC_TXDATA_1ST:  ALCT Sync Mode Transmit Data 1st
                //---------------------------------------------------------------------
                read_alct_sync_txdata_1st_ = ExtractValueFromData(data,alct_sync_txdata_1st_bitlo,alct_sync_txdata_1st_bithi);
                //
            } else if ( address == alct_sync_txdata_2nd_adr ) {    
                //---------------------------------------------------------------------
                //0X108 = ADR_ALCT_SYNC_TXDATA_2ND:  ALCT Sync Mode Transmit Data 2nd
                //---------------------------------------------------------------------
                read_alct_sync_txdata_2nd_ = ExtractValueFromData(data,alct_sync_txdata_2nd_bitlo,alct_sync_txdata_2nd_bithi);
                //
            } else if ( address == miniscope_adr ) {
                //---------------------------------------------------------------------
                //0X10C = ADR_MINISCOPE:  Internal 16 Channel Digital Scope
                //---------------------------------------------------------------------
                read_miniscope_enable_  = ExtractValueFromData(data,miniscope_enable_bitlo ,miniscope_enable_bithi );
                read_mini_tbins_test_   = ExtractValueFromData(data,mini_tbins_test_bitlo  ,mini_tbins_test_bithi  );
                read_mini_tbins_word_   = ExtractValueFromData(data,mini_tbins_word_bitlo  ,mini_tbins_word_bithi  );
                read_fifo_tbins_mini_   = ExtractValueFromData(data,fifo_tbins_mini_bitlo  ,fifo_tbins_mini_bithi  );
                read_fifo_pretrig_mini_ = ExtractValueFromData(data,fifo_pretrig_mini_bitlo,fifo_pretrig_mini_bithi);
                //
            } else if ( address == phaser_alct_rxd_adr  ||
                    address == phaser_alct_txd_adr  ||
                    address == phaser_cfeb0_rxd_adr ||
                    address == phaser_cfeb1_rxd_adr ||
                    address == phaser_cfeb2_rxd_adr ||
                    address == phaser_cfeb3_rxd_adr ||
                    address == phaser_cfeb4_rxd_adr ) {    
                //---------------------------------------------------------------------
                //(0X10E,0X110,0X112,0X114,0X116,0X118,0X11A) = ADR_PHASER[0-6]:  
                // digital phase shifter for... alct_rx,alct_tx,cfeb[0-4]_rx
                //---------------------------------------------------------------------
                read_fire_phaser_                   = ExtractValueFromData(data,fire_phaser_bitlo                  ,fire_phaser_bithi                  );
                read_reset_phase_                   = ExtractValueFromData(data,reset_phase_bitlo                  ,reset_phase_bithi                  );
                read_phaser_busy_                   = ExtractValueFromData(data,phaser_busy_bitlo                  ,phaser_busy_bithi                  );
                read_digital_clock_manager_locked_  = ExtractValueFromData(data,digital_clock_manager_locked_bitlo ,digital_clock_manager_locked_bithi );
                read_phase_shifter_state_           = ExtractValueFromData(data,phase_shifter_state_bitlo          ,phase_shifter_state_bithi          );
                read_phaser_posneg_                 = ExtractValueFromData(data,phaser_posneg_bitlo                ,phaser_posneg_bithi                );
                read_phase_value_within_quadrant_   = ExtractValueFromData(data,phase_value_within_quadrant_bitlo  ,phase_value_within_quadrant_bithi  ); 
                read_quarter_cycle_quadrant_select_ = ExtractValueFromData(data,quarter_cycle_quadrant_select_bitlo,quarter_cycle_quadrant_select_bithi); 
                read_half_cycle_quadrant_select_    = ExtractValueFromData(data,half_cycle_quadrant_select_bitlo   ,half_cycle_quadrant_select_bithi   ); 
                //
                ConvertVMERegisterValuesToDigitalPhases_(address);
                //
            } else if ( address == cfeb0_3_interstage_adr ) {
                //---------------------------------------------------------------------
                // 0X11C = ADR_DELAY0_INT:  CFEB to TMB "interstage" delays
                //---------------------------------------------------------------------
                read_cfeb0_rxd_int_delay_  = ExtractValueFromData(data,cfeb0_rxd_int_delay_bitlo,cfeb0_rxd_int_delay_bithi);    
                read_cfeb1_rxd_int_delay_  = ExtractValueFromData(data,cfeb1_rxd_int_delay_bitlo,cfeb1_rxd_int_delay_bithi);
                read_cfeb2_rxd_int_delay_  = ExtractValueFromData(data,cfeb2_rxd_int_delay_bitlo,cfeb2_rxd_int_delay_bithi);
                read_cfeb3_rxd_int_delay_  = ExtractValueFromData(data,cfeb3_rxd_int_delay_bitlo,cfeb3_rxd_int_delay_bithi);
                //
            } else if ( address == cfeb4_interstage_adr ) {
                //---------------------------------------------------------------------
                // 0X11E = ADR_DELAY1_INT:  CFEB to TMB "interstage" delays
                //---------------------------------------------------------------------
                read_cfeb4_rxd_int_delay_  = ExtractValueFromData(data,cfeb4_rxd_int_delay_bitlo,cfeb4_rxd_int_delay_bithi);    
                //
            } else if ( address == sync_err_control_adr ) {
                //---------------------------------------------------------------------
                // 0X120 = ADR_SYNC_ERR_CTRL:  Synchronization Error Control
                //---------------------------------------------------------------------
                read_sync_err_reset_                  = ExtractValueFromData(data,sync_err_reset_bitlo                 ,sync_err_reset_bithi               );
                read_clct_bx0_sync_err_enable_        = ExtractValueFromData(data,clct_bx0_sync_err_enable_bitlo       ,clct_bx0_sync_err_enable_bithi     );
                read_alct_ecc_rx_sync_err_enable_     = ExtractValueFromData(data,alct_ecc_rx_sync_err_enable_bitlo    ,alct_ecc_rx_sync_err_enable_bithi  );
                read_alct_ecc_tx_sync_err_enable_     = ExtractValueFromData(data,alct_ecc_tx_sync_err_enable_bitlo    ,alct_ecc_tx_sync_err_enable_bithi  );
                read_bx0_match_sync_err_enable_       = ExtractValueFromData(data,bx0_match_sync_err_enable_bitlo      ,bx0_match_sync_err_enable_bithi    );
                read_clock_lock_lost_sync_err_enable_ = ExtractValueFromData(data,clock_lock_lost_sync_err_enable_bitlo,clock_lock_lost_sync_err_enable_bithi    );
                read_sync_err_blanks_mpc_enable_      = ExtractValueFromData(data,sync_err_blanks_mpc_enable_bitlo     ,sync_err_blanks_mpc_enable_bithi   );
                read_sync_err_stops_pretrig_enable_   = ExtractValueFromData(data,sync_err_stops_pretrig_enable_bitlo  ,sync_err_stops_pretrig_enable_bithi);
                read_sync_err_stops_readout_enable_   = ExtractValueFromData(data,sync_err_stops_readout_enable_bitlo  ,sync_err_stops_readout_enable_bithi);
                read_sync_err_                        = ExtractValueFromData(data,sync_err_bitlo                       ,sync_err_bithi                     );
                read_clct_bx0_sync_err_               = ExtractValueFromData(data,clct_bx0_sync_err_bitlo              ,clct_bx0_sync_err_bithi            );
                read_alct_ecc_rx_sync_err_            = ExtractValueFromData(data,alct_ecc_rx_sync_err_bitlo           ,alct_ecc_rx_sync_err_bithi         );
                read_alct_ecc_tx_sync_err_            = ExtractValueFromData(data,alct_ecc_tx_sync_err_bitlo           ,alct_ecc_tx_sync_err_bithi         );
                read_bx0_match_sync_err_              = ExtractValueFromData(data,bx0_match_sync_err_bitlo             ,bx0_match_sync_err_bithi           );
                read_clock_lock_lost_sync_err_        = ExtractValueFromData(data,clock_lock_lost_sync_err_bitlo       ,clock_lock_lost_sync_err_bithi     );
                //
            } else if ( address == cfeb_badbits_ctrl_adr ) {
                //---------------------------------------------------------------------
                // 0X122 = ADR_CFEB_BADBITS_CTRL:  CFEB badbits control/status
                //---------------------------------------------------------------------
                read_cfeb_badbits_reset_   = ExtractValueFromData(data,cfeb_badbits_reset_bitlo  ,cfeb_badbits_reset_bithi  );
                read_cfeb_badbits_block_   = ExtractValueFromData(data,cfeb_badbits_block_bitlo  ,cfeb_badbits_block_bithi  );
                read_cfeb_badbits_found_   = ExtractValueFromData(data,cfeb_badbits_found_bitlo  ,cfeb_badbits_found_bithi  );
                read_cfeb_badbits_blocked_ = ExtractValueFromData(data,cfeb_badbits_blocked_bitlo,cfeb_badbits_blocked_bithi);
                //
            } else if ( address == cfeb_badbits_timer_adr ) {
                //---------------------------------------------------------------------
                // 0X124 = ADR_CFEB_BADBITS_TIMER:  CFEB badbits check interval
                //---------------------------------------------------------------------
                read_cfeb_badbits_nbx_ = ExtractValueFromData(data,cfeb_badbits_nbx_bitlo,cfeb_badbits_nbx_bithi);
                //
            } else if ( address == badbits001_adr || address == badbits023_adr || address == badbits045_adr ||
                    address == badbits101_adr || address == badbits123_adr || address == badbits145_adr ||
                    address == badbits201_adr || address == badbits223_adr || address == badbits245_adr ||
                    address == badbits301_adr || address == badbits323_adr || address == badbits345_adr ||
                    address == badbits401_adr || address == badbits423_adr || address == badbits445_adr ) {
                //------------------------------------------------------------------
                //0X126,128,12A = ADR_BADBITS001,BADBITS023,BADBITS045 = CFEB0 Hot Channel Masks
                //0X12C,12E,130 = ADR_BADBITS101,BADBITS123,BADBITS145 = CFEB1 Hot Channel Masks
                //0X132,134,136 = ADR_BADBITS201,BADBITS223,BADBITS245 = CFEB2 Hot Channel Masks
                //0X138,13A,13C = ADR_BADBITS301,BADBITS323,BADBITS345 = CFEB3 Hot Channel Masks
                //0X13E,140,142 = ADR_BADBITS401,BADBITS423,BADBITS445 = CFEB4 Hot Channel Masks
                //------------------------------------------------------------------
                for (int bit_in_register=0; bit_in_register<16; bit_in_register++) {
                    //
                    // get the layer and distrip channels covered by this register
                    int layer   = GetHotChannelLayerFromMap_(address,bit_in_register);
                    int distrip = GetHotChannelDistripFromMap_(address,bit_in_register);
                    //
                    read_badbits_[layer][distrip] = ExtractValueFromData(data,bit_in_register,bit_in_register);
                }
                //
            }
            //
            // combinations of bits which say which trgmode_ we are using....
            //
            int read_CLCTtrigger_setting     = read_tmb_allow_clct_  & read_clct_pat_trig_en_;
            int read_ALCTCLCTtrigger_setting = read_tmb_allow_match_ & read_match_pat_trig_en_;
            //
            if (read_CLCTtrigger_setting) 
                read_trgmode_ = CLCT_trigger;
            if (read_ALCTCLCTtrigger_setting) 
                read_trgmode_ = ALCT_CLCT_coincidence_trigger;
            //
            return;
        }
        //
        void TMB::DecodeBootRegister_(int data) {
            //------------------------------------------------------------------
            //0X70000 = ADR_BOOT:  Hardware Bootstrap Register
            //------------------------------------------------------------------
            read_boot_tdi_                     = ExtractValueFromData(data,boot_tdi_bitlo                    ,boot_tdi_bithi                    );
            read_boot_tms_                     = ExtractValueFromData(data,boot_tms_bitlo                    ,boot_tms_bithi                    );
            read_boot_tck_                     = ExtractValueFromData(data,boot_tck_bitlo                    ,boot_tck_bithi                    );
            read_boot_jtag_chain_select_       = ExtractValueFromData(data,boot_jtag_chain_select_bitlo      ,boot_jtag_chain_select_bithi      );
            read_boot_control_jtag_chain_      = ExtractValueFromData(data,boot_control_jtag_chain_bitlo     ,boot_control_jtag_chain_bithi     );
            read_boot_hard_reset_alct_         = ExtractValueFromData(data,boot_hard_reset_alct_bitlo        ,boot_hard_reset_alct_bithi        );
            read_boot_hard_reset_tmb_          = ExtractValueFromData(data,boot_hard_reset_tmb_bitlo         ,boot_hard_reset_tmb_bithi         );
            read_boot_disable_hard_reset_alct_ = ExtractValueFromData(data,boot_disable_hard_reset_alct_bitlo,boot_disable_hard_reset_alct_bithi);
            read_boot_disable_VME_             = ExtractValueFromData(data,boot_disable_VME_bitlo            ,boot_disable_VME_bithi            );
            read_boot_disable_mezz_clock_      = ExtractValueFromData(data,boot_disable_mezz_clock_bitlo     ,boot_disable_mezz_clock_bithi     );
            read_boot_hard_reset_rat_          = ExtractValueFromData(data,boot_hard_reset_rat_bitlo         ,boot_hard_reset_rat_bithi         );
            read_boot_vme_ready_               = ExtractValueFromData(data,boot_vme_ready_bitlo              ,boot_vme_ready_bithi              );
            read_boot_tdo_                     = ExtractValueFromData(data,boot_tdo_bitlo                    ,boot_tdo_bithi                    );
            //
            return;
        }
        //
        ////////////////////////////////////////////////////////////////////////////////////////
        // Print read values to screen
        ////////////////////////////////////////////////////////////////////////////////////////
        void TMB::PrintTMBConfiguration() {
            //
            (*MyOutput_) << "TMB READ configuration in slot = " << (int) slot() << std::endl;
            //
            PrintFirmwareDate();
            PrintBootRegister();
            //
            for (unsigned int index=0; index<TMBConfigurationRegister.size(); index++) {
                //
                unsigned long int VMEregister = TMBConfigurationRegister.at(index);
                //
                if (VMEregister != vme_usr_jtag_adr &&      // skip the user jtag register
                        VMEregister != hcm001_adr && VMEregister != hcm023_adr && VMEregister != hcm045_adr &&   //skip the hot channel
                        VMEregister != hcm101_adr && VMEregister != hcm123_adr && VMEregister != hcm145_adr &&   //mask registers... 
                        VMEregister != hcm201_adr && VMEregister != hcm223_adr && VMEregister != hcm245_adr &&   //(print hot channel mask
                    VMEregister != hcm301_adr && VMEregister != hcm323_adr && VMEregister != hcm345_adr &&   //out in a different way)
                        VMEregister != hcm401_adr && VMEregister != hcm423_adr && VMEregister != hcm445_adr )
                    PrintTMBRegister(VMEregister);
            }
            //
            PrintHotChannelMask();
            //
            return;
        }
        //
        void TMB::PrintHotChannelMask() {
            (*MyOutput_) << "-------------------------------------------" << std::endl;
            (*MyOutput_) << "TMB Hot Channel Mask (from right to left)" << std::endl;
            (*MyOutput_) << "-------------------------------------------" << std::endl;
            //
            for (int layer=5; layer>=0; layer--) {
                char hot_channel_mask[MAX_NUM_DISTRIPS_PER_LAYER/8];
                packCharBuffer(read_hot_channel_mask_[layer],
                        MAX_NUM_DISTRIPS_PER_LAYER,
                        hot_channel_mask);
                //
                int char_counter = MAX_NUM_DISTRIPS_PER_LAYER/8 - 1;
                //
                (*MyOutput_) << "Layer " << std::dec << layer << " -> ";    
                for (int layer_counter=MAX_NUM_DISTRIPS_PER_LAYER/8; layer_counter>0; layer_counter--) {
                    //      (*MyOutput_) << "char_counter " << std::dec << char_counter << " -> ";    
                    (*MyOutput_) << std::hex
                        << ((hot_channel_mask[char_counter] >> 4) & 0xf) 
                        << (hot_channel_mask[char_counter] & 0xf) << " ";
                    char_counter--;
                }
                (*MyOutput_) << std::endl;
            }
            return;
        }
        //
        void TMB::PrintComparatorBadBits() {
            (*MyOutput_) << "----------------------------------------" << std::endl;
            (*MyOutput_) << "TMB Hot Comparators (from right to left)" << std::endl;
            (*MyOutput_) << "----------------------------------------" << std::endl;
            //
            for (int layer=5; layer>=0; layer--) {
                char badbits[MAX_NUM_DISTRIPS_PER_LAYER/8];
                packCharBuffer(read_badbits_[layer],
                        MAX_NUM_DISTRIPS_PER_LAYER,
                        badbits);
                //
                int char_counter = MAX_NUM_DISTRIPS_PER_LAYER/8 - 1;
                //
                (*MyOutput_) << "Layer " << std::dec << layer << " -> ";    
                for (int layer_counter=MAX_NUM_DISTRIPS_PER_LAYER/8; layer_counter>0; layer_counter--) {
                    //      (*MyOutput_) << "char_counter " << std::dec << char_counter << " -> ";    
                    (*MyOutput_) << std::hex
                        << ((badbits[char_counter] >> 4) & 0xf) 
                        << (badbits[char_counter] & 0xf) << " ";
                    char_counter--;
                }
                (*MyOutput_) << std::endl;
            }
            return;
        }
        //
        void TMB::PrintVMEStateMachine() {
            //
            (*MyOutput_) << "-------------------------------------------" << std::endl;
            (*MyOutput_) << "TMB VME state machine status in slot = " << (int) slot() << std::endl;
            (*MyOutput_) << "-------------------------------------------" << std::endl;
            //
            PrintTMBRegister(vme_sm_ctrl_adr);
            PrintTMBRegister(vme_sm_wdcnt_adr);
            PrintTMBRegister(vme_sm_cksum_adr);
            PrintTMBRegister(num_vme_sm_adr_adr);
            //
            return;
        }
        //
        void TMB::PrintJTAGStateMachine() {
            //
            (*MyOutput_) << "-------------------------------------------" << std::endl;
            (*MyOutput_) << "TMB JTAG state machine status in slot = " << (int) slot() << std::endl;
            (*MyOutput_) << "-------------------------------------------" << std::endl;
            //
            PrintTMBRegister(jtag_sm_ctrl_adr);
            PrintTMBRegister(jtag_sm_cksum_adr);
            PrintTMBRegister(jtag_sm_wdcnt_adr);
            PrintBootRegister();
            //
            return;
        }
        //
        void TMB::PrintRawHitsHeader() {
            //
            (*MyOutput_) << "-------------------------------------------" << std::endl;
            (*MyOutput_) << "TMB raw hits header in slot " << std::dec << (int) slot() << std::endl;
            (*MyOutput_) << "-------------------------------------------" << std::endl;
            //
            PrintTMBRegister(tmb_stat_adr);
            //
            return;
        }
        //
        void TMB::PrintDDDStateMachine() {
            //
            (*MyOutput_) << "-------------------------------------------" << std::endl;
            (*MyOutput_) << "TMB DDD state machine status in slot = " << (int) slot() << std::endl;
            (*MyOutput_) << "-------------------------------------------" << std::endl;
            //
            PrintTMBRegister(vme_dddsm_adr);
            //
            return;
        }
        //
        void TMB::PrintTMBRegister(unsigned long int address) {
            //
            (*MyOutput_) << std::hex << "0x" << ( (address>>8) & 0xf) << ( (address>>4) & 0xf) << ( (address>>0) & 0xf);
            //
            if ( address == vme_loopbk_adr ) {
                //-----------------------------------------------------------------
                //0X0E = ADR_LOOPBK:  Loop-Back Control Register
                //-----------------------------------------------------------------
                (*MyOutput_) << " ->Loopback register:" << std::endl;
                (*MyOutput_) << "    CFEB output enable                    = " << std::hex << read_cfeb_oe_        << std::endl;
                (*MyOutput_) << "    ALCT loop-back                        = " << std::hex << read_alct_loop_      << std::endl;
                (*MyOutput_) << "    ALCT enable LVDS rx                   = " << std::hex << read_enable_alct_rx_ << std::endl;
                (*MyOutput_) << "    ALCT enable LVDS tx                   = " << std::hex << read_enable_alct_tx_ << std::endl;
                (*MyOutput_) << "    RPC FPGA enters loop-back mode        = " << std::hex << read_rpc_loop_rat_   << std::endl;
                (*MyOutput_) << "    TMBs RAT backplane ICs loop-back mode = " << std::hex << read_rpc_loop_tmb_   << std::endl;
                (*MyOutput_) << "    DMB loop-back                         = " << std::hex << read_dmb_loop_       << std::endl;
                (*MyOutput_) << "    DMB driver not enable                 = " << std::hex << read_dmb_oe_         << std::endl;
                (*MyOutput_) << "    GTL loop-back                         = " << std::hex << read_gtl_loop_       << std::endl;
                (*MyOutput_) << "    GTL outputs not enable                = " << std::hex << read_gtl_oe_         << std::endl;
                //
            } else if ( address == vme_dddsm_adr ) {
                //------------------------------------------------------------------
                //0X14 = ADR_DDDSM:  3D3444 State Machine Control + DCM Lock Status  
                //------------------------------------------------------------------
                (*MyOutput_) << " ->TMB DDD State Machine register:" << std::endl;
                (*MyOutput_) << "    start VME        = " << std::hex << read_ddd_state_machine_start_           << std::endl;
                (*MyOutput_) << "    manual clock mode= " << std::hex << read_ddd_state_machine_manual_           << std::endl;
                (*MyOutput_) << "    address latch    = " << std::hex << read_ddd_state_machine_latch_            << std::endl;
                (*MyOutput_) << "    serial in        = " << std::hex << read_ddd_state_machine_serial_in_        << std::endl;
                (*MyOutput_) << "    serial out       = " << std::hex << read_ddd_state_machine_serial_out_       << std::endl;
                (*MyOutput_) << "    auto start       = " << std::hex << read_ddd_state_machine_autostart_        << std::endl;
                (*MyOutput_) << "    busy             = " << std::hex << read_ddd_state_machine_busy_             << std::endl;
                (*MyOutput_) << "    verify OK        = " << std::hex << read_ddd_state_machine_verify_ok_        << std::endl;
                (*MyOutput_) << "    clock 0 DCM lock = " << std::hex << read_ddd_state_machine_clock0_lock_      << std::endl;
                (*MyOutput_) << "    clock 0d DCM lock= " << std::hex << read_ddd_state_machine_clock0d_lock_     << std::endl;
                (*MyOutput_) << "    clock 1 DCM lock = " << std::hex << read_ddd_state_machine_clock1_lock_      << std::endl;
                (*MyOutput_) << "    clock ALCT lock  = " << std::hex << read_ddd_state_machine_clock_alct_lock_  << std::endl;
                (*MyOutput_) << "    clock ALCTd lock = " << std::hex << read_ddd_state_machine_clockd_alct_lock_ << std::endl;
                (*MyOutput_) << "    clock CFEB lock  = " << std::hex << read_ddd_state_machine_clock_cfeb_lock_  << std::endl;
                (*MyOutput_) << "    clock DCC lock   = " << std::hex << read_ddd_state_machine_clock_dcc_lock_   << std::endl;
                (*MyOutput_) << "    clock RPC lock   = " << std::hex << read_ddd_state_machine_clock_rpc_lock_   << std::endl;
                //
            } else if ( address == vme_ddd0_adr ) {    
                //------------------------------------------------------------------
                //0X16 = ADR_DDD0:  3D3444 Chip 0 Delays, 1 step = 2ns
                //------------------------------------------------------------------
                (*MyOutput_) << " ->Clock phase delay register:" << std::endl;
                (*MyOutput_) << "    ALCT TOF delay = " << std::dec << read_alct_tof_delay_      << std::endl;
                (*MyOutput_) << "    DMB tx phase   = " << std::dec << read_dmb_tx_delay_        << std::endl;
                (*MyOutput_) << "    RAT-TMB phase  = " << std::dec << read_rat_tmb_delay_       << std::endl;
                //
            } else if ( address == vme_ddd1_adr ) {    
                //------------------------------------------------------------------
                //0X18 = ADR_DDD1:  3D3444 Chip 1 Delays, 1 step = 2ns
                //------------------------------------------------------------------
                (*MyOutput_) << " ->Clock phase delay register:" << std::endl;
                (*MyOutput_) << "    TMB 1 phase      = " << std::dec << read_tmb1_phase_          << std::endl;
                (*MyOutput_) << "    CFEB TOF delay   = " << std::dec << read_cfeb_tof_delay_      << std::endl;
                (*MyOutput_) << "    CFEB0 TOF delay = " << std::dec << read_cfeb0_tof_delay_     << std::endl;
                //
            } else if ( address == vme_ddd2_adr ) {    
                //------------------------------------------------------------------
                //0X1A = ADR_DDD2:  3D3444 Chip 2 Delays, 1 step = 2ns
                //------------------------------------------------------------------
                (*MyOutput_) << " ->Clock phase delay register:" << std::endl;
                (*MyOutput_) << "    CFEB1 TOF delay = " << std::dec << read_cfeb1_tof_delay_ << std::endl;
                (*MyOutput_) << "    CFEB2 TOF delay = " << std::dec << read_cfeb2_tof_delay_ << std::endl;
                (*MyOutput_) << "    CFEB3 TOF delay = " << std::dec << read_cfeb3_tof_delay_ << std::endl;
                (*MyOutput_) << "    CFEB4 TOF delay = " << std::dec << read_cfeb4_tof_delay_ << std::endl;
                //
            } else if ( address == vme_ratctrl_adr ) {
                //------------------------------------------------------------------
                //0X1E = ADR_RATCTRL:  RAT Module Control
                //------------------------------------------------------------------
                (*MyOutput_) << " ->RAT control register:" << std::endl;
                (*MyOutput_) << "    RPC 80MHz sync mode = " << std::hex << read_rpc_sync_   << std::endl;
                (*MyOutput_) << "    RPC shift 1/2 cycle = " << std::hex << read_shift_rpc_  << std::endl;
                (*MyOutput_) << "    enable RAT DSN read = " << std::hex << read_rat_dsn_en_ << std::endl;
                //
            } else if ( address == vme_adc_adr ) {
                //------------------------------------------------------------------
                //0X24 = ADR_ADC:  ADC + power comparator
                //-----------------------------------------------------------------
                (*MyOutput_) << " ->ADC control register:" << std::endl;
                (*MyOutput_) << "    Voltage status 5.0V             = " << std::hex << read_adc_vstat_5p0v_        << std::endl;
                (*MyOutput_) << "    Voltage status 3.3V             = " << std::hex << read_adc_vstat_3p3v_        << std::endl;
                (*MyOutput_) << "    Voltage status 1.8V             = " << std::hex << read_adc_vstat_1p8v_        << std::endl;
                (*MyOutput_) << "    Voltage status 1.5V             = " << std::hex << read_adc_vstat_1p5v_        << std::endl;
                (*MyOutput_) << "    Temperature status not critical = " << std::hex << read_temp_not_critical_ << std::endl;
                (*MyOutput_) << "    Voltage ADC data out            = " << std::hex << read_voltage_adc_data_out_     << std::endl;
                (*MyOutput_) << "    Voltage ADC serial clock        = " << std::hex << read_voltage_adc_serial_clock_ << std::endl;
                (*MyOutput_) << "    Voltage ADC data in             = " << std::hex << read_voltage_adc_data_in_      << std::endl;
                (*MyOutput_) << "    Voltage ADC chip select         = " << std::hex << read_voltage_adc_chip_select_  << std::endl;
                (*MyOutput_) << "    Temperature ADC serial clock    = " << std::hex << read_temperature_adc_serial_clock_ << std::endl;
                (*MyOutput_) << "    Temperature ADC serial data     = " << std::hex << read_temperature_adc_serial_data_  << std::endl;
                //
            } else if ( address == ccb_cfg_adr ) {
                //------------------------------------------------------------------
                //0X2A =  ADR_CCB_CFG:  CCB Configuration
                //------------------------------------------------------------------
                (*MyOutput_) << " ->CCB configuration register:" << std::endl;
                (*MyOutput_) << "    Ignore received CCB backplane inputs          = " << std::hex << read_ignore_ccb_rx_                 << std::endl;                
                (*MyOutput_) << "    Disable transmitted CCB backplane outputs     = " << std::hex << read_disable_ccb_tx_                << std::endl;               
                (*MyOutput_) << "    Enable internal L1A emulator                  = " << std::hex << read_enable_internal_l1a_           << std::endl;          
                (*MyOutput_) << "    Enable ALCT or CLCT status to CCB front panel = " << std::hex << read_enable_alctclct_status_to_ccb_ << std::endl;
                (*MyOutput_) << "    Enable ALCT status GTL outputs                = " << std::hex << read_enable_alct_status_to_ccb_     << std::endl;    
                (*MyOutput_) << "    Enable CLCT status GTL outputs                = " << std::hex << read_enable_clct_status_to_ccb_     << std::endl;    
                (*MyOutput_) << "    Fire CCB L1A oneshot                          = " << std::hex << read_fire_l1a_oneshot_              << std::endl;             
                //
            } else if ( address == ccb_trig_adr ) {
                //------------------------------------------------------------------
                //0X2C = ADR_CCB_TRIG:  CCB Trigger Control
                //------------------------------------------------------------------
                (*MyOutput_) << " ->CCB trigger configuration register:" << std::endl;
                (*MyOutput_) << "    Request CCB L1a on ALCT external trig = " << std::hex << read_alct_ext_trig_l1aen_    << std::endl;
                (*MyOutput_) << "    Request CCB L1a on CLCT external trig = " << std::hex << read_clct_ext_trig_l1aen_    << std::endl;
                (*MyOutput_) << "    Request CCB L1a on sequencer trigger  = " << std::hex << read_request_l1a_            << std::endl;
                (*MyOutput_) << "    Fire ALCT external trig one-shot      = " << std::hex << read_alct_ext_trig_vme_      << std::endl;
                (*MyOutput_) << "    Fire CLCT external trig one-shot      = " << std::hex << read_clct_ext_trig_vme_      << std::endl;
                (*MyOutput_) << "    CLCText fire ALCT + ALCText fire CLCT = " << std::hex << read_ext_trig_both_          << std::endl;
                (*MyOutput_) << "    allow CLCTextCCB when ccb_ignore_rx=1 = " << std::hex << read_ccb_allow_bypass_       << std::endl;
                (*MyOutput_) << "    Ignore CCB trig start/stop            = " << std::hex << read_ignore_ccb_startstop_   << std::endl;
                (*MyOutput_) << "    Internal L1A delay (VME)              = " << std::dec << read_internal_l1a_delay_vme_ << std::endl;
                //
            } else if ( address == alct_cfg_adr ) {
                //------------------------------------------------------------------
                //0X30 = ADR_ALCT_CFG:  ALCT Configuration
                //------------------------------------------------------------------
                (*MyOutput_) << " ->ALCT configuration register:" << std::endl;
                (*MyOutput_) << "    Enable alct_ext_trig from CCB             = " << std::hex << read_cfg_alct_ext_trig_en_   << std::endl;  
                (*MyOutput_) << "    Enable alct_ext_inject from CCB           = " << std::hex << read_cfg_alct_ext_inject_en_ << std::endl;
                (*MyOutput_) << "    Assert alct_ext_trig                      = " << std::hex << read_cfg_alct_ext_trig_      << std::endl;    
                (*MyOutput_) << "    Assert alct_ext_inject                    = " << std::hex << read_cfg_alct_ext_inject_    << std::endl;  
                (*MyOutput_) << "    ALCT sequencer command                   =0x" << std::hex << read_alct_seq_cmd_           << std::endl;         
                (*MyOutput_) << "    alct_clock_en_vme=ccb_clock40_enable      = " << std::hex << read_alct_clock_en_use_ccb_  << std::endl;
                (*MyOutput_) << "    set alct_clock_en scsi signal if above=0  = " << std::hex << read_alct_clock_en_use_vme_  << std::endl;
                (*MyOutput_) << "    ALCT has independent Time-Of-Flight delay = " << std::hex << read_alct_muonic_            << std::endl;
                (*MyOutput_) << "    CFEB has independent Time-of-Flight delay = " << std::hex << read_cfeb_muonic_            << std::endl;
                //
            } else if ( address == alct_inj_adr ) {
                //------------------------------------------------------------------
                //0X32 = ADR_ALCT_INJ:  ALCT Injector Control
                //------------------------------------------------------------------
                (*MyOutput_) << " ->ALCT injector control register:" << std::endl;
                (*MyOutput_) << "    Blank ALCT received data          = " << std::hex << read_alct_clear_      << std::endl;
                (*MyOutput_) << "    Start ALCT injector state machine = " << std::hex << read_alct_inject_mux_ << std::endl;
                (*MyOutput_) << "    Link ALCT inject with CLCT inject = " << std::hex << read_alct_sync_clct_  << std::endl;
                (*MyOutput_) << "    ALCT injector delay               = " << std::hex << read_alct_inj_delay_  << std::endl;
                //
            } else if ( address == alct_stat_adr ) {
                //------------------------------------------------------------------
                //0X38 = ADR_ALCT_STAT:  ALCT Sequencer Control/Status
                //------------------------------------------------------------------
                (*MyOutput_) << " ->ALCT sequencer control status:" << std::endl;
                (*MyOutput_) << "    ALCT FPGA configuration done              = " << std::hex << read_alct_cfg_done_       << std::endl;
                (*MyOutput_) << "    ALCT ECC trigger data correction enable   = " << std::hex << read_alct_ecc_en_         << std::endl;
                (*MyOutput_) << "    Blank ALCTs with uncorrected ECC errors   = " << std::hex << read_alct_ecc_err_blank_  << std::endl;
                (*MyOutput_) << "    ALCT sync-mode ECC error code             = " << std::hex << read_alct_sync_ecc_err_   << std::endl;
                (*MyOutput_) << "    Delay of ALCT tx data before 80MHz tx mux = 0x" << std::hex << read_alct_txdata_delay_ << std::endl;
                //
            } else if ( address == cfeb_inj_adr ) {
                //------------------------------------------------------------------
                //0X42 = ADR_CFEB_INJ:  CFEB Injector Control
                //------------------------------------------------------------------
                (*MyOutput_) << " ->CFEB injector control register:" << std::endl;
                (*MyOutput_) << "    CFEB enable mask               = 0x" << std::hex << read_enableCLCTInputs_  << std::endl;
                (*MyOutput_) << "    select CFEB for RAM read/write = 0x" << std::hex << read_cfeb_ram_sel_      << std::endl;
                (*MyOutput_) << "    CFEB enable injector mask      = 0x" << std::hex << read_cfeb_inj_en_sel_   << std::endl;
                (*MyOutput_) << "    start pattern injector         = "   << std::hex << read_start_pattern_inj_ << std::endl;
                //
            } else if ( address == seq_trig_en_adr ) {
                //------------------------------------------------------------------
                //0X68 = ADR_SEQ_TRIG_EN:  Sequencer Trigger Source Enables
                //------------------------------------------------------------------
                (*MyOutput_) << " ->Sequencer Trigger Source Enable register:" << std::endl;
                (*MyOutput_) << "    CLCT pretrigger                 = "   << std::hex << read_clct_pat_trig_en_   << std::endl;
                (*MyOutput_) << "    ALCT pretrigger                 = "   << std::hex << read_alct_pat_trig_en_   << std::endl;
                (*MyOutput_) << "    ALCT*CLCT pretrigger            = "   << std::hex << read_match_pat_trig_en_  << std::endl;
                (*MyOutput_) << "    ADB external pretrigger         = "   << std::hex << read_adb_ext_trig_en_    << std::endl;
                (*MyOutput_) << "    DMB external pretrigger         = "   << std::hex << read_dmb_ext_trig_en_    << std::endl;
                (*MyOutput_) << "    CLCT ext (scint) pretrigger     = "   << std::hex << read_clct_ext_trig_en_   << std::endl;
                (*MyOutput_) << "    ALCT ext pretrigger             = "   << std::hex << read_alct_ext_trig_en_   << std::endl;
                (*MyOutput_) << "    VME pretrigger                  = "   << std::hex << read_vme_ext_trig_       << std::endl;
                (*MyOutput_) << "    CLCT ext trig fires pattern inj = "   << std::hex << read_ext_trig_inject_    << std::endl;
                (*MyOutput_) << "    all CFEBs active                = "   << std::hex << read_all_cfeb_active_    << std::endl;
                (*MyOutput_) << "    CFEBs enabled                   = 0x" << std::hex << read_cfebs_enabled_      << std::endl;
                (*MyOutput_) << "    enable CFEBS through VME 0x42   = "   << std::hex << read_cfeb_enable_source_ << std::endl;
                //
            } else if ( address == seq_trig_dly0_adr ) {
                //------------------------------------------------------------------
                //0X6A = ADR_SEQ_TRIG_DLY0:  Sequencer Trigger Source Delays
                //------------------------------------------------------------------
                (*MyOutput_) << " ->Sequencer Trigger Source Delays register:" << std::endl;
                (*MyOutput_) << "    ALCT*CLCT pretrigger match window width    = " << std::dec << read_alct_pretrig_width_ << std::endl;
                (*MyOutput_) << "    ALCT*CLCT Pretrigger ALCT delay            = " << std::dec << read_alct_pretrig_delay_ << std::endl;
                (*MyOutput_) << "    Active FEB Flag delay                      = " << std::dec << read_alct_pattern_delay_ << std::endl;
                (*MyOutput_) << "    ADB External trigger delay                 = " << std::dec << read_adb_ext_trig_delay_ << std::endl;
                //
            } else if ( address == seq_trig_dly1_adr ) {
                //------------------------------------------------------------------
                //0X6C = ADR_SEQ_TRIG_DLY1:  Sequencer Trigger Source Delays
                //------------------------------------------------------------------
                (*MyOutput_) << " ->Sequencer Trigger Source Delays register:" << std::endl;
                (*MyOutput_) << "    Delay dmb_ext_trig from DMB          = " << std::dec << read_dmb_ext_trig_delay_  << std::endl;
                (*MyOutput_) << "    Delay clct_ext_trig (scint) from CCB = " << std::dec << read_clct_ext_trig_delay_ << std::endl;
                (*MyOutput_) << "    Delay alct_ext_trig from CCB         = " << std::dec << read_alct_ext_trig_delay_ << std::endl;
                //
            } else if ( address == seq_id_adr ) {
                //------------------------------------------------------------------
                //0X6E = ADR_SEQ_ID:  Sequencer Board + CSC Ids
                //------------------------------------------------------------------
                (*MyOutput_) << " ->ID register:" << std::endl;
                (*MyOutput_) << "    TMB slot = " << std::dec << read_tmb_slot_ << std::endl;
                (*MyOutput_) << "    CSC ID   = " << std::dec << read_csc_id_   << std::endl;
                (*MyOutput_) << "    Run ID   = " << std::dec << read_run_id_   << std::endl;
                //
            } else if ( address == seq_clct_adr ) {
                //------------------------------------------------------------------
                //0X70 = ADR_SEQ_CLCT:  Sequencer CLCT configuration
                //------------------------------------------------------------------
                (*MyOutput_) << " ->Sequencer CLCT configuration register:" << std::endl;
                (*MyOutput_) << "    Triad 1-shot persistence                                  = 0x" << std::hex << read_triad_persist_    << std::endl;
                (*MyOutput_) << "    1/2-strip pretrigger thresh                               = "   << std::dec << read_hit_thresh_       << std::endl;
                (*MyOutput_) << "    Minimum layers in pattern to send Active FEB Flag to DMB  = "   << std::dec << read_aff_thresh_       << std::endl; 
                (*MyOutput_) << "    min pattern hits for valid pattern                        = "   << std::dec << read_min_hits_pattern_ << std::endl;
                (*MyOutput_) << "    drift delay                                               = "   << std::dec << read_drift_delay_      << std::endl;
                (*MyOutput_) << "    pretrigger then halt until unhalt                         = "   << std::hex << read_pretrigger_halt_  << std::endl;
                //
            } else if ( address == seq_fifo_adr ) {
                //------------------------------------------------------------------
                //0X72 = ADR_SEQ_FIFO:  Sequencer FIFO configuration
                //------------------------------------------------------------------
                (*MyOutput_) << " ->Sequencer FIFO configuration register:" << std::endl;
                (*MyOutput_) << "   FIFO mode                           = " << std::dec << read_fifo_mode_ << " = ";
                if (read_fifo_mode_ == FIFOMODE_NoCfebRaw_FullHeader) {
                    (*MyOutput_) << "no CFEB raw hits, full header";
                } else if (read_fifo_mode_ == FIFOMODE_AllCfebRaw_FullHeader) {
                    (*MyOutput_) << "all CFEB raw hits, full header";
                } else if (read_fifo_mode_ == FIFOMODE_LocalCfebRaw_FullHeader) {
                    (*MyOutput_) << "local CFEB raw hits, full header";
                } else if (read_fifo_mode_ == FIFOMODE_NoCfebRaw_ShortHeader) {
                    (*MyOutput_) << "no CFEB raw hits, short header";
                } else if (read_fifo_mode_ == FIFOMODE_NoCfebRaw_NoHeader) {
                    (*MyOutput_) << "no CFEB raw hits, no header";
                } else {
                    (*MyOutput_) << "unknown fifo_mode...";
                }
                (*MyOutput_) << std::endl;
                (*MyOutput_) << "   Number FIFO time bins read out                = " << std::dec << read_fifo_tbins_       << std::endl;
                (*MyOutput_) << "   Number FIFO time bins before pretrig          = " << std::dec << read_fifo_pretrig_     << std::endl;
                (*MyOutput_) << "   Do not wait to store raw hits (a no-DAQ mode) = " << std::dec << read_fifo_no_raw_hits_ << std::endl;
                (*MyOutput_) << "   Enable CFEB blocked distrip bits in readout   = " << std::dec << read_cfeb_badbits_readout_ << std::endl;
                //
            } else if ( address == seq_l1a_adr ) {
                //------------------------------------------------------------------
                //0X74 = ADR_SEQ_L1A:  Sequencer L1A configuration
                //------------------------------------------------------------------
                (*MyOutput_) << " ->Sequencer L1A configuration register:" << std::endl;
                (*MyOutput_) << "    L1a delay from pretrig status output = " << std::dec << read_l1adelay_         << std::endl;
                (*MyOutput_) << "    L1a accept window width              = " << std::dec << read_l1a_window_size_  << std::endl;
                (*MyOutput_) << "    Generate internal L1a                = " << std::dec << read_tmb_l1a_internal_ << std::endl;
                //
            } else if ( address == seq_offset_adr ) {
                //------------------------------------------------------------------
                //0X76 = ADR_SEQ_OFFSET:  Sequencer Counter Offsets
                //------------------------------------------------------------------
                (*MyOutput_) << " ->Sequencer counter offset register:" << std::endl;
                (*MyOutput_) << "    L1a Counter Preset value = " << std::dec << read_l1a_offset_ << std::endl;
                (*MyOutput_) << "    BXN offset at reset      = " << std::dec << read_bxn_offset_ << std::endl;
                //
            } else if ( address == tmb_trig_adr ) {    
                //------------------------------------------------------------------
                //0X86 = ADR_TMB_TRIG:  TMB Trigger configuration/MPC accept
                //------------------------------------------------------------------
                (*MyOutput_) << " ->TMB trigger configuration/MPC accept register:" << std::endl;
                (*MyOutput_) << "    Allow sync_err to MPC for either muon        = " << std::hex << read_tmb_sync_err_enable_ << std::endl;
                (*MyOutput_) << "    Allow ALCT only trigger                      = " << std::hex << read_tmb_allow_alct_      << std::endl;
                (*MyOutput_) << "    Allow CLCT only trigger                      = " << std::hex << read_tmb_allow_clct_      << std::endl;
                (*MyOutput_) << "    Allow ALCT*CLCT trigger                      = " << std::hex << read_tmb_allow_match_     << std::endl;
                (*MyOutput_) << "    MPC rx delay                                 = " << std::dec << read_mpc_rx_delay_        << std::endl;
                (*MyOutput_) << "    MPC accept latched after delay               = " << std::dec << read_mpc_accept_          << std::endl;
                (*MyOutput_) << "    MPC reserved latched after delay             = " << std::dec << read_mpc_reserved_        << std::endl;
                (*MyOutput_) << "    MPC gets bx0 from TTC                        = " << std::dec << read_mpc_sel_ttc_bx0_     << std::endl;
                (*MyOutput_) << "    blank MPC data and bx0 except when triggered = " << std::hex << read_mpc_idle_blank_      << std::endl;
                (*MyOutput_) << "    enable outputs to MPC                        = " << std::hex << read_mpc_output_enable_   << std::endl;
                //
            } else if ( address == scp_ctrl_adr ) {    
                //------------------------------------------------------------------
                //0X98 = ADR_SCP_CTRL:  Scope Control
                //------------------------------------------------------------------
                (*MyOutput_) << " ->Scope Control register:" << std::endl;
                (*MyOutput_) << "    Scope in Readout       = " << std::hex << read_scope_in_readout_ << std::endl;
                //
            } else if ( address == seqmod_adr ) {
                //------------------------------------------------------------------
                //0XAC = ADR_SEQMOD:  Sequencer Trigger Modifiers
                //------------------------------------------------------------------
                (*MyOutput_) << " ->Sequencer trigger modifier register:" << std::endl;
                (*MyOutput_) << "    Trigger sequencer flush state timer                         = " << std::dec << read_clct_flush_delay_             << std::endl;
                (*MyOutput_) << "    Enable frozen buffer autoclear                              = " << std::hex << read_wr_buffer_autoclear_          << std::endl;
                (*MyOutput_) << "    Allow continuous header buffer writing for invalid triggers = " << std::hex << read_clct_write_continuous_enable_ << std::endl;
                (*MyOutput_) << "    Require wr_buffer available to pretrigger                   = " << std::hex << read_wrt_buf_required_             << std::endl;
                (*MyOutput_) << "    Require valid CLCT after drift delay                        = " << std::hex << read_valid_clct_required_          << std::endl;
                (*MyOutput_) << "    Readout allows tmb trig pulse in L1a window                 = " << std::hex << read_l1a_allow_match_              << std::endl;
                (*MyOutput_) << "    Readout allows notmb trig pulse in L1a window               = " << std::hex << read_l1a_allow_notmb_              << std::endl;
                (*MyOutput_) << "    Readout allows TMB trig pulse outside L1a window            = " << std::hex << read_l1a_allow_nol1a_              << std::endl;
                (*MyOutput_) << "    Allow ALCT-only events to readout at L1a                    = " << std::hex << read_l1a_allow_alct_only_          << std::endl;
                (*MyOutput_) << "    Clear scintillator veto FF                                  = " << std::hex << read_scint_veto_clr_               << std::endl;
                (*MyOutput_) << "    Scintillator veto FF state                                  = " << std::hex << read_scint_veto_vme_               << std::endl;
                //
            } else if ( address == tmbtim_adr ) {
                //------------------------------------------------------------------
                //0XB2 = ADR_TMBTIM:  TMB Timing for ALCT*CLCT Coincidence
                //------------------------------------------------------------------
                (*MyOutput_) << " ->TMB timing for ALCT*CLCT coincidence register:" << std::endl;
                (*MyOutput_) << "    ALCT*CLCT trigger ALCT (Valid Pattern Flag) delay = " << std::dec << read_alct_vpf_delay_         << std::endl;
                (*MyOutput_) << "    ALCT*CLCT trigger match window size               = " << std::dec << read_alct_match_window_size_ << std::endl;
                (*MyOutput_) << "    MPC transmit delay                                = " << std::dec << read_mpc_tx_delay_           << std::endl;
                //
            } else if ( address == rpc_cfg_adr ) {
                //------------------------------------------------------------------
                //0XB6 = ADR_RPC_CFG:  RPC Configuration
                //------------------------------------------------------------------
                (*MyOutput_) << " ->RPC configuration register:" << std::endl;
                (*MyOutput_) << "    RPC exists                                     = 0x" << std::hex << read_rpc_exists_      << std::endl;
                (*MyOutput_) << "    RPC read enable                                = "   << std::hex << read_rpc_read_enable_ << std::endl;
                (*MyOutput_) << "    RPC BXN offset                                 = "   << std::dec << read_rpc_bxn_offset_  << std::endl;
                (*MyOutput_) << "    RPC bank address (for reading rdata sync mode) = "   << std::dec << read_rpc_bank_        << std::endl;
                (*MyOutput_) << "    RPC rdata [18:16] msbs for sync mode           = "   << std::dec << read_rpc_rbxn_        << std::endl;
                (*MyOutput_) << "    RPC FPGA reports configuration done            = "   << std::dec << read_rpc_done_        << std::endl;
                //
            } else if ( address == rpc_raw_delay_adr ) {
                //------------------------------------------------------------------
                //0XBA = ADR_RPC_RAW_DELAY:  RPC Raw Hits Data Delay
                //------------------------------------------------------------------
                (*MyOutput_) << " ->RPC raw hits delay register:" << std::endl;
                (*MyOutput_) << "    RPC0 raw hits delay = " << std::dec << read_rpc0_raw_delay_ << std::endl;
                (*MyOutput_) << "    RPC1 raw hits delay = " << std::dec << read_rpc1_raw_delay_ << std::endl;
                //
            } else if ( address == rpc_inj_adr ) {
                //------------------------------------------------------------------
                //0XBC = ADR_RPC_INJ:  RPC Injector Control
                //------------------------------------------------------------------
                (*MyOutput_) << " ->RPC injector control register:" << std::endl;
                (*MyOutput_) << "    Enable RPC inputs to RAT             = "   << std::hex << read_rpc_mask_all_  << std::endl; 
                (*MyOutput_) << "    Enable RAT for injector fire         = "   << std::hex << read_inj_mask_rat_  << std::endl; 
                (*MyOutput_) << "    Enable RPC inj RAM for injector fire = "   << std::hex << read_inj_mask_rpc_  << std::endl; 
                (*MyOutput_) << "    CFEB/RPC injectors wait for RAT      = "   << std::dec << read_inj_delay_rat_ << std::endl; 
                (*MyOutput_) << "    Enable injector RAM write            = "   << std::hex << read_rpc_inj_sel_   << std::endl; 
                (*MyOutput_) << "    RPC injector write data MSBs         = 0x" << std::hex << read_rpc_inj_wdata_ << std::endl; 
                (*MyOutput_) << "    RPC injector read data MSBs          = 0x" << std::hex << read_rpc_inj_rdata_ << std::endl; 
                //
            } else if ( address == rpc_tbins_adr ) {
                //------------------------------------------------------------------
                //0XC4 = ADR_RPC_TBINS:  RPC FIFO Time Bins
                //------------------------------------------------------------------
                (*MyOutput_) << " ->RPC FIFO time bins register:" << std::endl;
                (*MyOutput_) << "    Number of RPC FIFO time bins to readout             = "   << std::dec << read_fifo_tbins_rpc_   << std::endl; 
                (*MyOutput_) << "    Number of RPC FIFO time bins before pretrigger      = "   << std::dec << read_fifo_pretrig_rpc_ << std::endl; 
                (*MyOutput_) << "    RPC time bins are independent (0 = copy CFEB tbins) = "   << std::dec << read_rpc_decouple_     << std::endl; 
                //
            } else if ( address == bx0_delay_adr ) {
                //------------------------------------------------------------------
                //0XCA = ADR_BX0_DELAY:  BX0 to MPC delays
                //------------------------------------------------------------------
                (*MyOutput_) << " ->BX0 to MPC delay register:" << std::endl;
                (*MyOutput_) << "    ALCT BX0 delay to MPC transmitter           = "   << std::dec << read_alct_bx0_delay_  << std::endl; 
                (*MyOutput_) << "    CLCT BX0 delay to MPC transmitter           = "   << std::dec << read_clct_bx0_delay_  << std::endl; 
                (*MyOutput_) << "    Enable ALCT BX0 (0 = use CLCT BX0 for ALCT) = "   << std::dec << read_alct_bx0_enable_ << std::endl; 
                (*MyOutput_) << "    CLCT_BX0=LCT0_VPF for BC0 alignment tests   = "   << std::dec << read_bx0_vpf_test_    << std::endl; 
                (*MyOutput_) << "    ALCT_BC0 = CLCT_BC0                         = "   << std::dec << read_bx0_match_       << std::endl; 
                //
            } else if ( address == non_trig_readout_adr ) {
                //-----------------------------------------------------------------------------
                //0XCC = ADR_NON_TRIG_RO:  Non-Triggering Event Enables + ME1/1A(1B) reversal 
                //-----------------------------------------------------------------------------
                (*MyOutput_) << " ->Non-triggering Event Enable + ME11A/B reversal register:" << std::endl;
                (*MyOutput_) << "    Allow ALCT-only non-triggering readout           =   " << std::hex << read_tmb_allow_alct_nontrig_readout_   << std::endl;
                (*MyOutput_) << "    Allow CLCT-only non-triggering readout           =   " << std::hex << read_tmb_allow_clct_nontrig_readout_   << std::endl;
                (*MyOutput_) << "    Allow ALCT*CLCT non-triggering readout           =   " << std::hex << read_tmb_allow_match_nontrig_readout_  << std::endl;
                (*MyOutput_) << "    Block ME1/1A LCTs from MPC                       =   " << std::hex << read_mpc_block_me1a_                   << std::endl;
                (*MyOutput_) << "    Allow CLCT pretrigger counter to count non ME1/1 =   " << std::hex << read_clct_pretrigger_counter_non_me11_ << std::endl;
                (*MyOutput_) << "    TMB firmware type is ME1/1                       =   " << std::hex << read_csc_me11_                         << std::endl;
                (*MyOutput_) << "    CLCT stagger 1/2-strips                          =   " << std::hex << read_clct_stagger_                     << std::endl;
                (*MyOutput_) << "    Reverse CLCT (for staggered)                     =   " << std::hex << read_reverse_stagger_                  << std::endl;
                (*MyOutput_) << "    Reverse ME1/1A 1/2-strips                        =   " << std::hex << read_reverse_me1a_                     << std::endl;
                (*MyOutput_) << "    Reverse ME1/1B 1/2-strips                        =   " << std::hex << read_reverse_me1b_                     << std::endl;
                (*MyOutput_) << "    TMB firmware compile type                        = 0x" << std::hex << read_tmb_firmware_compile_type_        << std::endl;
                //
            } else if ( address == jtag_sm_ctrl_adr ) {
                //------------------------------------------------------------------
                //0XD4 = ADR_JTAGSM0:  JTAG State Machine Control (reads JTAG PROM)
                //------------------------------------------------------------------
                (*MyOutput_) << " ->JTAG State Machine Control register:" << std::endl;
                (*MyOutput_) << "    prom start vme   = "   << std::hex << read_jtag_state_machine_start_       << std::endl;
                (*MyOutput_) << "    sreset           = "   << std::hex << read_jtag_state_machine_sreset_      << std::endl;
                (*MyOutput_) << "    autostart        = "   << std::hex << read_jtag_state_machine_autostart_   << std::endl;
                (*MyOutput_) << "    busy             = "   << std::hex << read_jtag_state_machine_busy_        << std::endl;
                (*MyOutput_) << "    aborted          = "   << std::hex << read_jtag_state_machine_aborted_     << std::endl;
                (*MyOutput_) << "    check sum OK     = "   << std::hex << read_jtag_state_machine_cksum_ok_    << std::endl;
                (*MyOutput_) << "    word count OK    = "   << std::hex << read_jtag_state_machine_wdcnt_ok_    << std::endl;
                (*MyOutput_) << "    tck FPGA OK      = "   << std::hex << read_jtag_state_machine_tck_fpga_ok_ << std::endl;
                (*MyOutput_) << "    VME ready        = "   << std::hex << read_jtag_state_machine_vme_ready_   << std::endl;
                (*MyOutput_) << "    state machine OK = "   << std::hex << read_jtag_state_machine_ok_          << std::endl;
                (*MyOutput_) << "    throttle         = 0x" << std::hex << read_jtag_state_machine_throttle_    << std::endl;
                (*MyOutput_) << "    disable wrt to 10= "   << std::hex << read_jtag_disable_write_to_adr10_   << std::endl;
                (*MyOutput_) << "    jtag oe          = "   << std::hex << read_jtag_state_machine_oe_          << std::endl;
                //
            } else if ( address == jtag_sm_wdcnt_adr ) {
                //------------------------------------------------------------------
                //0XD6 = ADR_JTAGSM1:  JTAG State Machine Word Count
                //------------------------------------------------------------------
                (*MyOutput_) << " ->JTAG State Machine Word Count register:" << std::endl;
                (*MyOutput_) << "    word count = 0x" << std::hex << read_jtag_state_machine_word_count_ << std::endl;
                //
            } else if ( address == jtag_sm_cksum_adr ) {
                //------------------------------------------------------------------
                //0XD8 = ADR_JTAGSM2:  JTAG State Machine Checksum
                //------------------------------------------------------------------
                (*MyOutput_) << " ->JTAG State Machine Checksum register:" << std::endl;
                (*MyOutput_) << "    check sum  = 0x" << std::hex << read_jtag_state_machine_check_sum_ << std::endl;
                (*MyOutput_) << "    tck_fpga   = 0x" << std::hex << read_jtag_state_machine_tck_fpga_ << std::endl;
                //
            } else if ( address == vme_sm_ctrl_adr ) {
                //------------------------------------------------------------------
                //0XDA = ADR_VMESM0:  VME State Machine Control (reads VME PROM)
                //------------------------------------------------------------------
                (*MyOutput_) << " ->VME State Machine Control register:" << std::endl;
                (*MyOutput_) << "    start                   = "   << std::hex << read_vme_state_machine_start_     << std::endl;
                (*MyOutput_) << "    sreset                  = "   << std::hex << read_vme_state_machine_sreset_    << std::endl;
                (*MyOutput_) << "    autostart               = "   << std::hex << read_vme_state_machine_autostart_ << std::endl;
                (*MyOutput_) << "    busy                    = "   << std::hex << read_vme_state_machine_busy_      << std::endl;
                (*MyOutput_) << "    aborted                 = "   << std::hex << read_vme_state_machine_aborted_   << std::endl;
                (*MyOutput_) << "    check sum OK            = "   << std::hex << read_vme_state_machine_cksum_ok_  << std::endl;
                (*MyOutput_) << "    word count OK           = "   << std::hex << read_vme_state_machine_wdcnt_ok_  << std::endl;
                (*MyOutput_) << "    JTAG auto               = "   << std::hex << read_vme_state_machine_jtag_auto_ << std::endl;
                (*MyOutput_) << "    VME ready               = "   << std::hex << read_vme_state_machine_vme_ready_ << std::endl;
                (*MyOutput_) << "    state machine OK        = "   << std::hex << read_vme_state_machine_ok_        << std::endl;
                (*MyOutput_) << "    path OK                 = "   << std::hex << read_vme_state_machine_path_ok_   << std::endl;
                (*MyOutput_) << "    phase shifter autostart = "   << std::hex << read_phase_shifter_auto_          << std::endl;
                (*MyOutput_) << "    throttle                = 0x" << std::hex << read_vme_state_machine_throttle_  << std::endl;
                //
            } else if ( address == vme_sm_wdcnt_adr ) {
                //------------------------------------------------------------------
                //0XDC = ADR_VMESM1:  VME State Machine Word Count
                //------------------------------------------------------------------
                (*MyOutput_) << " ->VME State Machine Word Count register:" << std::endl;
                (*MyOutput_) << "    word count = 0x" << std::hex << read_vme_state_machine_word_count_ << std::endl;
                //
            } else if ( address == vme_sm_cksum_adr ) {
                //------------------------------------------------------------------
                //0XDE = ADR_VMESM2:  VME State Machine Checksum
                //------------------------------------------------------------------
                (*MyOutput_) << " ->VME State Machine Checksum register:" << std::endl;
                (*MyOutput_) << "    check sum               = 0x" << std::hex << read_vme_state_machine_check_sum_                     << std::endl;
                (*MyOutput_) << "    missing header start    = "   << std::hex << read_vme_state_machine_error_missing_header_start_    << std::endl;
                (*MyOutput_) << "    missing header end      = "   << std::hex << read_vme_state_machine_error_missing_header_end_      << std::endl;
                (*MyOutput_) << "    missing data end marker = "   << std::hex << read_vme_state_machine_error_missing_data_end_marker_ << std::endl;
                (*MyOutput_) << "    missing trailer end     = "   << std::hex << read_vme_state_machine_error_missing_trailer_end_     << std::endl;
                (*MyOutput_) << "    word count overflow     = "   << std::hex << read_vme_state_machine_error_word_count_overflow_     << std::endl;
                //
            } else if ( address == num_vme_sm_adr_adr ) {
                //------------------------------------------------------------------
                //0XE0 = ADR_VMESM3:  Number of VME addresses written by VMESM
                //------------------------------------------------------------------
                (*MyOutput_) << " ->VME State Machine Address Count register:" << std::endl;
                (*MyOutput_) << "    Number of VME writes = 0x" << std::hex << read_vme_state_machine_number_of_vme_writes_ << std::endl;
                //
            } else if ( address == rat_3d_delays_adr ) {
                //------------------------------------------------------------------
                //0XE6 = ADR_DDDR0:  RAT 3D3444 RPC Delays, 1 step = 2ns
                //------------------------------------------------------------------
                (*MyOutput_) << " ->RPC/RAT phase delay register:" << std::endl;
                (*MyOutput_) << "    RPC0/RAT rx phase = " << std::dec << read_rpc0_rat_delay_ << std::endl;
                (*MyOutput_) << "    RPC1/RAT rx phase = " << std::dec << read_rpc1_rat_delay_ << std::endl;
                //
            } else if ( address == tmb_stat_adr ) {
                //---------------------------------------------------------------------
                //0XEA = ADR_BDSTATUS:  Board Status Summary (copy of raw-hits header)
                //---------------------------------------------------------------------
                (*MyOutput_) << " ->Board Status Summary register:" << std::endl;
                (*MyOutput_) << "    board status OK                 = " << std::hex << read_bdstatus_ok_     << std::endl;
                (*MyOutput_) << "    5.0V critical OK                = " << std::hex << read_vstat_5p0v_      << std::endl;
                (*MyOutput_) << "    3.3V critical OK                = " << std::hex << read_vstat_3p3v_      << std::endl;
                (*MyOutput_) << "    1.8V critical OK                = " << std::hex << read_vstat_1p8v_      << std::endl;
                (*MyOutput_) << "    1.5V critical OK                = " << std::hex << read_vstat_1p5v_      << std::endl;
                (*MyOutput_) << "    Temperature not critical        = " << std::hex << read_nt_crit_         << std::endl;
                (*MyOutput_) << "    VME state machine OK            = " << std::hex << read_vsm_ok_          << std::endl;
                (*MyOutput_) << "    VME state machine aborted       = " << std::hex << read_vsm_aborted_     << std::endl;
                (*MyOutput_) << "    VME state machine checksum OK   = " << std::hex << read_vsm_cksum_ok_    << std::endl;
                (*MyOutput_) << "    VME state machine wordcount OK  = " << std::hex << read_vsm_wdcnt_ok_    << std::endl;
                (*MyOutput_) << "    JTAG state machine OK           = " << std::hex << read_jsm_ok_          << std::endl;
                (*MyOutput_) << "    JTAG state machine aborted      = " << std::hex << read_jsm_aborted_     << std::endl;
                (*MyOutput_) << "    JTAG state machine check sum OK = " << std::hex << read_jsm_cksum_ok_    << std::endl;
                (*MyOutput_) << "    JTAG state machine wordcount OK = " << std::hex << read_jsm_wdcnt_ok_    << std::endl;
                (*MyOutput_) << "    JTAG state machine FPGA TCK OK  = " << std::hex << read_jsm_tck_fpga_ok_ << std::endl;
                //
            } else if ( address == layer_trg_mode_adr ) {
                //---------------------------------------------------------------------
                //0XF0 = ADR_LAYER_TRIG:  Layer-Trigger Mode
                //---------------------------------------------------------------------
                (*MyOutput_) << " ->Layer-trigger mode register:" << std::endl;
                (*MyOutput_) << "    Enable layer trigger mode = " << std::dec << read_layer_trigger_en_  << std::endl; 
                (*MyOutput_) << "    Layer trigger threshold   = " << std::dec << read_layer_trig_thresh_ << std::endl; 
                (*MyOutput_) << "    Number of layers hit      = " << std::dec << read_number_layers_hit_ << std::endl; 
                (*MyOutput_) << "    CLCT throttle             = " << std::dec << read_clct_throttle_     << std::endl; 
                //
            } else if ( address == pattern_find_pretrg_adr ) {
                //---------------------------------------------------------------------
                //0XF4 = ADR_TEMP0:  Pattern Finder Pretrigger
                //---------------------------------------------------------------------
                (*MyOutput_) << " ->CLCT Pattern Finder pretrigger configuration register:" << std::endl;
                (*MyOutput_) << "    Blank CLCT output if no valid pattern flag                = " << std::dec << read_clct_blanking_                     << std::endl; 
                (*MyOutput_) << "    Stagger CLCT layers                                       = " << std::dec << read_clct_stagger_                      << std::endl; 
                (*MyOutput_) << "    Minimum pattern ID value for CLCT pretrig                 = " << std::dec << read_clct_pattern_id_thresh_            << std::endl; 
                (*MyOutput_) << "    Minimum pattern ID value for CLCT pattern trigger         = " << std::dec << read_clct_pattern_id_thresh_postdrift_  << std::endl; 
                (*MyOutput_) << "    Distance from key on CFEBn to CFEBn+1 to set AFF for n+1  = " << std::dec << read_adjacent_cfeb_distance_            << std::endl; 
                //
            } else if ( address == clct_separation_adr ) {
                //---------------------------------------------------------------------
                //0XF6 = ADR_TEMP1:  CLCT separation
                //---------------------------------------------------------------------
                (*MyOutput_) << " ->CLCT Separation register:" << std::endl;
                (*MyOutput_) << "    CLCT separation source = VME      = " << std::dec << read_clct_separation_src_               << std::endl; 
                (*MyOutput_) << "    CLCT separation RAM write enable  = " << std::dec << read_clct_separation_ram_write_enable_  << std::endl; 
                (*MyOutput_) << "    CLCT separation RAM address       = " << std::dec << read_clct_separation_ram_adr_           << std::endl; 
                (*MyOutput_) << "    Minimum 1/2-strip CLCT separation = " << std::dec << read_min_clct_separation_               << std::endl; 
                //
            } else if ( address == clock_status_adr ) {
                //---------------------------------------------------------------------
                //0XFC = ADR_CCB_STAT1:  CCB Status Register (cont. from 0x2E)
                //--------------------------------------------------------------------- 
                (*MyOutput_) << " ->Clock status register:" << std::endl;
                (*MyOutput_) << "    TTCrx lock never achieved     = " << std::hex << read_ccb_ttcrx_lock_never_ << std::endl;
                (*MyOutput_) << "    TTCrx lock lost at least once = " << std::hex << read_ccb_ttcrx_lost_ever_  << std::endl;
                (*MyOutput_) << "    QPLL lock never achieved      = " << std::hex << read_ccb_qpll_lock_never_  << std::endl;
                (*MyOutput_) << "    QPLL lock lost at least once  = " << std::hex << read_ccb_qpll_lost_ever_   << std::endl;
                //
            } else if ( address == l1a_lookback_adr ) {    
                //---------------------------------------------------------------------
                //0X100 = ADR_L1A_LOOKBACK:  L1A Lookback Distance
                //---------------------------------------------------------------------
                (*MyOutput_) << " ->L1A Lookback Distance register:" << std::endl;
                (*MyOutput_) << "    bx to back from L1A for L1A-only readout (dec) = "   << std::dec <<read_l1a_allow_notmb_lookback_ << std::endl;
                (*MyOutput_) << "    Injector RAM write data MSBs                   = 0x" << std::hex <<read_inj_wrdata_msb_           << std::endl;
                (*MyOutput_) << "    Injector RAM read data MSBs                    = 0x" << std::hex <<read_inj_rdata_msb_            << std::endl;
                (*MyOutput_) << "    Limit TMB to 1 event readout per L1A           = "   << std::hex <<read_l1a_priority_enable_      << std::endl;
                //
            } else if ( address == alct_sync_ctrl_adr ) {
                //---------------------------------------------------------------------
                //0X104 = ADR_ALCT_SYNC_CTRL:  ALCT Sync Mode Control
                //---------------------------------------------------------------------
                (*MyOutput_) << " ->ALCT sync mode control register:" << std::endl;
                (*MyOutput_) << "    Sync mode:  delay pointer to valid data       = 0x" << std::hex << read_alct_sync_rxdata_dly_        << std::endl;
                (*MyOutput_) << "    Sync mode:  TMB transmits random data to ALCT = "   << std::hex << read_alct_sync_tx_random_         << std::endl;
                (*MyOutput_) << "    ALCT sync mode:  clear rng error FFs          = "   << std::hex << read_alct_sync_clear_errors_      << std::endl;
                (*MyOutput_) << "    ALCT to TMB:  1st-in-time match OK            = "   << std::hex << read_alct_sync_1st_error_         << std::endl;
                (*MyOutput_) << "    ALCT to TMB:  2nd-in-time match OK            = "   << std::hex << read_alct_sync_2nd_error_         << std::endl;
                (*MyOutput_) << "    ALCT to TMB:  1st-in-time match OK, latched   = "   << std::hex << read_alct_sync_1st_error_latched_ << std::endl;
                (*MyOutput_) << "    ALCT to TMB:  2nd-in-time match OK, latched   = "   << std::hex << read_alct_sync_2nd_error_latched_ << std::endl;
                //
            } else if ( address == alct_sync_txdata_1st_adr ) {
                //---------------------------------------------------------------------
                //0X106 = ADR_ALCT_SYNC_TXDATA_1ST:  ALCT Sync Mode Transmit Data 1st
                //---------------------------------------------------------------------
                (*MyOutput_) << " ->ALCT sync mode Transmit Data 1st frame:" << std::endl;
                (*MyOutput_) << "    Sync mode data to send for loopback 1st frame = 0x" << std::hex << read_alct_sync_txdata_1st_ << std::endl;
                //
            } else if ( address == alct_sync_txdata_2nd_adr ) {
                //---------------------------------------------------------------------
                //0X108 = ADR_ALCT_SYNC_TXDATA_2ND:  ALCT Sync Mode Transmit Data 2nd
                //---------------------------------------------------------------------
                (*MyOutput_) << " ->ALCT sync mode Transmit Data 2nd frame:" << std::endl;
                (*MyOutput_) << "    Sync mode data to send for loopback 2nd frame = 0x" << std::hex << read_alct_sync_txdata_2nd_ << std::endl;
                //
            } else if ( address == miniscope_adr ) {
                //---------------------------------------------------------------------
                //0X10C = ADR_MINISCOPE:  Internal 16 Channel Digital Scope
                //---------------------------------------------------------------------
                (*MyOutput_) << " ->Internal 16 channel digital scope:" << std::endl;
                (*MyOutput_) << "  miniscope_enable                         = "   << std::hex << read_miniscope_enable_  << std::endl;
                (*MyOutput_) << "  Miniscope data=write adr (for testing)   = 0x" << std::hex << read_mini_tbins_test_   << std::endl;
                (*MyOutput_) << "  Insert tbins & pretrig tbins in 1st word = "   << std::hex << read_mini_tbins_word_   << std::endl;
                (*MyOutput_) << "  Number of FIFO tbins in miniscope        = 0x" << std::hex << read_fifo_tbins_mini_   << std::endl;
                (*MyOutput_) << "  Number of FIFO tbins before pretrig      = 0x" << std::hex << read_fifo_pretrig_mini_ << std::endl;
                //
            } else if ( address == phaser_alct_rxd_adr ) {
                //--------------------------------------------------------------
                //[0X10E] = ADR_PHASER0:  ALCT -> TMB communication clock delay
                //--------------------------------------------------------------
                (*MyOutput_) << " ->ALCT to TMB communication clock delay:" << std::endl;
                (*MyOutput_) << "    ALCT rx clock delay    = " << std::dec << read_alct_rx_clock_delay_ << std::endl;
                //
            } else if ( address == phaser_alct_txd_adr ) {
                //--------------------------------------------------------------
                //[0X110] = ADR_PHASER1:  TMB -> ALCT communication clock delay
                //--------------------------------------------------------------
                (*MyOutput_) << " ->TMB to ALCT communication clock delay:" << std::endl;
                (*MyOutput_) << "    ALCT tx clock delay    = " << std::dec << read_alct_tx_clock_delay_ << std::endl;
                //
            } else if ( address == phaser_cfeb0_rxd_adr ) {
                //--------------------------------------------------------------
                //[0X112] = ADR_PHASER2:  CFEB0 -> TMB communication clock delay
                //--------------------------------------------------------------
                (*MyOutput_) << " ->CFEB0 to TMB communication clock delay:" << std::endl;
                (*MyOutput_) << "    CFEB0 rx clock delay    = " << std::dec << read_cfeb0_rx_clock_delay_ << std::endl;
                //
            } else if ( address == phaser_cfeb1_rxd_adr ) {
                //--------------------------------------------------------------
                //[0X114] = ADR_PHASER3:  CFEB1 -> TMB communication clock delay
                //--------------------------------------------------------------
                (*MyOutput_) << " ->CFEB1 to TMB communication clock delay:" << std::endl;
                (*MyOutput_) << "    CFEB1 rx clock delay    = " << std::dec << read_cfeb1_rx_clock_delay_ << std::endl;
                //
            } else if ( address == phaser_cfeb2_rxd_adr ) {
                //--------------------------------------------------------------
                //[0X116] = ADR_PHASER4:  CFEB2 -> TMB communication clock delay
                //--------------------------------------------------------------
                (*MyOutput_) << " ->CFEB2 to TMB communication clock delay:" << std::endl;
                (*MyOutput_) << "    CFEB2 rx clock delay    = " << std::dec << read_cfeb2_rx_clock_delay_ << std::endl;
                //
            } else if ( address == phaser_cfeb3_rxd_adr ) {
                //--------------------------------------------------------------
                //[0X118] = ADR_PHASER5:  CFEB3 -> TMB communication clock delay
                //--------------------------------------------------------------
                (*MyOutput_) << " ->CFEB3 to TMB communication clock delay:" << std::endl;
                (*MyOutput_) << "    CFEB3 rx clock delay    = " << std::dec << read_cfeb3_rx_clock_delay_ << std::endl;
                //
            } else if ( address == phaser_cfeb4_rxd_adr ) {
                //--------------------------------------------------------------
                //[0X11A] = ADR_PHASER6:  CFEB4 -> TMB communication clock delay
                //--------------------------------------------------------------
                (*MyOutput_) << " ->CFEB4 to TMB communication clock delay:" << std::endl;
                (*MyOutput_) << "    CFEB4 rx clock delay    = " << std::dec << read_cfeb4_rx_clock_delay_ << std::endl;
                //
            } else if ( address == cfeb0_3_interstage_adr ) {
                //--------------------------------------------------------------
                // 0X11C = ADR_DELAY0_INT:  CFEB to TMB "interstage" delays
                //--------------------------------------------------------------
                (*MyOutput_) << " ->CFEB to TMB interstage delays:" << std::endl;
                (*MyOutput_) << "    CFEB0 receive interstage delay    = " << std::dec << read_cfeb0_rxd_int_delay_ << std::endl;
                (*MyOutput_) << "    CFEB1 receive interstage delay    = " << std::dec << read_cfeb1_rxd_int_delay_ << std::endl;
                (*MyOutput_) << "    CFEB2 receive interstage delay    = " << std::dec << read_cfeb2_rxd_int_delay_ << std::endl;
                (*MyOutput_) << "    CFEB3 receive interstage delay    = " << std::dec << read_cfeb3_rxd_int_delay_ << std::endl;
                //
            } else if ( address == cfeb4_interstage_adr ) {
                //--------------------------------------------------------------
                // 0X11E = ADR_DELAY1_INT:  CFEB to TMB "interstage" delays
                //--------------------------------------------------------------
                (*MyOutput_) << " ->CFEB to TMB interstage delays:" << std::endl;
                (*MyOutput_) << "    CFEB4 receive interstage delay    = " << std::dec << read_cfeb4_rxd_int_delay_ << std::endl;
                //
            } else if ( address == sync_err_control_adr ) {
                //---------------------------------------------------------------------
                // 0X120 = ADR_SYNC_ERR_CTRL:  Synchronization Error Control
                //---------------------------------------------------------------------
                (*MyOutput_) << " ->Synchronization Error Control:" << std::endl;
                (*MyOutput_) << "   VME sync error reset = "                << read_sync_err_reset_ << std::endl;
                (*MyOutput_) << "   Enable sync error type:  BXN != offset at ttc_bx0 arrival    = " << read_clct_bx0_sync_err_enable_    << std::endl;
                (*MyOutput_) << "   Enable sync error type:  Uncorrected ECC data from TMB->ALCT = " << read_alct_ecc_rx_sync_err_enable_ << std::endl; 
                (*MyOutput_) << "   Enable sync error type:  Uncorrected ECC data from ALCT->TMB = " << read_alct_ecc_tx_sync_err_enable_ << std::endl;
                (*MyOutput_) << "   Enable sync error type:  alct_bx0 != clct_bx0                = " << read_bx0_match_sync_err_enable_   << std::endl;
                (*MyOutput_) << "   Enable sync error type:  clock lock lost                     = " << read_clock_lock_lost_sync_err_enable_ << std::endl;
                (*MyOutput_) << "   Enable sync error to blank LCTs to MPC     = " << read_sync_err_blanks_mpc_enable_    << std::endl;
                (*MyOutput_) << "   Enable sync error to stop CLCT pretriggers = " << read_sync_err_stops_pretrig_enable_ << std::endl;
                (*MyOutput_) << "   Enable sync error to stop TMB readout      = " << read_sync_err_stops_readout_enable_ << std::endl;
                (*MyOutput_) << "   Synchonization Error                                  = " << read_sync_err_             << std::endl;
                (*MyOutput_) << "   Sync error type:  BXN != offset at ttc_bx0 arrival    = " << read_clct_bx0_sync_err_    << std::endl;
                (*MyOutput_) << "   Sync error type:  Uncorrected ECC data from TMB->ALCT = " << read_alct_ecc_rx_sync_err_ << std::endl;
                (*MyOutput_) << "   Sync error type:  Uncorrected ECC data from ALCT->TMB = " << read_alct_ecc_tx_sync_err_ << std::endl;
                (*MyOutput_) << "   Sync error type:  alct_bx0 != clct_bx0                = " << read_bx0_match_sync_err_   << std::endl;
                (*MyOutput_) << "   Sync error type:  clock lock lost                     = " << read_clock_lock_lost_sync_err_<< std::endl;
                //
            } else if ( address == cfeb_badbits_ctrl_adr ) {
                //---------------------------------------------------------------------
                // 0X122 = ADR_CFEB_BADBITS_CTRL:  CFEB badbits control/status
                //---------------------------------------------------------------------
                (*MyOutput_) << " ->CFEB badbits control/status:" << std::endl;
                (*MyOutput_) << "    Mask of CFEBs to reset badbits         = 0x" << std::hex << read_cfeb_badbits_reset_ << std::endl;
                (*MyOutput_) << "    Mask of CFEBs to block badbits         = 0x" << std::hex << read_cfeb_badbits_block_ << std::endl;
                (*MyOutput_) << "    Mask of CFEBs with at least one badbit = 0x" << std::hex << read_cfeb_badbits_found_ << std::endl;
                (*MyOutput_) << "    At least one CFEB has a blocked badbit =   " << std::hex << read_cfeb_badbits_blocked_ << std::endl;
                //
            } else if ( address == cfeb_badbits_timer_adr ) {
                //---------------------------------------------------------------------
                // 0X124 = ADR_CFEB_BADBITS_TIMER:  CFEB badbits check interval
                //---------------------------------------------------------------------
                (*MyOutput_) << " ->CFEB badbits timer:" << std::endl;
                (*MyOutput_) << "    Check interval for CFEB badbits = " << std::dec << read_cfeb_badbits_nbx_ << std::endl;
                //
            } else {
                //
                (*MyOutput_) << " -> Unable to decode register: PLEASE DEFINE" << std::endl;
                //
            }
            return;
        }
        //
        void TMB::PrintFirmwareDate() {
            //
            (*MyOutput_) << "-> TMB Firmware date: " << std::dec
                << GetReadTmbFirmwareYear() << " . " 
                << GetReadTmbFirmwareMonth() << " . " 
                << GetReadTmbFirmwareDay() << std::endl;
            (*MyOutput_) << "-> TMB Firmware type   : " << std::hex << GetReadTmbFirmwareType()    << std::endl;
            (*MyOutput_) << "-> TMB Firmware version: " << std::hex << GetReadTmbFirmwareVersion() << std::endl;
            (*MyOutput_) << "-> TMB Firmware RevCode: " << std::hex << GetReadTmbFirmwareRevcode() << std::endl;
            //
            return;
        }
        //
        void TMB::PrintBootRegister() {
            //
            //-----------------------------------------------------------------
            //0X70000 = ADR_BOOT:  Hardware Bootstrap Register
            //-----------------------------------------------------------------
            (*MyOutput_) << " boot register tdi                     = "  << std::hex << read_boot_tdi_                     << std::endl;
            (*MyOutput_) << " boot register tms                     = "  << std::hex << read_boot_tms_                     << std::endl;
            (*MyOutput_) << " boot register tck                     = "  << std::hex << read_boot_tck_                     << std::endl;
            (*MyOutput_) << " boot register jtag chain select       = 0x"<< std::hex << read_boot_jtag_chain_select_       << std::endl;
            (*MyOutput_) << " boot register control JTAG chain      = "  << std::hex << read_boot_control_jtag_chain_      << std::endl;
            (*MyOutput_) << " boot register hard reset ALCT         = "  << std::hex << read_boot_hard_reset_alct_         << std::endl;
            (*MyOutput_) << " boot register hard reset TMB          = "  << std::hex << read_boot_hard_reset_tmb_          << std::endl;
            (*MyOutput_) << " boot register disable hard reset ALCT = "  << std::hex << read_boot_disable_hard_reset_alct_ << std::endl;
            (*MyOutput_) << " boot register disable VME             = "  << std::hex << read_boot_disable_VME_             << std::endl;
            (*MyOutput_) << " boot register disable TMB mezz clock  = "  << std::hex << read_boot_disable_mezz_clock_      << std::endl;
            (*MyOutput_) << " boot register hard reset RAT          = "  << std::hex << read_boot_hard_reset_rat_          << std::endl;
            (*MyOutput_) << " boot register VME ready               = "  << std::hex << read_boot_vme_ready_               << std::endl;
            (*MyOutput_) << " boot register tdo                     = "  << std::hex << read_boot_tdo_                     << std::endl;
            //
            return;
        }
        //
        //
        ////////////////////////////////////////////////////////////////////////////////////////
        // Fill register value with values extracted from database
        ////////////////////////////////////////////////////////////////////////////////////////
        void TMB::Set_cfeb_enable_source(int value) {
            //
            cfeb_enable_source_orig = value;
            // decode TMB VME register into the bit which the VME register expects
            if (value == 42) {
                SetCfebEnableSource_(1);     
            } else if (value == 68) {
                SetCfebEnableSource_(0);     
            }
            return;
        }
        //
        int TMB::FillTMBRegister(unsigned long int address) {
            //
            // Default to write 0's into bits not specified
            int data_word = 0;
            //
            if ( address == vme_loopbk_adr ) {
                //------------------------------------------------------------------
                //0X0E = ADR_LOOPBK:  Loop-Back Control Register  
                //------------------------------------------------------------------
                InsertValueIntoDataWord(enable_alct_rx_,enable_alct_rx_bithi,enable_alct_rx_bitlo,&data_word);
                InsertValueIntoDataWord(enable_alct_tx_,enable_alct_tx_bithi,enable_alct_tx_bitlo,&data_word);
                //
            } else if ( address == vme_dddsm_adr ) {    
                //------------------------------------------------------------------
                //0X14 = ADR_DDDSM:  3D3444 State Machine Control + DCM Lock Status  
                //------------------------------------------------------------------
                InsertValueIntoDataWord(ddd_state_machine_start_     ,ddd_state_machine_start_bithi     ,ddd_state_machine_start_bitlo     ,&data_word);
                InsertValueIntoDataWord(ddd_state_machine_manual_    ,ddd_state_machine_manual_bithi    ,ddd_state_machine_manual_bitlo    ,&data_word);
                InsertValueIntoDataWord(ddd_state_machine_latch_     ,ddd_state_machine_latch_bithi     ,ddd_state_machine_latch_bitlo     ,&data_word);
                InsertValueIntoDataWord(ddd_state_machine_serial_in_ ,ddd_state_machine_serial_in_bithi ,ddd_state_machine_serial_in_bitlo ,&data_word);
                InsertValueIntoDataWord(ddd_state_machine_serial_out_,ddd_state_machine_serial_out_bithi,ddd_state_machine_serial_out_bitlo,&data_word);
                InsertValueIntoDataWord(ddd_state_machine_autostart_ ,ddd_state_machine_autostart_bithi ,ddd_state_machine_autostart_bitlo ,&data_word);
                //
            } else if ( address == vme_ddd0_adr ) {
                //------------------------------------------------------------------
                //0X16 = ADR_DDD0:  3D3444 Chip 0 Delays, 1 step = 2ns
                //------------------------------------------------------------------
                InsertValueIntoDataWord(alct_tof_delay_,alct_tof_delay_bithi,alct_tof_delay_bitlo,&data_word);
                InsertValueIntoDataWord(dmb_tx_delay_  ,dmb_tx_delay_bithi  ,dmb_tx_delay_bitlo  ,&data_word); 
                InsertValueIntoDataWord(rat_tmb_delay_ ,rat_tmb_delay_bithi ,rat_tmb_delay_bitlo ,&data_word);
                //
            } else if ( address == vme_ddd1_adr ) {
                //------------------------------------------------------------------
                //0X18 = ADR_DDD1:  3D3444 Chip 1 Delays, 1 step = 2ns
                //------------------------------------------------------------------
                InsertValueIntoDataWord(tmb1_phase_     ,tmb1_phase_bithi     ,tmb1_phase_bitlo     ,&data_word);
                InsertValueIntoDataWord(cfeb_tof_delay_ ,cfeb_tof_delay_bithi ,cfeb_tof_delay_bitlo ,&data_word);
                InsertValueIntoDataWord(cfeb0_tof_delay_,cfeb0_tof_delay_bithi,cfeb0_tof_delay_bitlo,&data_word);
                //
            } else if ( address == vme_ddd2_adr ) {
                //------------------------------------------------------------------
                //0X1A = ADR_DDD2:  3D3444 Chip 2 Delays, 1 step = 2ns
                //------------------------------------------------------------------
                InsertValueIntoDataWord(cfeb1_tof_delay_,cfeb1_tof_delay_bithi,cfeb1_tof_delay_bitlo,&data_word);
                InsertValueIntoDataWord(cfeb2_tof_delay_,cfeb2_tof_delay_bithi,cfeb2_tof_delay_bitlo,&data_word);
                InsertValueIntoDataWord(cfeb3_tof_delay_,cfeb3_tof_delay_bithi,cfeb3_tof_delay_bitlo,&data_word);
                InsertValueIntoDataWord(cfeb4_tof_delay_,cfeb4_tof_delay_bithi,cfeb4_tof_delay_bitlo,&data_word);
                //
            } else if ( address == vme_ratctrl_adr ) {
                //------------------------------------------------------------------
                //0X1E = ADR_RATCTRL:  RAT Module Control
                //------------------------------------------------------------------
                InsertValueIntoDataWord(rpc_sync_  ,rpc_sync_bithi  ,rpc_sync_bitlo  ,&data_word);
                InsertValueIntoDataWord(shift_rpc_ ,shift_rpc_bithi ,shift_rpc_bitlo ,&data_word);
                InsertValueIntoDataWord(rat_dsn_en_,rat_dsn_en_bithi,rat_dsn_en_bitlo,&data_word);
                //
            } else if ( address == vme_adc_adr ) {
                //------------------------------------------------------------------
                //0X24 = ADR_ADC:  ADC + power comparator
                //-----------------------------------------------------------------
                InsertValueIntoDataWord(voltage_adc_data_out_        ,voltage_adc_data_out_bithi        ,voltage_adc_data_out_bitlo        ,&data_word);
                InsertValueIntoDataWord(voltage_adc_serial_clock_    ,voltage_adc_serial_clock_bithi    ,voltage_adc_serial_clock_bitlo    ,&data_word);
                InsertValueIntoDataWord(voltage_adc_data_in_         ,voltage_adc_data_in_bithi         ,voltage_adc_data_in_bitlo         ,&data_word);
                InsertValueIntoDataWord(voltage_adc_chip_select_     ,voltage_adc_chip_select_bithi     ,voltage_adc_chip_select_bitlo     ,&data_word);
                InsertValueIntoDataWord(temperature_adc_serial_clock_,temperature_adc_serial_clock_bithi,temperature_adc_serial_clock_bitlo,&data_word);
                InsertValueIntoDataWord(temperature_adc_serial_data_ ,temperature_adc_serial_data_bithi ,temperature_adc_serial_data_bitlo ,&data_word);
                //
            } else if ( address == ccb_cfg_adr ) {
                //------------------------------------------------------------------
                //0X2A = ADR_CCB_CFG:  CCB Configuration
                //------------------------------------------------------------------
                InsertValueIntoDataWord(ignore_ccb_rx_                 ,ignore_ccb_rx_bithi                ,ignore_ccb_rx_bitlo                ,&data_word);
                InsertValueIntoDataWord(disable_ccb_tx_                ,disable_ccb_tx_bithi               ,disable_ccb_tx_bitlo               ,&data_word);
                InsertValueIntoDataWord(enable_internal_l1a_           ,enable_internal_l1a_bithi          ,enable_internal_l1a_bitlo          ,&data_word);
                InsertValueIntoDataWord(enable_alctclct_status_to_ccb_ ,enable_alctclct_status_to_ccb_bithi,enable_alctclct_status_to_ccb_bitlo,&data_word);
                InsertValueIntoDataWord(enable_alct_status_to_ccb_     ,enable_alct_status_to_ccb_bithi    ,enable_alct_status_to_ccb_bitlo    ,&data_word);
                InsertValueIntoDataWord(enable_clct_status_to_ccb_     ,enable_clct_status_to_ccb_bithi    ,enable_clct_status_to_ccb_bitlo    ,&data_word);
                InsertValueIntoDataWord(fire_l1a_oneshot_              ,fire_l1a_oneshot_bithi             ,fire_l1a_oneshot_bitlo             ,&data_word);
                //
            } else if ( address == ccb_trig_adr ) {
                //------------------------------------------------------------------
                //0X2C = ADR_CCB_TRIG:  CCB Trigger Control
                //------------------------------------------------------------------
                InsertValueIntoDataWord(alct_ext_trig_l1aen_   ,alct_ext_trig_l1aen_bithi   ,alct_ext_trig_l1aen_bitlo   ,&data_word);
                InsertValueIntoDataWord(clct_ext_trig_l1aen_   ,clct_ext_trig_l1aen_bithi   ,clct_ext_trig_l1aen_bitlo   ,&data_word);
                InsertValueIntoDataWord(request_l1a_           ,request_l1a_bithi           ,request_l1a_bitlo           ,&data_word);
                InsertValueIntoDataWord(alct_ext_trig_vme_     ,alct_ext_trig_vme_bithi     ,alct_ext_trig_vme_bitlo     ,&data_word);
                InsertValueIntoDataWord(clct_ext_trig_vme_     ,clct_ext_trig_vme_bithi     ,clct_ext_trig_vme_bitlo     ,&data_word);
                InsertValueIntoDataWord(ext_trig_both_         ,ext_trig_both_bithi         ,ext_trig_both_bitlo         ,&data_word);
                InsertValueIntoDataWord(ccb_allow_bypass_      ,ccb_allow_bypass_bithi      ,ccb_allow_bypass_bitlo      ,&data_word);
                InsertValueIntoDataWord(ignore_ccb_startstop_  ,ignore_ccb_startstop_bithi  ,ignore_ccb_startstop_bitlo  ,&data_word);
                InsertValueIntoDataWord(internal_l1a_delay_vme_,internal_l1a_delay_vme_bithi,internal_l1a_delay_vme_bitlo,&data_word);
                //
            } else if ( address == alct_cfg_adr ) {
                //------------------------------------------------------------------
                //0X30 = ADR_ALCT_CFG:  ALCT Configuration
                //------------------------------------------------------------------
                InsertValueIntoDataWord(cfg_alct_ext_trig_en_  ,cfg_alct_ext_trig_en_bithi  ,cfg_alct_ext_trig_en_bitlo  ,&data_word);
                InsertValueIntoDataWord(cfg_alct_ext_inject_en_,cfg_alct_ext_inject_en_bithi,cfg_alct_ext_inject_en_bitlo,&data_word);
                InsertValueIntoDataWord(cfg_alct_ext_trig_     ,cfg_alct_ext_trig_bithi     ,cfg_alct_ext_trig_bitlo     ,&data_word);
                InsertValueIntoDataWord(cfg_alct_ext_inject_   ,cfg_alct_ext_inject_bithi   ,cfg_alct_ext_inject_bitlo   ,&data_word);
                InsertValueIntoDataWord(alct_seq_cmd_          ,alct_seq_cmd_bithi          ,alct_seq_cmd_bitlo          ,&data_word);
                InsertValueIntoDataWord(alct_clock_en_use_ccb_ ,alct_clock_en_use_ccb_bithi ,alct_clock_en_use_ccb_bitlo ,&data_word);
                InsertValueIntoDataWord(alct_clock_en_use_vme_ ,alct_clock_en_use_vme_bithi ,alct_clock_en_use_vme_bitlo ,&data_word);
                //
            } else if ( address == alct_inj_adr ) {
                //------------------------------------------------------------------
                //0X32 = ADR_ALCT_INJ:  ALCT Injector Control
                //------------------------------------------------------------------
                InsertValueIntoDataWord(alct_clear_     ,alct_clear_bithi     ,alct_clear_bitlo     ,&data_word);
                InsertValueIntoDataWord(alct_inject_mux_,alct_inject_mux_bithi,alct_inject_mux_bitlo,&data_word);
                InsertValueIntoDataWord(alct_sync_clct_ ,alct_sync_clct_bithi ,alct_sync_clct_bitlo ,&data_word);
                InsertValueIntoDataWord(alct_inj_delay_ ,alct_inj_delay_bithi ,alct_inj_delay_bitlo ,&data_word);
                //
            } else if ( address == alct_stat_adr ) {
                //------------------------------------------------------------------
                //0X38 = ADR_ALCT_STAT:  ALCT Sequencer Control/Status
                //------------------------------------------------------------------
                InsertValueIntoDataWord(alct_ecc_en_       ,alct_ecc_en_bithi       ,alct_ecc_en_bitlo       ,&data_word);
                InsertValueIntoDataWord(alct_ecc_err_blank_,alct_ecc_err_blank_bithi,alct_ecc_err_blank_bitlo,&data_word);
                InsertValueIntoDataWord(alct_txdata_delay_ ,alct_txdata_delay_bithi ,alct_txdata_delay_bitlo ,&data_word);
                //
            } else if ( address == cfeb_inj_adr ) {
                //------------------------------------------------------------------
                //0X42 = ADR_CFEB_INJ:  CFEB Injector Control
                //------------------------------------------------------------------
                InsertValueIntoDataWord(enableCLCTInputs_ ,enableCLCTInputs_bithi ,enableCLCTInputs_bitlo ,&data_word);
                InsertValueIntoDataWord(cfeb_ram_sel_     ,cfeb_ram_sel_bithi     ,cfeb_ram_sel_bitlo     ,&data_word);
                InsertValueIntoDataWord(cfeb_inj_en_sel_  ,cfeb_inj_en_sel_bithi  ,cfeb_inj_en_sel_bitlo  ,&data_word);
                InsertValueIntoDataWord(start_pattern_inj_,start_pattern_inj_bithi,start_pattern_inj_bitlo,&data_word);
                //
            } else if ( address == hcm001_adr || address == hcm023_adr || address == hcm045_adr ||
                    address == hcm101_adr || address == hcm123_adr || address == hcm145_adr ||
                    address == hcm201_adr || address == hcm223_adr || address == hcm245_adr ||
                    address == hcm301_adr || address == hcm323_adr || address == hcm345_adr ||
                    address == hcm401_adr || address == hcm423_adr || address == hcm445_adr ) {
                //------------------------------------------------------------------
                //0X4A,4C,4E = ADR_HCM001,HCM023,HCM045 = CFEB0 Hot Channel Masks
                //0X50,52,54 = ADR_HCM101,HCM123,HCM145 = CFEB1 Hot Channel Masks
                //0X56,58,5A = ADR_HCM201,HCM223,HCM245 = CFEB2 Hot Channel Masks
                //0X5C,5E,60 = ADR_HCM301,HCM323,HCM345 = CFEB3 Hot Channel Masks
                //0X62,64,66 = ADR_HCM401,HCM423,HCM445 = CFEB4 Hot Channel Masks
                //------------------------------------------------------------------
                for (int bit_in_register=0; bit_in_register<16; bit_in_register++) {
                    //
                    // get the layer and distrip channels covered by this register
                    int layer   = GetHotChannelLayerFromMap_(address,bit_in_register);
                    int distrip = GetHotChannelDistripFromMap_(address,bit_in_register);
                    //
                    InsertValueIntoDataWord(hot_channel_mask_[layer][distrip],bit_in_register,bit_in_register,&data_word);
                }
                //
            } else if ( address == seq_trig_en_adr ) {
                //------------------------------------------------------------------
                //0X68 = ADR_SEQ_TRIG_EN:  Sequencer Trigger Source Enables
                //------------------------------------------------------------------
                InsertValueIntoDataWord(clct_pat_trig_en_  ,clct_pat_trig_en_bithi  ,clct_pat_trig_en_bitlo  ,&data_word);
                InsertValueIntoDataWord(alct_pat_trig_en_  ,alct_pat_trig_en_bithi  ,alct_pat_trig_en_bitlo  ,&data_word);
                InsertValueIntoDataWord(match_pat_trig_en_ ,match_pat_trig_en_bithi ,match_pat_trig_en_bitlo ,&data_word);
                InsertValueIntoDataWord(adb_ext_trig_en_   ,adb_ext_trig_en_bithi   ,adb_ext_trig_en_bitlo   ,&data_word);
                InsertValueIntoDataWord(dmb_ext_trig_en_   ,dmb_ext_trig_en_bithi   ,dmb_ext_trig_en_bitlo   ,&data_word);
                InsertValueIntoDataWord(clct_ext_trig_en_  ,clct_ext_trig_en_bithi  ,clct_ext_trig_en_bitlo  ,&data_word);
                InsertValueIntoDataWord(alct_ext_trig_en_  ,alct_ext_trig_en_bithi  ,alct_ext_trig_en_bitlo  ,&data_word);
                InsertValueIntoDataWord(vme_ext_trig_      ,vme_ext_trig_bithi      ,vme_ext_trig_bitlo      ,&data_word);
                InsertValueIntoDataWord(ext_trig_inject_   ,ext_trig_inject_bithi   ,ext_trig_inject_bitlo   ,&data_word);
                InsertValueIntoDataWord(all_cfeb_active_   ,all_cfeb_active_bithi   ,all_cfeb_active_bitlo   ,&data_word);
                InsertValueIntoDataWord(cfebs_enabled_     ,cfebs_enabled_bithi     ,cfebs_enabled_bitlo     ,&data_word);
                InsertValueIntoDataWord(cfeb_enable_source_,cfeb_enable_source_bithi,cfeb_enable_source_bitlo,&data_word);
                //    
            } else if ( address == seq_trig_dly0_adr ) {
                //------------------------------------------------------------------
                //0X6A = ADR_SEQ_TRIG_DLY0:  Sequencer Trigger Source Delays
                //------------------------------------------------------------------
                InsertValueIntoDataWord(alct_pretrig_width_,alct_pretrig_width_bithi,alct_pretrig_width_bitlo,&data_word);
                InsertValueIntoDataWord(alct_pretrig_delay_,alct_pretrig_delay_bithi,alct_pretrig_delay_bitlo,&data_word);
                InsertValueIntoDataWord(alct_pattern_delay_,alct_pattern_delay_bithi,alct_pattern_delay_bitlo,&data_word);
                InsertValueIntoDataWord(adb_ext_trig_delay_,adb_ext_trig_delay_bithi,adb_ext_trig_delay_bitlo,&data_word);
                //
            } else if ( address == seq_trig_dly1_adr ) {
                //------------------------------------------------------------------
                //0X6C = ADR_SEQ_TRIG_DLY1:  Sequencer Trigger Source Delays
                //------------------------------------------------------------------
                InsertValueIntoDataWord(dmb_ext_trig_delay_ ,dmb_ext_trig_delay_bithi ,dmb_ext_trig_delay_bitlo ,&data_word);
                InsertValueIntoDataWord(clct_ext_trig_delay_,clct_ext_trig_delay_bithi,clct_ext_trig_delay_bitlo,&data_word);
                InsertValueIntoDataWord(alct_ext_trig_delay_,alct_ext_trig_delay_bithi,alct_ext_trig_delay_bitlo,&data_word);
                //
            } else if ( address == seq_id_adr ) {
                //------------------------------------------------------------------
                //0X6E = ADR_SEQ_ID:  Sequencer Board + CSC Ids
                //------------------------------------------------------------------
                InsertValueIntoDataWord(tmb_slot_,tmb_slot_bithi,tmb_slot_bitlo,&data_word);
                InsertValueIntoDataWord(csc_id_  ,csc_id_bithi  ,csc_id_bitlo  ,&data_word);
                InsertValueIntoDataWord(run_id_  ,run_id_bithi  ,run_id_bitlo  ,&data_word);
                //
            } else if ( address == seq_clct_adr ) {
                //------------------------------------------------------------------
                //0X70 = ADR_SEQ_CLCT:  Sequencer CLCT configuration
                //------------------------------------------------------------------
                InsertValueIntoDataWord(triad_persist_   ,triad_persist_bithi   ,triad_persist_bitlo   ,&data_word);
                InsertValueIntoDataWord(hit_thresh_      ,hit_thresh_bithi      ,hit_thresh_bitlo      ,&data_word);
                InsertValueIntoDataWord(aff_thresh_      ,aff_thresh_bithi      ,aff_thresh_bitlo      ,&data_word);
                InsertValueIntoDataWord(min_hits_pattern_,min_hits_pattern_bithi,min_hits_pattern_bitlo,&data_word);
                InsertValueIntoDataWord(drift_delay_     ,drift_delay_bithi     ,drift_delay_bitlo     ,&data_word);
                InsertValueIntoDataWord(pretrigger_halt_ ,pretrigger_halt_bithi ,pretrigger_halt_bitlo ,&data_word);
                //
            } else if ( address == seq_fifo_adr ) {
                //------------------------------------------------------------------
                //0X72 = ADR_SEQ_FIFO:  Sequencer FIFO configuration
                //------------------------------------------------------------------
                InsertValueIntoDataWord(fifo_mode_           ,fifo_mode_bithi           ,fifo_mode_bitlo           ,&data_word);
                InsertValueIntoDataWord(fifo_tbins_          ,fifo_tbins_bithi          ,fifo_tbins_bitlo          ,&data_word);
                InsertValueIntoDataWord(fifo_pretrig_        ,fifo_pretrig_bithi        ,fifo_pretrig_bitlo        ,&data_word);
                InsertValueIntoDataWord(fifo_no_raw_hits_    ,fifo_no_raw_hits_bithi    ,fifo_no_raw_hits_bitlo    ,&data_word);
                InsertValueIntoDataWord(cfeb_badbits_readout_,cfeb_badbits_readout_bithi,cfeb_badbits_readout_bitlo,&data_word);
                //
            } else if ( address == seq_l1a_adr ) {
                //------------------------------------------------------------------
                //0X74 = ADR_SEQ_L1A:  Sequencer L1A configuration
                //------------------------------------------------------------------
                InsertValueIntoDataWord(l1adelay_        ,l1adelay_bithi        ,l1adelay_bitlo        ,&data_word);
                InsertValueIntoDataWord(l1a_window_size_ ,l1a_window_size_bithi ,l1a_window_size_bitlo ,&data_word);
                InsertValueIntoDataWord(tmb_l1a_internal_,tmb_l1a_internal_bithi,tmb_l1a_internal_bitlo,&data_word);
                //
            } else if ( address == seq_offset_adr ) {
                //------------------------------------------------------------------
                //0X76 = ADR_SEQ_OFFSET:  Sequencer Counter Offsets
                //------------------------------------------------------------------
                InsertValueIntoDataWord(l1a_offset_,l1a_offset_bithi,l1a_offset_bitlo,&data_word);
                InsertValueIntoDataWord(bxn_offset_,bxn_offset_bithi,bxn_offset_bitlo,&data_word);
                //    
            } else if ( address == tmb_trig_adr ) {
                //------------------------------------------------------------------
                //0X86 = ADR_TMB_TRIG:  TMB Trigger configuration/MPC accept
                //------------------------------------------------------------------
                InsertValueIntoDataWord(tmb_sync_err_enable_,tmb_sync_err_enable_bithi,tmb_sync_err_enable_bitlo,&data_word);
                InsertValueIntoDataWord(tmb_allow_alct_     ,tmb_allow_alct_bithi     ,tmb_allow_alct_bitlo     ,&data_word);
                InsertValueIntoDataWord(tmb_allow_clct_     ,tmb_allow_clct_bithi     ,tmb_allow_clct_bitlo     ,&data_word);
                InsertValueIntoDataWord(tmb_allow_match_    ,tmb_allow_match_bithi    ,tmb_allow_match_bitlo    ,&data_word);
                InsertValueIntoDataWord(mpc_rx_delay_       ,mpc_rx_delay_bithi       ,mpc_rx_delay_bitlo       ,&data_word);
                InsertValueIntoDataWord(mpc_sel_ttc_bx0_    ,mpc_sel_ttc_bx0_bithi    ,mpc_sel_ttc_bx0_bitlo    ,&data_word);
                InsertValueIntoDataWord(mpc_idle_blank_     ,mpc_idle_blank_bithi     ,mpc_idle_blank_bitlo     ,&data_word);
                InsertValueIntoDataWord(mpc_output_enable_  ,mpc_output_enable_bithi  ,mpc_output_enable_bitlo  ,&data_word);
                //
            } else if ( address == scp_ctrl_adr ) {
                //------------------------------------------------------------------
                //0X98 = ADR_SCP_CTRL:  Scope Control
                //------------------------------------------------------------------
                InsertValueIntoDataWord(scope_in_readout_,scope_in_readout_bithi,scope_in_readout_bitlo,&data_word);
                //
            } else if ( address == alctfifo1_adr ) {
                //------------------------------------------------------------------
                //0XA8 = ADR_ALCTFIFO1:  ALCT Raw Hits RAM control
                //------------------------------------------------------------------
                InsertValueIntoDataWord(alct_raw_reset_       ,alct_raw_reset_bithi       ,alct_raw_reset_bitlo       ,&data_word);
                InsertValueIntoDataWord(alct_raw_read_address_,alct_raw_read_address_bithi,alct_raw_read_address_bitlo,&data_word);
                InsertValueIntoDataWord(alct_demux_mode_      ,alct_demux_mode_bithi      ,alct_demux_mode_bitlo      ,&data_word);
                //
            } else if ( address == seqmod_adr ) {
                //------------------------------------------------------------------
                //0XAC = ADR_SEQMOD:  Sequencer Trigger Modifiers
                //------------------------------------------------------------------
                InsertValueIntoDataWord(clct_flush_delay_            ,clct_flush_delay_bithi            ,clct_flush_delay_bitlo            ,&data_word);
                InsertValueIntoDataWord(wr_buffer_autoclear_         ,wr_buffer_autoclear_bithi         ,wr_buffer_autoclear_bitlo         ,&data_word);
                InsertValueIntoDataWord(clct_write_continuous_enable_,clct_write_continuous_enable_bithi,clct_write_continuous_enable_bitlo,&data_word);
                InsertValueIntoDataWord(wrt_buf_required_            ,wrt_buf_required_bithi            ,wrt_buf_required_bitlo            ,&data_word);
                InsertValueIntoDataWord(valid_clct_required_         ,valid_clct_required_bithi         ,valid_clct_required_bitlo         ,&data_word);
                InsertValueIntoDataWord(l1a_allow_match_             ,l1a_allow_match_bithi             ,l1a_allow_match_bitlo             ,&data_word);
                InsertValueIntoDataWord(l1a_allow_notmb_             ,l1a_allow_notmb_bithi             ,l1a_allow_notmb_bitlo             ,&data_word);
                InsertValueIntoDataWord(l1a_allow_nol1a_             ,l1a_allow_nol1a_bithi             ,l1a_allow_nol1a_bitlo             ,&data_word);
                InsertValueIntoDataWord(l1a_allow_alct_only_         ,l1a_allow_alct_only_bithi         ,l1a_allow_alct_only_bitlo         ,&data_word);
                InsertValueIntoDataWord(scint_veto_clr_              ,scint_veto_clr_bithi              ,scint_veto_clr_bitlo              ,&data_word);
                //
            } else if ( address == tmbtim_adr ) {
                //------------------------------------------------------------------
                //0XB2 = ADR_TMBTIM:  TMB Timing for ALCT*CLCT Coincidence
                //------------------------------------------------------------------
                InsertValueIntoDataWord(alct_vpf_delay_        ,alct_vpf_delay_bithi        ,alct_vpf_delay_bitlo        ,&data_word);
                InsertValueIntoDataWord(alct_match_window_size_,alct_match_window_size_bithi,alct_match_window_size_bitlo,&data_word);
                InsertValueIntoDataWord(mpc_tx_delay_          ,mpc_tx_delay_bithi          ,mpc_tx_delay_bitlo          ,&data_word);
                //
            } else if ( address == rpc_cfg_adr ) {
                //------------------------------------------------------------------
                //0XB6 = ADR_RPC_CFG:  RPC Configuration
                //------------------------------------------------------------------
                InsertValueIntoDataWord(rpc_exists_     ,rpc_exists_bithi     ,rpc_exists_bitlo     ,&data_word);
                InsertValueIntoDataWord(rpc_read_enable_,rpc_read_enable_bithi,rpc_read_enable_bitlo,&data_word);
                InsertValueIntoDataWord(rpc_bxn_offset_ ,rpc_bxn_offset_bithi ,rpc_bxn_offset_bitlo ,&data_word);
                InsertValueIntoDataWord(rpc_bank_       ,rpc_bank_bithi       ,rpc_bank_bitlo       ,&data_word);
                //
            } else if ( address == rpc_raw_delay_adr ) {
                //------------------------------------------------------------------
                //0XBA = ADR_RPC_RAW_DELAY:  RPC Raw Hits Data Delay
                //------------------------------------------------------------------
                InsertValueIntoDataWord(rpc0_raw_delay_,rpc0_raw_delay_bithi,rpc0_raw_delay_bitlo,&data_word);
                InsertValueIntoDataWord(rpc1_raw_delay_,rpc1_raw_delay_bithi,rpc1_raw_delay_bitlo,&data_word);
                //
            } else if ( address == rpc_inj_adr ) {
                //------------------------------------------------------------------
                //0XBC = ADR_RPC_INJ:  RPC Injector Control
                //------------------------------------------------------------------
                InsertValueIntoDataWord(rpc_mask_all_ ,rpc_mask_all_bithi ,rpc_mask_all_bitlo ,&data_word); 
                InsertValueIntoDataWord(inj_mask_rat_ ,inj_mask_rat_bithi ,inj_mask_rat_bitlo ,&data_word); 
                InsertValueIntoDataWord(inj_mask_rpc_ ,inj_mask_rpc_bithi ,inj_mask_rpc_bitlo ,&data_word); 
                InsertValueIntoDataWord(inj_delay_rat_,inj_delay_rat_bithi,inj_delay_rat_bitlo,&data_word); 
                InsertValueIntoDataWord(rpc_inj_sel_  ,rpc_inj_sel_bithi  ,rpc_inj_sel_bitlo  ,&data_word); 
                InsertValueIntoDataWord(rpc_inj_wdata_,rpc_inj_wdata_bithi,rpc_inj_wdata_bitlo,&data_word); 
                //
            } else if ( address == rpc_tbins_adr ) {
                //------------------------------------------------------------------
                //0XC4 = ADR_RPC_TBINS:  RPC FIFO Time Bins
                //------------------------------------------------------------------
                InsertValueIntoDataWord(fifo_tbins_rpc_  ,fifo_tbins_rpc_bithi  ,fifo_tbins_rpc_bitlo  ,&data_word); 
                InsertValueIntoDataWord(fifo_pretrig_rpc_,fifo_pretrig_rpc_bithi,fifo_pretrig_rpc_bitlo,&data_word); 
                InsertValueIntoDataWord(rpc_decouple_    ,rpc_decouple_bithi    ,rpc_decouple_bitlo    ,&data_word); 
                //
            } else if ( address == bx0_delay_adr ) {
                //------------------------------------------------------------------
                //0XCA = ADR_BX0_DELAY:  BX0 to MPC delays
                //------------------------------------------------------------------
                InsertValueIntoDataWord(alct_bx0_delay_ ,alct_bx0_delay_bithi ,alct_bx0_delay_bitlo ,&data_word);
                InsertValueIntoDataWord(clct_bx0_delay_ ,clct_bx0_delay_bithi ,clct_bx0_delay_bitlo ,&data_word);
                InsertValueIntoDataWord(alct_bx0_enable_,alct_bx0_enable_bithi,alct_bx0_enable_bitlo,&data_word);
                InsertValueIntoDataWord(bx0_vpf_test_   ,bx0_vpf_test_bithi   ,bx0_vpf_test_bitlo   ,&data_word);
                //
            } else if ( address == non_trig_readout_adr ) {
                //-----------------------------------------------------------------------------
                //0XCC = ADR_NON_TRIG_RO:  Non-Triggering Event Enables + ME1/1A(1B) reversal 
                //-----------------------------------------------------------------------------
                InsertValueIntoDataWord(tmb_allow_alct_nontrig_readout_   ,tmb_allow_alct_nontrig_readout_bithi  ,tmb_allow_alct_nontrig_readout_bitlo  ,&data_word);
                InsertValueIntoDataWord(tmb_allow_clct_nontrig_readout_   ,tmb_allow_clct_nontrig_readout_bithi  ,tmb_allow_clct_nontrig_readout_bitlo  ,&data_word);
                InsertValueIntoDataWord(tmb_allow_match_nontrig_readout_  ,tmb_allow_match_nontrig_readout_bithi ,tmb_allow_match_nontrig_readout_bitlo ,&data_word);
                InsertValueIntoDataWord(mpc_block_me1a_                   ,mpc_block_me1a_bithi                  ,mpc_block_me1a_bitlo                  ,&data_word);
                InsertValueIntoDataWord(clct_pretrigger_counter_non_me11_ ,clct_pretrigger_counter_non_me11_bithi,clct_pretrigger_counter_non_me11_bitlo,&data_word);
                //
            } else if ( address == jtag_sm_ctrl_adr ) {
                //------------------------------------------------------------------
                //0XD4 = ADR_JTAGSM0:  JTAG State Machine Control (reads JTAG PROM)
                //------------------------------------------------------------------
                InsertValueIntoDataWord(jtag_state_machine_start_   ,jtag_state_machine_start_bithi   ,jtag_state_machine_start_bitlo   ,&data_word);
                InsertValueIntoDataWord(jtag_state_machine_sreset_  ,jtag_state_machine_sreset_bithi  ,jtag_state_machine_sreset_bitlo  ,&data_word);
                InsertValueIntoDataWord(jtag_disable_write_to_adr10_,jtag_disable_write_to_adr10_bithi,jtag_disable_write_to_adr10_bitlo,&data_word);
                InsertValueIntoDataWord(jtag_state_machine_throttle_,jtag_state_machine_throttle_bithi,jtag_state_machine_throttle_bitlo,&data_word);
                //
            } else if ( address == vme_sm_ctrl_adr ) {
                //------------------------------------------------------------------
                //0XDA = ADR_VMESM0:  VME State Machine Control (reads VME PROM)
                //------------------------------------------------------------------
                InsertValueIntoDataWord(vme_state_machine_start_    ,vme_state_machine_start_bithi    ,vme_state_machine_start_bitlo    ,&data_word);
                InsertValueIntoDataWord(vme_state_machine_sreset_   ,vme_state_machine_sreset_bithi   ,vme_state_machine_sreset_bitlo   ,&data_word);
                InsertValueIntoDataWord(vme_state_machine_jtag_auto_,vme_state_machine_jtag_auto_bithi,vme_state_machine_jtag_auto_bitlo,&data_word);
                InsertValueIntoDataWord(phase_shifter_auto_         ,phase_shifter_auto_bithi         ,phase_shifter_auto_bitlo         ,&data_word);
                InsertValueIntoDataWord(vme_state_machine_throttle_ ,vme_state_machine_throttle_bithi ,vme_state_machine_throttle_bitlo ,&data_word);
                //
            } else if ( address == rat_3d_delays_adr ) {
                //------------------------------------------------------------------
                //0XE6 = ADR_DDDR0:  RAT 3D3444 RPC Delays, 1 step = 2ns
                //------------------------------------------------------------------
                InsertValueIntoDataWord(rpc0_rat_delay_,rpc0_rat_delay_bithi,rpc0_rat_delay_bitlo,&data_word);
                InsertValueIntoDataWord(rpc1_rat_delay_,rpc1_rat_delay_bithi,rpc1_rat_delay_bitlo,&data_word);
                //
            } else if ( address == layer_trg_mode_adr ) {
                //---------------------------------------------------------------------
                //0XF0 = ADR_LAYER_TRIG:  Layer-Trigger Mode
                //---------------------------------------------------------------------
                InsertValueIntoDataWord(layer_trigger_en_ ,layer_trigger_en_bithi ,layer_trigger_en_bitlo ,&data_word); 
                InsertValueIntoDataWord(layer_trig_thresh_,layer_trig_thresh_bithi,layer_trig_thresh_bitlo,&data_word); 
                InsertValueIntoDataWord(clct_throttle_    ,clct_throttle_bithi    ,clct_throttle_bitlo    ,&data_word); 
                //
            } else if ( address == pattern_find_pretrg_adr ) {
                //---------------------------------------------------------------------
                //0XF4 = ADR_TEMP0:  Pattern Finder Pretrigger
                //---------------------------------------------------------------------
                InsertValueIntoDataWord(clct_blanking_                   ,clct_blanking_bithi                   ,clct_blanking_bitlo                   ,&data_word);
                InsertValueIntoDataWord(clct_pattern_id_thresh_          ,clct_pattern_id_thresh_bithi          ,clct_pattern_id_thresh_bitlo          ,&data_word);
                InsertValueIntoDataWord(clct_pattern_id_thresh_postdrift_,clct_pattern_id_thresh_postdrift_bithi,clct_pattern_id_thresh_postdrift_bitlo,&data_word);
                InsertValueIntoDataWord(adjacent_cfeb_distance_          ,adjacent_cfeb_distance_bithi          ,adjacent_cfeb_distance_bitlo          ,&data_word);
                //
            } else if ( address == clct_separation_adr ) {
                //---------------------------------------------------------------------
                //0XF6 = ADR_TEMP1:  CLCT separation
                //---------------------------------------------------------------------
                InsertValueIntoDataWord(clct_separation_src_             ,clct_separation_src_bithi             ,clct_separation_src_bitlo             ,&data_word);
                InsertValueIntoDataWord(clct_separation_ram_write_enable_,clct_separation_ram_write_enable_bithi,clct_separation_ram_write_enable_bitlo,&data_word);
                InsertValueIntoDataWord(clct_separation_ram_adr_         ,clct_separation_ram_adr_bithi         ,clct_separation_ram_adr_bitlo         ,&data_word);
                InsertValueIntoDataWord(min_clct_separation_             ,min_clct_separation_bithi             ,min_clct_separation_bitlo             ,&data_word);
                //
            } else if ( address == l1a_lookback_adr ) {    
                //---------------------------------------------------------------------
                //0X100 = ADR_L1A_LOOKBACK:  L1A Lookback Distance
                //---------------------------------------------------------------------
                InsertValueIntoDataWord(l1a_allow_notmb_lookback_,l1a_allow_notmb_lookback_bithi,l1a_allow_notmb_lookback_bitlo,&data_word);
                InsertValueIntoDataWord(inj_wrdata_msb_          ,inj_wrdata_msb_bithi          ,inj_wrdata_msb_bitlo          ,&data_word);
                InsertValueIntoDataWord(l1a_priority_enable_     ,l1a_priority_enable_bithi     ,l1a_priority_enable_bitlo     ,&data_word);
                //
            } else if ( address == alct_sync_ctrl_adr ) {    
                //---------------------------------------------------------------------
                //0X104 = ADR_ALCT_SYNC_CTRL:  ALCT Sync Mode Control
                //---------------------------------------------------------------------
                InsertValueIntoDataWord(alct_sync_rxdata_dly_  ,alct_sync_rxdata_dly_bithi  ,alct_sync_rxdata_dly_bitlo  ,&data_word);
                InsertValueIntoDataWord(alct_sync_tx_random_   ,alct_sync_tx_random_bithi   ,alct_sync_tx_random_bitlo   ,&data_word);
                InsertValueIntoDataWord(alct_sync_clear_errors_,alct_sync_clear_errors_bithi,alct_sync_clear_errors_bitlo,&data_word);
                //
            } else if ( address == alct_sync_txdata_1st_adr ) {    
                //---------------------------------------------------------------------
                //0X106 = ADR_ALCT_SYNC_TXDATA_1ST:  ALCT Sync Mode Transmit Data 1st
                //---------------------------------------------------------------------
                InsertValueIntoDataWord(alct_sync_txdata_1st_,alct_sync_txdata_1st_bithi,alct_sync_txdata_1st_bitlo,&data_word);
                //
            } else if ( address == alct_sync_txdata_2nd_adr ) {    
                //---------------------------------------------------------------------
                //0X108 = ADR_ALCT_SYNC_TXDATA_2ND:  ALCT Sync Mode Transmit Data 2nd
                //---------------------------------------------------------------------
                InsertValueIntoDataWord(alct_sync_txdata_2nd_,alct_sync_txdata_2nd_bithi,alct_sync_txdata_2nd_bitlo,&data_word);
                //
            } else if ( address == miniscope_adr ) {
                //---------------------------------------------------------------------
                //0X10C = ADR_MINISCOPE:  Internal 16 Channel Digital Scope
                //---------------------------------------------------------------------
                InsertValueIntoDataWord(miniscope_enable_ ,miniscope_enable_bithi ,miniscope_enable_bitlo ,&data_word);
                InsertValueIntoDataWord(mini_tbins_test_  ,mini_tbins_test_bithi  ,mini_tbins_test_bitlo  ,&data_word);
                InsertValueIntoDataWord(mini_tbins_word_  ,mini_tbins_word_bithi  ,mini_tbins_word_bitlo  ,&data_word);
                InsertValueIntoDataWord(fifo_tbins_mini_  ,fifo_tbins_mini_bithi  ,fifo_tbins_mini_bitlo  ,&data_word);
                InsertValueIntoDataWord(fifo_pretrig_mini_,fifo_pretrig_mini_bithi,fifo_pretrig_mini_bitlo,&data_word);
                //
            } else if ( address == phaser_alct_rxd_adr ) {
                //---------------------------------------------------------------------
                //0X10E = ADR_PHASER0: digital phase shifter for alct_rx
                //---------------------------------------------------------------------
                data_word = ConvertDigitalPhaseToVMERegisterValues_(alct_rx_clock_delay_,alct_rx_posneg_);
                //
            } else if ( address == phaser_alct_txd_adr ) {
                //---------------------------------------------------------------------
                //0X110 = ADR_PHASER1: digital phase shifter for alct_tx
                //---------------------------------------------------------------------
                data_word = ConvertDigitalPhaseToVMERegisterValues_(alct_tx_clock_delay_,alct_tx_posneg_);
                //
            } else if ( address == phaser_cfeb0_rxd_adr ) { 
                //---------------------------------------------------------------------
                //0X112 = ADR_PHASER2: digital phase shifter for cfeb0
                //---------------------------------------------------------------------
                data_word = ConvertDigitalPhaseToVMERegisterValues_(cfeb0_rx_clock_delay_,cfeb0_rx_posneg_);
                //
            } else if ( address == phaser_cfeb1_rxd_adr ) { 
                //---------------------------------------------------------------------
                //0X114 = ADR_PHASER3: digital phase shifter for cfeb1
                //---------------------------------------------------------------------
                data_word = ConvertDigitalPhaseToVMERegisterValues_(cfeb1_rx_clock_delay_,cfeb1_rx_posneg_);
                //
            } else if ( address == phaser_cfeb2_rxd_adr ) { 
                //---------------------------------------------------------------------
                //0X116 = ADR_PHASER4: digital phase shifter for cfeb2
                //---------------------------------------------------------------------
                data_word = ConvertDigitalPhaseToVMERegisterValues_(cfeb2_rx_clock_delay_,cfeb2_rx_posneg_);
                //
            } else if ( address == phaser_cfeb3_rxd_adr ) { 
                //---------------------------------------------------------------------
                //0X118 = ADR_PHASER5: digital phase shifter for cfeb3
                //---------------------------------------------------------------------
                data_word = ConvertDigitalPhaseToVMERegisterValues_(cfeb3_rx_clock_delay_,cfeb3_rx_posneg_);
                //
            } else if ( address == phaser_cfeb4_rxd_adr ) { 
                //---------------------------------------------------------------------
                //0X11A = ADR_PHASER6: digital phase shifter for cfeb4
                //---------------------------------------------------------------------
                data_word = ConvertDigitalPhaseToVMERegisterValues_(cfeb4_rx_clock_delay_,cfeb4_rx_posneg_);
                //
            } else if ( address == cfeb0_3_interstage_adr ) {    
                //---------------------------------------------------------------------
                // 0X11C = ADR_DELAY0_INT:  CFEB to TMB "interstage" delays
                //---------------------------------------------------------------------
                InsertValueIntoDataWord(cfeb0_rxd_int_delay_,cfeb0_rxd_int_delay_bithi,cfeb0_rxd_int_delay_bitlo,&data_word);
                InsertValueIntoDataWord(cfeb1_rxd_int_delay_,cfeb1_rxd_int_delay_bithi,cfeb1_rxd_int_delay_bitlo,&data_word);
                InsertValueIntoDataWord(cfeb2_rxd_int_delay_,cfeb2_rxd_int_delay_bithi,cfeb2_rxd_int_delay_bitlo,&data_word);
                InsertValueIntoDataWord(cfeb3_rxd_int_delay_,cfeb3_rxd_int_delay_bithi,cfeb3_rxd_int_delay_bitlo,&data_word);
                //
            } else if ( address == cfeb4_interstage_adr ) {    
                //---------------------------------------------------------------------
                // 0X11E = ADR_DELAY1_INT:  CFEB to TMB "interstage" delays
                //---------------------------------------------------------------------
                InsertValueIntoDataWord(cfeb4_rxd_int_delay_,cfeb4_rxd_int_delay_bithi,cfeb4_rxd_int_delay_bitlo,&data_word);
                //
            } else if ( address == sync_err_control_adr ) {
                //---------------------------------------------------------------------
                // 0X120 = ADR_SYNC_ERR_CTRL:  Synchronization Error Control
                //---------------------------------------------------------------------
                InsertValueIntoDataWord(sync_err_reset_                 ,sync_err_reset_bithi                 ,sync_err_reset_bitlo                 ,&data_word);
                InsertValueIntoDataWord(clct_bx0_sync_err_enable_       ,clct_bx0_sync_err_enable_bithi       ,clct_bx0_sync_err_enable_bitlo       ,&data_word);
                InsertValueIntoDataWord(alct_ecc_rx_sync_err_enable_    ,alct_ecc_rx_sync_err_enable_bithi    ,alct_ecc_rx_sync_err_enable_bitlo    ,&data_word);
                InsertValueIntoDataWord(alct_ecc_tx_sync_err_enable_    ,alct_ecc_tx_sync_err_enable_bithi    ,alct_ecc_tx_sync_err_enable_bitlo    ,&data_word);
                InsertValueIntoDataWord(bx0_match_sync_err_enable_      ,bx0_match_sync_err_enable_bithi      ,bx0_match_sync_err_enable_bitlo      ,&data_word);
                InsertValueIntoDataWord(clock_lock_lost_sync_err_enable_,clock_lock_lost_sync_err_enable_bithi,clock_lock_lost_sync_err_enable_bitlo,&data_word);
                InsertValueIntoDataWord(sync_err_blanks_mpc_enable_     ,sync_err_blanks_mpc_enable_bithi     ,sync_err_blanks_mpc_enable_bitlo     ,&data_word);
                InsertValueIntoDataWord(sync_err_stops_pretrig_enable_  ,sync_err_stops_pretrig_enable_bithi  ,sync_err_stops_pretrig_enable_bitlo  ,&data_word);
                InsertValueIntoDataWord(sync_err_stops_readout_enable_  ,sync_err_stops_readout_enable_bithi  ,sync_err_stops_readout_enable_bitlo  ,&data_word);
                //
            } else if ( address == cfeb_badbits_ctrl_adr ) {
                //---------------------------------------------------------------------
                // 0X122 = ADR_CFEB_BADBITS_CTRL:  CFEB badbits control/status
                //---------------------------------------------------------------------
                InsertValueIntoDataWord(cfeb_badbits_reset_  ,cfeb_badbits_reset_bithi  ,cfeb_badbits_reset_bitlo  ,&data_word);
                InsertValueIntoDataWord(cfeb_badbits_block_  ,cfeb_badbits_block_bithi  ,cfeb_badbits_block_bitlo  ,&data_word);
                //
            } else if ( address == cfeb_badbits_timer_adr ) {
                //---------------------------------------------------------------------
                // 0X124 = ADR_CFEB_BADBITS_TIMER:  CFEB badbits check interval
                //---------------------------------------------------------------------
                InsertValueIntoDataWord(cfeb_badbits_nbx_,cfeb_badbits_nbx_bithi,cfeb_badbits_nbx_bitlo,&data_word);
                //
            } else {
                //
                (*MyOutput_) << "TMB: ERROR in FillTMBRegister, VME address = " << address << " not supported to be filled" << std::endl;
                data_word = 0xf0000;  //make data word too big to fit in TMB register
                //
            }
            //
            return data_word;
        }
        //
        int TMB::ConvertDigitalPhaseToVMERegisterValues_(int digital_phase,int posneg) {
            //
            int data_word = 0;
            //
            float float_number_of_available_bins_per_clock_cycle = (float) number_of_available_bins_per_clock_cycle;
            //
            float float_maximum_number_of_phase_delay_values = (float) maximum_number_of_phase_delay_values;
            //
            float float_phase_to_write = ( (float) digital_phase * ( float_number_of_available_bins_per_clock_cycle / float_maximum_number_of_phase_delay_values ) + 0.5);
            int phase_to_write         = ( (int) float_phase_to_write ) & 0xff;
            //
            int phase_value_within_quadrant   = phase_to_write & 0x3f;
            int quarter_cycle_quadrant_select = (phase_to_write >> 6) & 0x1;
            int half_cycle_quadrant_select    = (phase_to_write >> 7) & 0x1;
            //
            InsertValueIntoDataWord(fire_phaser_                 ,fire_phaser_bithi                  ,fire_phaser_bitlo                  ,&data_word);
            InsertValueIntoDataWord(reset_phase_                 ,reset_phase_bithi                  ,reset_phase_bitlo                  ,&data_word);
            InsertValueIntoDataWord(posneg                       ,phaser_posneg_bithi                ,phaser_posneg_bitlo                ,&data_word);
            InsertValueIntoDataWord(phase_value_within_quadrant  ,phase_value_within_quadrant_bithi  ,phase_value_within_quadrant_bitlo  ,&data_word); 
            InsertValueIntoDataWord(quarter_cycle_quadrant_select,quarter_cycle_quadrant_select_bithi,quarter_cycle_quadrant_select_bitlo,&data_word); 
            InsertValueIntoDataWord(half_cycle_quadrant_select   ,half_cycle_quadrant_select_bithi   ,half_cycle_quadrant_select_bitlo   ,&data_word); 
            //
            return data_word;
        }
        //
        void TMB::ConvertVMERegisterValuesToDigitalPhases_(unsigned long int vme_address) {
            //
            // conversion from VME register values to digital phase value:
            int posneg = read_phaser_posneg_;
            int full_digital_phase  = 
                ( read_phase_value_within_quadrant_   & 0x3f)        | 
                ((read_quarter_cycle_quadrant_select_ &  0x1) << 6 ) |
                ((read_half_cycle_quadrant_select_    &  0x1) << 7 ) ;
            //
            float float_number_of_available_bins_per_clock_cycle = (float) number_of_available_bins_per_clock_cycle;
            //
            float float_maximum_number_of_phase_delay_values = (float) maximum_number_of_phase_delay_values;
            //
            float float_read_digital_phase = ( (float) full_digital_phase * 
                    ( float_maximum_number_of_phase_delay_values / float_number_of_available_bins_per_clock_cycle  ) + 0.5);
            //
            int read_digital_phase = ( (int) float_read_digital_phase ) & 0xff;
            //
            if ( vme_address == phaser_alct_rxd_adr ) {
                //
                read_alct_rx_posneg_       = posneg       ;
                read_alct_rx_clock_delay_  = read_digital_phase;
                //
            } else if ( vme_address == phaser_alct_txd_adr ) {
                //
                read_alct_tx_posneg_       = posneg       ;
                read_alct_tx_clock_delay_  = read_digital_phase;
                //
            } else if ( vme_address == phaser_cfeb0_rxd_adr ) { 
                //
                read_cfeb0_rx_posneg_      = posneg       ;
                read_cfeb0_rx_clock_delay_ = read_digital_phase;
                //
            } else if ( vme_address == phaser_cfeb1_rxd_adr ) { 
                //
                read_cfeb1_rx_posneg_      = posneg       ;
                read_cfeb1_rx_clock_delay_ = read_digital_phase;
                //
            } else if ( vme_address == phaser_cfeb2_rxd_adr ) { 
                //
                read_cfeb2_rx_posneg_      = posneg       ;
                read_cfeb2_rx_clock_delay_ = read_digital_phase;
                //
            } else if ( vme_address == phaser_cfeb3_rxd_adr ) { 
                //
                read_cfeb3_rx_posneg_      = posneg       ;
                read_cfeb3_rx_clock_delay_ = read_digital_phase;
                //
            } else if ( vme_address == phaser_cfeb4_rxd_adr ) { 
                //
                read_cfeb4_rx_posneg_      = posneg       ;
                read_cfeb4_rx_clock_delay_ = read_digital_phase;
                //
            }
            //
            return;
        }
        void TMB::FirePhaser(long unsigned int vme_address) {
            //
            // The values for the phaser have been set already.  Fire the state machine in the FPGA to
            // set the values properly...
            //
            // make sure the phaser state machine is in unstarted state:
            fire_phaser_ = 0;
            WriteRegister(vme_address);
            //
            // start the phaser state machine:
            fire_phaser_ = 1;
            WriteRegister(vme_address);
            //
            // unstart the phaser state machine:
            fire_phaser_ = 0;
            WriteRegister(vme_address);
            //
            ReadRegister(vme_address);
            //
            const int max_number_of_reads = 1000;
            int number_of_reads = 1;
            //
            while (read_phaser_busy_ == 1 && number_of_reads < max_number_of_reads) {
                ReadRegister(vme_address);
                number_of_reads++;
            }
            //
            if (debug_) 
                std::cout << "number of phaser reads while busy = " << number_of_reads << std::endl;
            //
            if (number_of_reads >= max_number_of_reads) 
                std::cout << "Writing to phaser FAILED, number of reads = " << number_of_reads << std::endl;
            //
            return;
        }
        //
        ////////////////////////////////////////////////////////////////////////////////////////
        // Check read values versus expected values 
        ////////////////////////////////////////////////////////////////////////////////////////
        void TMB::CheckTMBConfiguration() {
            //
            // Default number of times to read the configuration values:
            this->CheckTMBConfiguration(2); 
            //
            return;
        }
        //
        void TMB::CheckTMBConfiguration(int max_number_of_reads) {
            //
            // Read the configuration values up to a maximum number of times in order to prevent
            // false failures which are simply bad VME reads.
            //
            bool config_ok = false;
            //
            number_of_configuration_reads_ = 0;
            //
            while (!config_ok && number_of_configuration_reads_ < max_number_of_reads) {
                //
                number_of_configuration_reads_++;
                //
                bool print_errors;
                //
                if (number_of_configuration_reads_ == (max_number_of_reads-1) ) {
                    print_errors = true;
                    //
                } else {
                    print_errors = false;
                    //
                }
                //
                config_ok = true;
                //
                ReadTMBConfiguration();    // fill the read values in the software
                //
                // Check if user has forced CFEB enable bits in register 0x68 to be copied from 0x42
                // If yes => expected value of address 0x68 = write value of address 0x42 
                // If no  => expected value of address 0x68 = write value of address 0x68 
                //
                int cfebs_enabled_expected;
                //
                if (GetCfebEnableSource() == 1) {
                    cfebs_enabled_expected = enableCLCTInputs_;
                } else {
                    cfebs_enabled_expected = cfebs_enabled_; 
                }
                //
                //-----------------------------------------------------------------
                // firmware information
                //-----------------------------------------------------------------
                config_ok &= compareValues("TMB tmb_firmware_month"  ,GetReadTmbFirmwareMonth()  ,GetExpectedTmbFirmwareMonth()  , print_errors);
                config_ok &= compareValues("TMB tmb_firmware_day"    ,GetReadTmbFirmwareDay()    ,GetExpectedTmbFirmwareDay()    , print_errors);
                config_ok &= compareValues("TMB tmb_firmware_year"   ,GetReadTmbFirmwareYear()   ,GetExpectedTmbFirmwareYear()   , print_errors);
                config_ok &= compareValues("TMB tmb_firmware_version",GetReadTmbFirmwareVersion(),GetExpectedTmbFirmwareVersion(), print_errors);
                config_ok &= compareValues("TMB tmb_firmware_revcode",GetReadTmbFirmwareRevcode(),GetExpectedTmbFirmwareRevcode(), print_errors);
                config_ok &= compareValues("TMB tmb_firmware_type"   ,GetReadTmbFirmwareType()   ,GetExpectedTmbFirmwareType()   , print_errors);
                //
                //-----------------------------------------------------------------
                //0X70000 = ADR_BOOT:  Hardware Bootstrap Register
                //-----------------------------------------------------------------
                config_ok &= compareValues("TMB Boot register control JTAG chain (not in xml)",
                        read_boot_control_jtag_chain_,
                        boot_control_jtag_chain_expected, 
                        print_errors);
                //
                //-----------------------------------------------------------------
                //0X0E = ADR_LOOPBK:  Loop-Back Control Register
                //-----------------------------------------------------------------
                config_ok &= compareValues("TMB enable_alct_tx",read_enable_alct_tx_,enable_alct_tx_, print_errors);
                config_ok &= compareValues("TMB enable_alct_rx",read_enable_alct_rx_,enable_alct_rx_, print_errors);
                //
                //------------------------------------------------------------------
                //0X16 = ADR_DDD0:  3D3444 Chip 0 Delays, 1 step = 2ns
                //-----------------------------------------------------------------
                config_ok &= compareValues("TMB alct_tof_delay"     ,read_alct_tof_delay_     ,alct_tof_delay_     , print_errors);
                config_ok &= compareValues("TMB dmb_tx_delay"       ,read_dmb_tx_delay_       ,dmb_tx_delay_       , print_errors);
                config_ok &= compareValues("TMB rat_tmb_delay"      ,read_rat_tmb_delay_      ,rat_tmb_delay_      , print_errors);
                //
                //------------------------------------------------------------------
                //0X18 = ADR_DDD1:  3D3444 Chip 1 Delays, 1 step = 2ns
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB TMB1 phase (not in xml)",read_tmb1_phase_         ,tmb1_phase_         , print_errors);
                config_ok &= compareValues("TMB cfeb_tof_delay"         ,read_cfeb_tof_delay_     ,cfeb_tof_delay_     , print_errors);
                config_ok &= compareValues("TMB cfeb0_tof_delay"        ,read_cfeb0_tof_delay_    ,cfeb0_tof_delay_    , print_errors);
                //
                //------------------------------------------------------------------
                //0X1A = ADR_DDD2:  3D3444 Chip 2 Delays, 1 step = 2ns
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB cfeb1_tof_delay",read_cfeb1_tof_delay_,cfeb1_tof_delay_, print_errors);
                config_ok &= compareValues("TMB cfeb2_tof_delay",read_cfeb2_tof_delay_,cfeb2_tof_delay_, print_errors);
                config_ok &= compareValues("TMB cfeb3_tof_delay",read_cfeb3_tof_delay_,cfeb3_tof_delay_, print_errors);
                config_ok &= compareValues("TMB cfeb4_tof_delay",read_cfeb4_tof_delay_,cfeb4_tof_delay_, print_errors);
                //
                //------------------------------------------------------------------
                //0X1E = ADR_RATCTRL:  RAT Module Control
                //------------------------------------------------------------------
                //  config_ok &= compareValues("TMB Shift RPC 1/2 phase"             ,read_shift_rpc_ ,shift_rpc_ , print_errors);
                //  config_ok &= compareValues("TMB RPC sync"                        ,read_rpc_sync_  ,rpc_sync_  , print_errors);
                //  config_ok &= compareValues("TMB RAT digital serial number enable",read_rat_dsn_en_,rat_dsn_en_, print_errors);
                //
                //------------------------------------------------------------------
                //0X2C = ADR_CCB_TRIG:  CCB Trigger Control
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB Request CCB L1a on ALCT ext trig (not in xml)"     ,read_alct_ext_trig_l1aen_   ,alct_ext_trig_l1aen_   , print_errors);
                config_ok &= compareValues("TMB Request CCB L1a on CLCT ext trig (not in xml)"     ,read_clct_ext_trig_l1aen_   ,clct_ext_trig_l1aen_   , print_errors);
                config_ok &= compareValues("TMB request_l1a"                                       ,read_request_l1a_           ,request_l1a_           , print_errors);
                config_ok &= compareValues("TMB Fire ALCT ext trig one-shot (not in xml)"          ,read_alct_ext_trig_vme_     ,alct_ext_trig_vme_     , print_errors);
                config_ok &= compareValues("TMB Fire CLCT ext trig one-shot (not in xml)"          ,read_clct_ext_trig_vme_     ,clct_ext_trig_vme_     , print_errors);
                config_ok &= compareValues("TMB CLCText fire ALCT + ALCText fire CLCT (not in xml)",read_ext_trig_both_         ,ext_trig_both_         , print_errors);
                config_ok &= compareValues("TMB allow CLCTextCCB when ccb_ignore_rx=1 (not in xml)",read_ccb_allow_bypass_      ,ccb_allow_bypass_      , print_errors);
                config_ok &= compareValues("TMB ignore_ccb_startstop"                              ,read_ignore_ccb_startstop_  ,ignore_ccb_startstop_  , print_errors);
                config_ok &= compareValues("TMB Internal L1A delay (not in xml)"                   ,read_internal_l1a_delay_vme_,internal_l1a_delay_vme_, print_errors);
                //
                //------------------------------------------------------------------
                //0X30 = ADR_ALCT_CFG:  ALCT Configuration
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB Enable alct_ext_trig from CCB (not in xml)"           ,read_cfg_alct_ext_trig_en_  ,cfg_alct_ext_trig_en_  , print_errors);
                config_ok &= compareValues("TMB Enable alct_ext_inject from CCB (not in xml)"         ,read_cfg_alct_ext_inject_en_,cfg_alct_ext_inject_en_, print_errors);
                config_ok &= compareValues("TMB Assert alct_ext_trig (not in xml)"                    ,read_cfg_alct_ext_trig_     ,cfg_alct_ext_trig_     , print_errors); 
                config_ok &= compareValues("TMB Assert alct_ext_inject (not in xml)"	            ,read_cfg_alct_ext_inject_ ,cfg_alct_ext_inject_   , print_errors);
                config_ok &= compareValues("TMB ALCT sequencer command (not in xml)" 	            ,read_alct_seq_cmd_        ,alct_seq_cmd_          , print_errors);
                config_ok &= compareValues("TMB alct_clock_en_use_ccb"                                ,read_alct_clock_en_use_ccb_ ,alct_clock_en_use_ccb_ , print_errors);
                config_ok &= compareValues("TMB set alct_clock_en scsi signal if above=0 (not in xml)",read_alct_clock_en_use_vme_ ,alct_clock_en_use_vme_ , print_errors);
                //
                //------------------------------------------------------------------
                //0X32 = ADR_ALCT_INJ:  ALCT Injector Control
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB alct_clear"                                    ,read_alct_clear_     ,alct_clear_     , print_errors);
                config_ok &= compareValues("TMB start ALCT injector state machine (not in xml)",read_alct_inject_mux_,alct_inject_mux_, print_errors);
                config_ok &= compareValues("TMB sync ALCT injector with CLCT (not in xml)"     ,read_alct_sync_clct_ ,alct_sync_clct_ , print_errors);
                config_ok &= compareValues("TMB ALCT injector delay (not in xml)"              ,read_alct_inj_delay_ ,alct_inj_delay_ , print_errors);
                //
                //------------------------------------------------------------------
                //0X38 = ADR_ALCT_STAT:  ALCT Sequencer Control/Status
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB alct_ecc_enable (not in xml)"     ,read_alct_ecc_en_       ,alct_ecc_en_       , print_errors);
                config_ok &= compareValues("TMB alct_ecc_error_blank (not in xml)",read_alct_ecc_err_blank_,alct_ecc_err_blank_, print_errors);
                config_ok &= compareValues("TMB tmb_to_alct_data_delay"           ,read_alct_txdata_delay_ ,alct_txdata_delay_ , print_errors);
                //
                //------------------------------------------------------------------
                //0X42 = ADR_CFEB_INJ:  CFEB Injector Control
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB enableCLCTInputs_reg42"                         ,read_enableCLCTInputs_ ,enableCLCTInputs_ , print_errors);
                config_ok &= compareValues("TMB Select CFEB n for RAM read/write (not in xml)"  ,read_cfeb_ram_sel_     ,cfeb_ram_sel_     , print_errors);
                config_ok &= compareValues("TMB Enable CFEB n for injector trigger (not in xml)",read_cfeb_inj_en_sel_  ,cfeb_inj_en_sel_  , print_errors); 
                config_ok &= compareValues("TMB Start CLCT pattern injector (not in xml)"       ,read_start_pattern_inj_,start_pattern_inj_, print_errors);
                //
                //------------------------------------------------------------------
                //0X4A,4C,4E = ADR_HCM001,HCM023,HCM045 = CFEB0 Hot Channel Masks
                //0X50,52,54 = ADR_HCM101,HCM123,HCM145 = CFEB1 Hot Channel Masks
                //0X56,58,5A = ADR_HCM201,HCM223,HCM245 = CFEB2 Hot Channel Masks
                //0X5C,5E,60 = ADR_HCM301,HCM323,HCM345 = CFEB3 Hot Channel Masks
                //0X62,64,66 = ADR_HCM401,HCM423,HCM445 = CFEB4 Hot Channel Masks
                //------------------------------------------------------------------
                for (int layer=0; layer<MAX_NUM_LAYERS; layer++) {
                    for (int distrip=0; distrip<MAX_NUM_DISTRIPS_PER_LAYER; distrip++) {
                        std::ostringstream hotmasklabel;
                        hotmasklabel << "TMB layer" << layer << "_distrip_hot_chann_mask" << distrip; 
                        config_ok &= compareValues(hotmasklabel.str(),
                                read_hot_channel_mask_[layer][distrip],
                                hot_channel_mask_[layer][distrip], 
                                print_errors);
                    }
                }
                //
                //------------------------------------------------------------------
                //0X68 = ADR_SEQ_TRIG_EN:  Sequencer Trigger Source Enables
                //N.B. See TMB documentation first before controlling CFEBs through this register...
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB clct_pretrig_enable"                                  ,read_clct_pat_trig_en_  ,clct_pat_trig_en_     , print_errors);
                config_ok &= compareValues("TMB alct_pretrig_enable"                                  ,read_alct_pat_trig_en_  ,alct_pat_trig_en_     , print_errors);
                config_ok &= compareValues("TMB match_pretrig_enable"                                 ,read_match_pat_trig_en_ ,match_pat_trig_en_    , print_errors);
                config_ok &= compareValues("TMB Allow ADB ext trig (CCB) for pretrigger (not in xml)" ,read_adb_ext_trig_en_   ,adb_ext_trig_en_      , print_errors);
                config_ok &= compareValues("TMB Allow DMB ext trig for pretrigger (not in xml)"       ,read_dmb_ext_trig_en_   ,dmb_ext_trig_en_      , print_errors);
                config_ok &= compareValues("TMB clct_ext_pretrig_enable"                              ,read_clct_ext_trig_en_  ,clct_ext_trig_en_     , print_errors);
                config_ok &= compareValues("TMB Allow ALCT ext trig (CCB) for pretrigger (not in xml)",read_alct_ext_trig_en_  ,alct_ext_trig_en_     , print_errors);
                config_ok &= compareValues("TMB Initiate sequencer trigger from VME (not in xml)"     ,read_vme_ext_trig_      ,vme_ext_trig_         , print_errors);
                config_ok &= compareValues("TMB Make clct_ext_trig fire pattern injector (not in xml)",read_ext_trig_inject_   ,ext_trig_inject_      , print_errors);
                config_ok &= compareValues("TMB all_cfeb_active"                                      ,read_all_cfeb_active_   ,all_cfeb_active_      , print_errors);
                config_ok &= compareValues("TMB enableCLCTInputs_reg68"                               ,read_cfebs_enabled_     ,cfebs_enabled_expected, print_errors);
                config_ok &= compareValues("TMB cfeb_enable_source"                                   ,read_cfeb_enable_source_,cfeb_enable_source_   , print_errors);
                //
                //------------------------------------------------------------------
                //0X6A = ADR_SEQ_TRIG_DLY0:  Sequencer Trigger Source Delays
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB match_pretrig_window_size"               ,read_alct_pretrig_width_,alct_pretrig_width_, print_errors);
                config_ok &= compareValues("TMB match_pretrig_alct_delay"                ,read_alct_pretrig_delay_,alct_pretrig_delay_, print_errors);
                config_ok &= compareValues("TMB Active FEB Flag delay (not in xml)"      ,read_alct_pattern_delay_,alct_pattern_delay_, print_errors);
                config_ok &= compareValues("TMB Delay adb_ext_trig from CCB (not in xml)",read_adb_ext_trig_delay_,adb_ext_trig_delay_, print_errors);
                //
                //------------------------------------------------------------------
                //0X6C = ADR_SEQ_TRIG_DLY1:  Sequencer Trigger Source Delays
                //------------------------------------------------------------------
                //  config_ok &= compareValues("TMB Delay dmb_ext_trig from DMB"         ,read_dmb_ext_trig_delay_  ,dmb_ext_trig_delay_ , print_errors);
                //  config_ok &= compareValues("TMB Delay clct_ext_trig (scint) from CCB",read_clct_ext_trig_delay_ ,clct_ext_trig_delay_, print_errors);
                //  config_ok &= compareValues("TMB Delay alct_ext_trig from CCB"        ,read_alct_ext_trig_delay_ ,alct_ext_trig_delay_, print_errors);
                //
                //------------------------------------------------------------------
                //0X6E = ADR_SEQ_ID:  Sequencer Board + CSC Ids
                //------------------------------------------------------------------
                //  config_ok &= compareValues("TMB TMB slot",read_tmb_slot_,tmb_slot_, print_errors);
                //  config_ok &= compareValues("TMB CSC ID"  ,read_csc_id_  ,csc_id_  , print_errors);
                //  config_ok &= compareValues("TMB Run ID"  ,read_run_id_  ,run_id_  , print_errors);
                //
                //------------------------------------------------------------------
                //0X70 = ADR_SEQ_CLCT:  Sequencer CLCT configuration
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB clct_hit_persist"                ,read_triad_persist_   ,triad_persist_   , print_errors);
                config_ok &= compareValues("TMB clct_nplanes_hit_pretrig"        ,read_hit_thresh_      ,hit_thresh_      , print_errors);
                config_ok &= compareValues("TMB aff_thresh"                      ,read_aff_thresh_      ,aff_thresh_      , print_errors);
                config_ok &= compareValues("TMB clct_nplanes_hit_pattern"        ,read_min_hits_pattern_,min_hits_pattern_, print_errors);
                config_ok &= compareValues("TMB clct_drift_delay"                ,read_drift_delay_     ,drift_delay_     , print_errors);
                config_ok &= compareValues("TMB halt and wait (not in xml)"      ,read_pretrigger_halt_ ,pretrigger_halt_ , print_errors);
                //
                //------------------------------------------------------------------
                //0X72 = ADR_SEQ_FIFO:  Sequencer FIFO configuration
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB tmb_fifo_mode"       ,read_fifo_mode_           ,fifo_mode_           , print_errors);
                config_ok &= compareValues("TMB clct_fifo_tbins"     ,read_fifo_tbins_          ,fifo_tbins_          , print_errors);
                config_ok &= compareValues("TMB clct_fifo_pretrig"   ,read_fifo_pretrig_        ,fifo_pretrig_        , print_errors);
                config_ok &= compareValues("TMB tmb_fifo_no_raw_hits",read_fifo_no_raw_hits_    ,fifo_no_raw_hits_    , print_errors);
                config_ok &= compareValues("TMB cfeb_badbits_readout",read_cfeb_badbits_readout_,cfeb_badbits_readout_, print_errors);
                //
                //------------------------------------------------------------------
                //0X74 = ADR_SEQ_L1A:  Sequencer L1A configuration
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB tmb_l1a_delay"                             ,read_l1adelay_        ,l1adelay_        , print_errors);
                config_ok &= compareValues("TMB tmb_l1a_window_size"                       ,read_l1a_window_size_ ,l1a_window_size_ , print_errors);
                config_ok &= compareValues("TMB Generate internal L1a (overrides external)",read_tmb_l1a_internal_,tmb_l1a_internal_, print_errors);
                //
                //------------------------------------------------------------------
                //0X76 = ADR_SEQ_OFFSET:  Sequencer Counter Offsets
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB tmb_l1a_offset",read_l1a_offset_,l1a_offset_, print_errors);
                config_ok &= compareValues("TMB tmb_bxn_offset",read_bxn_offset_,bxn_offset_, print_errors);
                //
                //------------------------------------------------------------------
                //0X86 = ADR_TMB_TRIG:  TMB Trigger configuration/MPC accept
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB mpc_sync_err_enable"          ,read_tmb_sync_err_enable_,tmb_sync_err_enable_, print_errors);
                config_ok &= compareValues("TMB alct_trig_enable"             ,read_tmb_allow_alct_     ,tmb_allow_alct_     , print_errors);
                config_ok &= compareValues("TMB clct_trig_enable"             ,read_tmb_allow_clct_     ,tmb_allow_clct_     , print_errors);
                config_ok &= compareValues("TMB match_trig_enable"            ,read_tmb_allow_match_    ,tmb_allow_match_    , print_errors);
                config_ok &= compareValues("TMB mpc_rx_delay"                 ,read_mpc_rx_delay_       ,mpc_rx_delay_       , print_errors);
                config_ok &= compareValues("TMB MPC gets TTC BX0 (not in xml)",read_mpc_sel_ttc_bx0_    ,mpc_sel_ttc_bx0_    , print_errors);
                config_ok &= compareValues("TMB mpc_idle_blank"               ,read_mpc_idle_blank_     ,mpc_idle_blank_     , print_errors);
                config_ok &= compareValues("TMB mpc_output_enable"            ,read_mpc_output_enable_  ,mpc_output_enable_  , print_errors);
                //
                //------------------------------------------------------------------
                //0X98 = ADR_SCP_CTRL:  Scope Control
                //------------------------------------------------------------------
                //    config_ok &= compareValues("TMB scope in readout (not in xml)",read_scope_in_readout_,scope_in_readout_, print_errors);
                //
                //------------------------------------------------------------------
                //0XAC = ADR_SEQMOD:  Sequencer Trigger Modifiers
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB Trigger seq flush state timer (not in xml)",read_clct_flush_delay_            ,clct_flush_delay_            , print_errors);
                config_ok &= compareValues("TMB write_buffer_autoclear"                    ,read_wr_buffer_autoclear_         ,wr_buffer_autoclear_         , print_errors);
                config_ok &= compareValues("TMB write_continuous_enable"                   ,read_clct_write_continuous_enable_,clct_write_continuous_enable_, print_errors);
                config_ok &= compareValues("TMB write_buffer_required"                     ,read_wrt_buf_required_            ,wrt_buf_required_            , print_errors);
                config_ok &= compareValues("TMB valid_clct_required"                       ,read_valid_clct_required_         ,valid_clct_required_         , print_errors);
                config_ok &= compareValues("TMB l1a_allow_match"                           ,read_l1a_allow_match_             ,l1a_allow_match_             , print_errors);
                config_ok &= compareValues("TMB l1a_allow_notmb"                           ,read_l1a_allow_notmb_             ,l1a_allow_notmb_             , print_errors);
                config_ok &= compareValues("TMB l1a_allow_nol1a"                           ,read_l1a_allow_nol1a_             ,l1a_allow_nol1a_             , print_errors);
                config_ok &= compareValues("TMB l1a_allow_alct_only"                       ,read_l1a_allow_alct_only_         ,l1a_allow_alct_only_         , print_errors);
                config_ok &= compareValues("TMB Clear scintillator veto (not in xml)"      ,read_scint_veto_clr_              ,scint_veto_clr_              , print_errors);
                //
                //------------------------------------------------------------------
                //0XB2 = ADR_TMBTIM:  TMB Timing for ALCT*CLCT Coincidence
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB match_trig_alct_delay" ,read_alct_vpf_delay_        ,alct_vpf_delay_        , print_errors);
                config_ok &= compareValues("TMB match_trig_window_size",read_alct_match_window_size_,alct_match_window_size_, print_errors);
                config_ok &= compareValues("TMB mpc_tx_delay"          ,read_mpc_tx_delay_          ,mpc_tx_delay_          , print_errors);
                //
                //------------------------------------------------------------------
                //0XB6 = ADR_RPC_CFG:  RPC Configuration
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB rpc_exists"                                           ,read_rpc_exists_     ,rpc_exists_     , print_errors);
                config_ok &= compareValues("TMB rpc_read_enable"                                      ,read_rpc_read_enable_,rpc_read_enable_, print_errors);
                config_ok &= compareValues("TMB rpc_bxn_offset"                                       ,read_rpc_bxn_offset_ ,rpc_bxn_offset_ , print_errors);
                config_ok &= compareValues("TMB RPC Bank address (for reading sync mode) (not in xml)",read_rpc_bank_       ,rpc_bank_       , print_errors);
                //
                //------------------------------------------------------------------
                //0XBA = ADR_RPC_RAW_DELAY:  RPC Raw Hits Data Delay
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB rpc0_raw_delay",read_rpc0_raw_delay_,rpc0_raw_delay_, print_errors);
                config_ok &= compareValues("TMB rpc1_raw_delay",read_rpc1_raw_delay_,rpc1_raw_delay_, print_errors);
                //
                //------------------------------------------------------------------
                //0XBC = ADR_RPC_INJ:  RPC Injector Control
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB rpc_mask_all"                                     ,read_rpc_mask_all_ ,rpc_mask_all_ , print_errors);
                config_ok &= compareValues("TMB Enable RAT for injector fire (not in xml)"        ,read_inj_mask_rat_ ,inj_mask_rat_ , print_errors); 
                config_ok &= compareValues("TMB Enable RPC inj RAM for injector fire (not in xml)",read_inj_mask_rpc_ ,inj_mask_rpc_ , print_errors); 
                config_ok &= compareValues("TMB CFEB/RPC injectors wait for RAT (not in xml)"     ,read_inj_delay_rat_,inj_delay_rat_, print_errors); 
                config_ok &= compareValues("TMB Enable injector RAM write (not in xml)"           ,read_rpc_inj_sel_  ,rpc_inj_sel_  , print_errors); 
                //
                //------------------------------------------------------------------
                //0XC4 = ADR_RPC_TBINS:  RPC FIFO Time Bins
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB rpc_fifo_tbins"   ,read_fifo_tbins_rpc_  ,fifo_tbins_rpc_  , print_errors);
                config_ok &= compareValues("TMB rpc_fifo_pretrig" ,read_fifo_pretrig_rpc_,fifo_pretrig_rpc_, print_errors); 
                config_ok &= compareValues("TMB rpc_fifo_decouple",read_rpc_decouple_    ,rpc_decouple_    , print_errors); 
                //
                //------------------------------------------------------------------
                //0XCA = ADR_BX0_DELAY:  BX0 to MPC delays
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB alct_bx0_delay"           ,read_alct_bx0_delay_ ,alct_bx0_delay_ , print_errors);
                config_ok &= compareValues("TMB clct_bx0_delay"           ,read_clct_bx0_delay_ ,clct_bx0_delay_ , print_errors);
                config_ok &= compareValues("TMB alct_bx0_enable"          ,read_alct_bx0_enable_,alct_bx0_enable_, print_errors);
                config_ok &= compareValues("TMB bx0_vpf_test (not in xml)",read_bx0_vpf_test_   ,bx0_vpf_test_   , print_errors);
                //
                //-----------------------------------------------------------------------------
                //0XCC = ADR_NON_TRIG_RO:  Non-Triggering Event Enables + ME1/1A(1B) reversal 
                //-----------------------------------------------------------------------------
                config_ok &= compareValues("TMB alct_readout_without_trig"   ,read_tmb_allow_alct_nontrig_readout_   ,tmb_allow_alct_nontrig_readout_    , print_errors);
                config_ok &= compareValues("TMB clct_readout_without_trig"   ,read_tmb_allow_clct_nontrig_readout_   ,tmb_allow_clct_nontrig_readout_    , print_errors);
                config_ok &= compareValues("TMB match_readout_without_trig"  ,read_tmb_allow_match_nontrig_readout_  ,tmb_allow_match_nontrig_readout_   , print_errors);
                config_ok &= compareValues("TMB mpc_block_me1a"              ,read_mpc_block_me1a_                   ,mpc_block_me1a_                    , print_errors);
                //config_ok &= compareValues("TMB counter_clct_non_me11"       ,read_clct_pretrigger_counter_non_me11_ ,clct_pretrigger_counter_non_me11_  , print_errors);
                config_ok &= compareValues("TMB csc_me11 (not in xml)"       ,read_csc_me11_                         ,csc_me11_                          , print_errors);
                config_ok &= compareValues("TMB clct_stagger (not in xml)"   ,read_clct_stagger_                     ,clct_stagger_                      , print_errors);
                config_ok &= compareValues("TMB reverse_stagger (not in xml)",read_reverse_stagger_                  ,reverse_stagger_                   , print_errors);
                config_ok &= compareValues("TMB reverse_me1a (not in xml)"   ,read_reverse_me1a_                     ,reverse_me1a_                      , print_errors);
                config_ok &= compareValues("TMB reverse_me1b (not in xml)"   ,read_reverse_me1b_                     ,reverse_me1b_                      , print_errors);
                config_ok &= compareValues("TMB tmb_firmware_compile_type"   ,read_tmb_firmware_compile_type_        ,expected_tmb_firmware_compile_type_, print_errors);
                //
                //------------------------------------------------------------------
                //0XE6 = ADR_DDDR0:  RAT 3D3444 RPC Delays, 1 step = 2ns
                //------------------------------------------------------------------
                config_ok &= compareValues("TMB rpc0_rat_delay",read_rpc0_rat_delay_,rpc0_rat_delay_, print_errors);
                config_ok &= compareValues("TMB rpc1_rat_delay",read_rpc1_rat_delay_,rpc1_rat_delay_, print_errors);
                //
                //---------------------------------------------------------------------
                //0XF0 = ADR_LAYER_TRIG:  Layer-Trigger Mode
                //---------------------------------------------------------------------
                config_ok &= compareValues("TMB layer_trig_enable",read_layer_trigger_en_ ,layer_trigger_en_ , print_errors); 
                config_ok &= compareValues("TMB layer_trig_thresh",read_layer_trig_thresh_,layer_trig_thresh_, print_errors); 
                config_ok &= compareValues("TMB clct_throttle"    ,read_clct_throttle_    ,clct_throttle_    , print_errors); 
                //
                //---------------------------------------------------------------------
                //0XF4 = ADR_TEMP0:  Pattern Finder Pretrigger
                //---------------------------------------------------------------------
                config_ok &= compareValues("TMB clct_blanking"          ,read_clct_blanking_                   ,clct_blanking_                   , print_errors);
                config_ok &= compareValues("TMB clct_pid_thresh_pretrig",read_clct_pattern_id_thresh_          ,clct_pattern_id_thresh_          , print_errors);
                config_ok &= compareValues("TMB clct_pid_thresh_pattern",read_clct_pattern_id_thresh_postdrift_,clct_pattern_id_thresh_postdrift_, print_errors);
                config_ok &= compareValues("TMB adjacent_cfeb_distance" ,read_adjacent_cfeb_distance_          ,adjacent_cfeb_distance_          , print_errors);
                //
                //---------------------------------------------------------------------
                //0XF6 = ADR_TEMP1:  CLCT separation
                //---------------------------------------------------------------------
                config_ok &= compareValues("TMB CLCT separation source is VME (not in xml)",read_clct_separation_src_,clct_separation_src_, print_errors);
                config_ok &= compareValues("TMB clct_min_separation"                       ,read_min_clct_separation_,min_clct_separation_, print_errors);
                //
                //---------------------------------------------------------------------
                //0X100 = ADR_L1A_LOOKBACK:  L1A Lookback Distance
                //---------------------------------------------------------------------
                config_ok &= compareValues("TMB Lookback distance for non-TMB readout (not in xml)",read_l1a_allow_notmb_lookback_,l1a_allow_notmb_lookback_, print_errors);
                config_ok &= compareValues("TMB l1a_priority_enable"                               ,read_l1a_priority_enable_     ,l1a_priority_enable_     , print_errors);
                //
                //---------------------------------------------------------------------
                //0X10C = ADR_MINISCOPE:  Internal 16 Channel Digital Scope
                //---------------------------------------------------------------------
                config_ok &= compareValues ("TMB miniscope_enable",read_miniscope_enable_ ,miniscope_enable_ , print_errors);
                config_ok &= compareValues ("TMB mini_tbins_test (not in xml)"  ,read_mini_tbins_test_  ,mini_tbins_test_  , print_errors);
                config_ok &= compareValues ("TMB mini_tbins_word (not in xml)"  ,read_mini_tbins_word_  ,mini_tbins_word_  , print_errors);
                config_ok &= compareValues ("TMB fifo_tbins_mini (not in xml)"  ,read_fifo_tbins_mini_  ,fifo_tbins_mini_  , print_errors);
                config_ok &= compareValues ("TMB fifo_pretrig_mini (not in xml)",read_fifo_pretrig_mini_,fifo_pretrig_mini_, print_errors);
                //
                //--------------------------------------------------------------
                //[0X10E] = ADR_PHASER0:  ALCT -> TMB communication
                //--------------------------------------------------------------
                config_ok &= compareValues("TMB alct_rx_clock_delay",read_alct_rx_clock_delay_,alct_rx_clock_delay_, print_errors);
                // the lack of "rx" in the following label is legacy from the need for persistence of parameter names in the database 
                config_ok &= compareValues("TMB alct_posneg"     ,read_alct_rx_posneg_     ,alct_rx_posneg_     , print_errors);
                //
                //--------------------------------------------------------------
                //[0X110] = ADR_PHASER1:  TMB -> ALCT communication
                //--------------------------------------------------------------
                config_ok &= compareValues("TMB alct_tx_clock_delay",read_alct_tx_clock_delay_,alct_tx_clock_delay_, print_errors);
                config_ok &= compareValues("TMB alct_tx_posneg"     ,read_alct_tx_posneg_     ,alct_tx_posneg_     , print_errors); 
                //
                //--------------------------------------------------------------
                //[0X112] = ADR_PHASER2:  CFEB0 -> TMB communication
                //--------------------------------------------------------------
                // the lack of "rx" in the following label is legacy from the need for persistence of parameter names in the database 
                config_ok &= compareValues("TMB cfeb0delay"     ,read_cfeb0_rx_clock_delay_,cfeb0_rx_clock_delay_, print_errors);
                config_ok &= compareValues("TMB cfeb0_rx_posneg",read_cfeb0_rx_posneg_     ,cfeb0_rx_posneg_     , print_errors);
                //
                //--------------------------------------------------------------
                //[0X114] = ADR_PHASER3:  CFEB1 -> TMB communication
                //--------------------------------------------------------------
                // the lack of "rx" in the following label is legacy from the need for persistence of parameter names in the database 
                config_ok &= compareValues("TMB cfeb1delay"     ,read_cfeb1_rx_clock_delay_,cfeb1_rx_clock_delay_, print_errors);
                config_ok &= compareValues("TMB cfeb1_rx_posneg",read_cfeb1_rx_posneg_     ,cfeb1_rx_posneg_     , print_errors);
                //
                //--------------------------------------------------------------
                //[0X116] = ADR_PHASER4:  CFEB2 -> TMB communication
                //--------------------------------------------------------------
                // the lack of "rx" in the following label is legacy from the need for persistence of parameter names in the database 
                config_ok &= compareValues("TMB cfeb2delay"     ,read_cfeb2_rx_clock_delay_,cfeb2_rx_clock_delay_, print_errors);
                config_ok &= compareValues("TMB cfeb2_rx_posneg",read_cfeb2_rx_posneg_     ,cfeb2_rx_posneg_     , print_errors);
                //
                //--------------------------------------------------------------
                //[0X118] = ADR_PHASER5:  CFEB3 -> TMB communication
                //--------------------------------------------------------------
                // the lack of "rx" in the following label is legacy from the need for persistence of parameter names in the database 
                config_ok &= compareValues("TMB cfeb3delay"     ,read_cfeb3_rx_clock_delay_,cfeb3_rx_clock_delay_, print_errors);
                config_ok &= compareValues("TMB cfeb3_rx_posneg",read_cfeb3_rx_posneg_     ,cfeb3_rx_posneg_     , print_errors);
                //
                //--------------------------------------------------------------
                //[0X11A] = ADR_PHASER6:  CFEB4 -> TMB communication
                //--------------------------------------------------------------
                // the lack of "rx" in the following label is legacy from the need for persistence of parameter names in the database 
                config_ok &= compareValues("TMB cfeb4delay"     ,read_cfeb4_rx_clock_delay_,cfeb4_rx_clock_delay_, print_errors);
                config_ok &= compareValues("TMB cfeb4_rx_posneg",read_cfeb4_rx_posneg_     ,cfeb4_rx_posneg_     , print_errors);
                //
                //--------------------------------------------------------------
                // 0X11C = ADR_DELAY0_INT:  CFEB to TMB "interstage" delays
                //--------------------------------------------------------------
                config_ok &= compareValues("TMB cfeb0_rxd_int_delay",read_cfeb0_rxd_int_delay_,cfeb0_rxd_int_delay_, print_errors);
                config_ok &= compareValues("TMB cfeb1_rxd_int_delay",read_cfeb1_rxd_int_delay_,cfeb1_rxd_int_delay_, print_errors);
                config_ok &= compareValues("TMB cfeb2_rxd_int_delay",read_cfeb2_rxd_int_delay_,cfeb2_rxd_int_delay_, print_errors);
                config_ok &= compareValues("TMB cfeb3_rxd_int_delay",read_cfeb3_rxd_int_delay_,cfeb3_rxd_int_delay_, print_errors);
                //
                //--------------------------------------------------------------
                // 0X11E = ADR_DELAY1_INT:  CFEB to TMB "interstage" delays
                //--------------------------------------------------------------
                config_ok &= compareValues("TMB cfeb4_rxd_int_delay",read_cfeb4_rxd_int_delay_,cfeb4_rxd_int_delay_, print_errors);
                //
                //---------------------------------------------------------------------
                // 0X122 = ADR_CFEB_BADBITS_CTRL:  CFEB badbits control/status
                //---------------------------------------------------------------------
                // Here check only the bit (ANDed between all five CFEB bits...)
                config_ok &= compareValues("TMB cfeb_badbits_block",GetReadCFEBBadBitsBlock(),GetCFEBBadBitsBlock(),print_errors); 
                //
            }
            //
            tmb_configuration_status_ = (int) config_ok;
            //
            //  ReportCheck("TMB configuration check",config_ok);
            //
            return;
        }
        //
        void TMB::CheckRawHitsHeader() {
            //
            bool config_ok = true;
            //
            ReadRawHitsHeader();
            //
            config_ok &= compareValues("TMB Raw hits header:board status OK"                ,read_bdstatus_ok_    ,bdstatus_ok_expected    );
            config_ok &= compareValues("TMB Raw hits header:5.0V critical OK"               ,read_vstat_5p0v_     ,vstat_5p0v_expected     );
            config_ok &= compareValues("TMB Raw hits header:3.3V critical OK"               ,read_vstat_3p3v_     ,vstat_3p3v_expected     );
            config_ok &= compareValues("TMB Raw hits header:1.8V critical OK"               ,read_vstat_1p8v_     ,vstat_1p8v_expected     );
            config_ok &= compareValues("TMB Raw hits header:1.5V critical OK"               ,read_vstat_1p5v_     ,vstat_1p5v_expected     );
            config_ok &= compareValues("TMB Raw hits header:Temperature not critical"       ,read_nt_crit_        ,nt_crit_expected        );
            config_ok &= compareValues("TMB Raw hits header:VME state machine OK"           ,read_vsm_ok_         ,vsm_ok_expected         );
            config_ok &= compareValues("TMB Raw hits header:VME state machine aborted"      ,read_vsm_aborted_    ,vsm_aborted_expected    );
            config_ok &= compareValues("TMB Raw hits header:VME state machine checksum OK"  ,read_vsm_cksum_ok_   ,vsm_cksum_ok_expected   );
            config_ok &= compareValues("TMB Raw hits header:VME state machine wordcount OK" ,read_vsm_wdcnt_ok_   ,vsm_wdcnt_ok_expected   );
            config_ok &= compareValues("TMB Raw hits header:JTAG state machine OK"          ,read_jsm_ok_         ,jsm_ok_expected         );
            config_ok &= compareValues("TMB Raw hits header:JTAG state machine aborted"     ,read_jsm_aborted_    ,jsm_aborted_expected    );
            config_ok &= compareValues("TMB Raw hits header:JTAG state machine checksum OK" ,read_jsm_cksum_ok_   ,jsm_cksum_ok_expected   );
            config_ok &= compareValues("TMB Raw hits header:JTAG state machine wordcount OK",read_jsm_wdcnt_ok_   ,jsm_wdcnt_ok_expected   );
            config_ok &= compareValues("TMB Raw hits header:JTAG state machine FPGA TCK OK" ,read_jsm_tck_fpga_ok_,jsm_tck_fpga_ok_expected);
            //
            ReportCheck("TMB Raw hits header",config_ok);
            //
            raw_hits_header_status_ = (int) config_ok;
            //
            return;
        }
        //
        void TMB::CheckVMEStateMachine() {
            //
            bool config_ok = true;
            //
            ReadVMEStateMachine();
            //
            config_ok &= compareValues("VME state machine autostart"              ,read_vme_state_machine_autostart_,vme_state_machine_autostart_expected);
            config_ok &= compareValues("VME state machine aborted"                ,read_vme_state_machine_aborted_  ,vme_state_machine_aborted_expected);
            config_ok &= compareValues("VME state machine check sum OK"           ,read_vme_state_machine_cksum_ok_ ,vme_state_machine_cksum_ok_expected);
            config_ok &= compareValues("VME state machine word count OK"          ,read_vme_state_machine_wdcnt_ok_ ,vme_state_machine_wdcnt_ok_expected);
            config_ok &= compareValues("VME state machine VME ready"              ,read_vme_state_machine_vme_ready_,vme_state_machine_vme_ready_expected);
            config_ok &= compareValues("VME state machine OK"                     ,read_vme_state_machine_ok_       ,vme_state_machine_ok_expected);
            config_ok &= compareValues("VME state machine path OK"                ,read_vme_state_machine_path_ok_  ,vme_state_machine_path_ok_expected);
            config_ok &= compareValues("VME state machine missing header start"   ,read_vme_state_machine_error_missing_header_start_   
                    ,vme_state_machine_error_missing_header_start_expected   );
            config_ok &= compareValues("VME state machine missing header end"     ,read_vme_state_machine_error_missing_header_end_     
                    ,vme_state_machine_error_missing_header_end_expected     );
            config_ok &= compareValues("VME state machine missing data end marker",read_vme_state_machine_error_missing_data_end_marker_
                    ,vme_state_machine_error_missing_data_end_marker_expected);
            config_ok &= compareValues("VME state machine missing trailer end"    ,read_vme_state_machine_error_missing_trailer_end_    
                    ,vme_state_machine_error_missing_trailer_end_expected    );
            config_ok &= compareValues("VME state machine word count overflow"    ,read_vme_state_machine_error_word_count_overflow_    
                    ,vme_state_machine_error_word_count_overflow_expected    );
            //
            ReportCheck("VME state machine check",config_ok);
            //
            vme_state_machine_status_ = (int) config_ok;
            //
            return;
        }
        //
        void TMB::CheckJTAGStateMachine() {
            //
            bool config_ok = true;
            //
            ReadJTAGStateMachine();
            //
            config_ok &= compareValues("JTAG state machine autostart"         ,read_jtag_state_machine_autostart_  ,jtag_state_machine_autostart_expected  );
            config_ok &= compareValues("JTAG state machine aborted"           ,read_jtag_state_machine_aborted_    ,jtag_state_machine_aborted_expected    );
            config_ok &= compareValues("JTAG state machine check sum OK"      ,read_jtag_state_machine_cksum_ok_   ,jtag_state_machine_cksum_ok_expected   );
            config_ok &= compareValues("JTAG state machine word count OK"     ,read_jtag_state_machine_wdcnt_ok_   ,jtag_state_machine_wdcnt_ok_expected   );
            config_ok &= compareValues("JTAG state machine tck FPGA OK"       ,read_jtag_state_machine_tck_fpga_ok_,jtag_state_machine_tck_fpga_ok_expected);
            config_ok &= compareValues("JTAG state machine VME ready"         ,read_jtag_state_machine_vme_ready_  ,jtag_state_machine_vme_ready_expected  );
            config_ok &= compareValues("JTAG state machine OK"                ,read_jtag_state_machine_ok_         ,jtag_state_machine_ok_expected         );
            config_ok &= compareValues("Boot Register FPGA control JTAG chain",read_boot_control_jtag_chain_       ,boot_control_jtag_chain_expected       );
            //
            ReportCheck("JTAG state machine check",config_ok);
            //
            jtag_state_machine_status_ = (int) config_ok;
            //
            return;
        }
        //
        void TMB::CheckDDDStateMachine() {
            //
            bool config_ok = true;
            //
            ReadDDDStateMachine();
            //
            config_ok &= compareValues("DDD state machine busy"             ,read_ddd_state_machine_busy_          ,ddd_state_machine_busy_expected        );
            config_ok &= compareValues("DDD state machine data verify OK"   ,read_ddd_state_machine_verify_ok_     ,ddd_state_machine_verify_ok_expected   );
            config_ok &= compareValues("DDD state machine clock 0 DCM lock" ,read_ddd_state_machine_clock0_lock_   ,ddd_state_machine_clock0_lock_expected );
            config_ok &= compareValues("DDD state machine clock 0d DCM lock",read_ddd_state_machine_clock0d_lock_  ,ddd_state_machine_clock0d_lock_expected);
            config_ok &= compareValues("DDD state machine clock 1 DCM lock" ,read_ddd_state_machine_clock1_lock_   ,ddd_state_machine_clock1_lock_expected );
            config_ok &= compareValues("DDD state machine clock ALCT lock"  ,read_ddd_state_machine_clock_alct_lock_
                    ,ddd_state_machine_clock_alct_lock_expected );
            config_ok &= compareValues("DDD state machine clock ALCTd lock" ,read_ddd_state_machine_clockd_alct_lock_
                    ,ddd_state_machine_clockd_alct_lock_expected);
            config_ok &= compareValues("DDD state machine clock CFEB lock"  ,read_ddd_state_machine_clock_cfeb_lock_
                    ,ddd_state_machine_clock_cfeb_lock_expected );
            config_ok &= compareValues("DDD state machine clock DCC lock"   ,read_ddd_state_machine_clock_dcc_lock_
                    ,ddd_state_machine_clock_dcc_lock_expected  );
            //
            // expected value of RPC lock check depends on if RPC exists...
            //
            config_ok &= compareValues("DDD state machine clock RPC lock"   ,read_ddd_state_machine_clock_rpc_lock_,(rpc_exists_ & 0x1)                    );
            //
            ReportCheck("TMB DDD state machine check",config_ok);
            //
            ddd_state_machine_status_ = (int) config_ok;
            //
            return;
        }
        //
        ////////////////////////////////////////////////////////////////////////////////////////
        // integer parsing routines 
        ////////////////////////////////////////////////////////////////////////////////////////
        void TMB::InsertValueIntoDataWord(int value, int hibit, int lobit, int * data_word) {
            //
            // insert "value" into the value of the variable pointed at by "data_word" from "lobit" (LSB) to "hibit" (MSB)
            //
            const int NUMBER_OF_BITS = 16;
            int data_vector[NUMBER_OF_BITS] = {};
            //
            //  (*MyOutput_) << "Put " << value << " into " << (*data_word) 
            //	       << " from bits " << lobit << " to " << hibit << std::endl;
            //
            // fill vector of bits data_vector[] with what is in the address pointed at by data_word:
            int_to_bits( (*data_word),
                    NUMBER_OF_BITS,
                    data_vector,
                    LSBfirst );
            //
            //  (*MyOutput_) << "Before adding " << value << "..." << std::endl;
            //  for (int i=0; i<NUMBER_OF_BITS; i++) 
            //    (*MyOutput_) << "data_vector[" << i << "] =" << data_vector[i] << std::endl;
            //
            // insert "value" into "data_vector" beginning at index "lobit" and finishing at vector "hibit"
            int size_of_value = hibit - lobit + 1;
            int * pointer_to_place_in_data_vector = data_vector + lobit;
            int_to_bits(value,
                    size_of_value,
                    pointer_to_place_in_data_vector,
                    LSBfirst);
            //
            //  (*MyOutput_) << "After adding " << value << "..." << std::endl;
            //  for (int i=0; i<NUMBER_OF_BITS; i++) 
            //    (*MyOutput_) << "data_vector[" << i << "] =" << data_vector[i] << std::endl;
            //
            // pack vector of bits into integer to be written to VME register:
            (*data_word) = bits_to_int(data_vector,
                    NUMBER_OF_BITS,
                    LSBfirst);
            //
            //  (*MyOutput_) << "... gives " << std::hex << (*data_word) << std::endl;
            //
            return;
        }
        //
        int TMB::ExtractValueFromData(int data, int bitlo, int bithi) {
            //
            // return the value located in "data" which resides from "bitlo" to "bithi"
            //
            int value = 0;
            //
            value = (data >> bitlo) & makemask(bitlo,bithi);
            //
            return value;
        }
        //
        int TMB::makemask(int bitlo, int bithi) {
            //
            // return a mask of the right size for the specified number of bits
            //
            int mask = 0;
            for (int bit=bitlo; bit<=bithi; bit++) {
                mask <<= 1;
                mask |= 1;
            }
            return mask;
        }
        //
        /////////////////////////////////////////////////////////////////////
        // hot channel masks
        /////////////////////////////////////////////////////////////////////
        int TMB::GetHotChannelLayerFromMap_(unsigned long int vme_address, int bit_in_register) {
            //
            if (vme_address == hcm001_adr || vme_address == badbits001_adr ) {
                return cfeb0_layer01_hotchannelmask_layer_map[bit_in_register];
                //
            } else if (vme_address == hcm023_adr || vme_address == badbits023_adr ) {
                return cfeb0_layer23_hotchannelmask_layer_map[bit_in_register];
                //
            } else if (vme_address == hcm045_adr || vme_address == badbits045_adr ) {
                return cfeb0_layer45_hotchannelmask_layer_map[bit_in_register];
                //
            } else if (vme_address == hcm101_adr || vme_address == badbits101_adr ) {
                return cfeb1_layer01_hotchannelmask_layer_map[bit_in_register];
                //
            } else if (vme_address == hcm123_adr || vme_address == badbits123_adr ) {
                return cfeb1_layer23_hotchannelmask_layer_map[bit_in_register];
                //
            } else if (vme_address == hcm145_adr || vme_address == badbits145_adr ) {
                return cfeb1_layer45_hotchannelmask_layer_map[bit_in_register];
                //
            } else if (vme_address == hcm201_adr || vme_address == badbits201_adr ) {
                return cfeb2_layer01_hotchannelmask_layer_map[bit_in_register];
                //
            } else if (vme_address == hcm223_adr || vme_address == badbits223_adr ) {
                return cfeb2_layer23_hotchannelmask_layer_map[bit_in_register];
                //
            } else if (vme_address == hcm245_adr || vme_address == badbits245_adr ) {
                return cfeb2_layer45_hotchannelmask_layer_map[bit_in_register];
                //
            } else if (vme_address == hcm301_adr || vme_address == badbits301_adr ) {
                return cfeb3_layer01_hotchannelmask_layer_map[bit_in_register];
                //
            } else if (vme_address == hcm323_adr || vme_address == badbits323_adr ) {
                return cfeb3_layer23_hotchannelmask_layer_map[bit_in_register];
                //
            } else if (vme_address == hcm345_adr || vme_address == badbits345_adr ) {
                return cfeb3_layer45_hotchannelmask_layer_map[bit_in_register];
                //
            } else if (vme_address == hcm401_adr || vme_address == badbits401_adr ) {
                return cfeb4_layer01_hotchannelmask_layer_map[bit_in_register];
                //
            } else if (vme_address == hcm423_adr || vme_address == badbits423_adr ) {
                return cfeb4_layer23_hotchannelmask_layer_map[bit_in_register];
                //
            } else if (vme_address == hcm445_adr || vme_address == badbits445_adr ) {
                return cfeb4_layer45_hotchannelmask_layer_map[bit_in_register];
                //
            } 
            return -999;
        }
        //
        int TMB::GetHotChannelDistripFromMap_(unsigned long int vme_address, int bit_in_register) {
            //
            if (vme_address == hcm001_adr || vme_address == badbits001_adr ) {
                return cfeb0_layer01_hotchannelmask_distrip_map[bit_in_register];
                //
            } else if (vme_address == hcm023_adr || vme_address == badbits023_adr ) {
                return cfeb0_layer23_hotchannelmask_distrip_map[bit_in_register];
                //
            } else if (vme_address == hcm045_adr || vme_address == badbits045_adr ) {
                return cfeb0_layer45_hotchannelmask_distrip_map[bit_in_register];
                //
            } else if (vme_address == hcm101_adr || vme_address == badbits101_adr ) {
                return cfeb1_layer01_hotchannelmask_distrip_map[bit_in_register];
                //
            } else if (vme_address == hcm123_adr || vme_address == badbits123_adr ) {
                return cfeb1_layer23_hotchannelmask_distrip_map[bit_in_register];
                //
            } else if (vme_address == hcm145_adr || vme_address == badbits145_adr ) {
                return cfeb1_layer45_hotchannelmask_distrip_map[bit_in_register];
                //
            } else if (vme_address == hcm201_adr || vme_address == badbits201_adr ) {
                return cfeb2_layer01_hotchannelmask_distrip_map[bit_in_register];
                //
            } else if (vme_address == hcm223_adr || vme_address == badbits223_adr ) {
                return cfeb2_layer23_hotchannelmask_distrip_map[bit_in_register];
                //
            } else if (vme_address == hcm245_adr || vme_address == badbits245_adr ) {
                return cfeb2_layer45_hotchannelmask_distrip_map[bit_in_register];
                //
            } else if (vme_address == hcm301_adr || vme_address == badbits301_adr ) {
                return cfeb3_layer01_hotchannelmask_distrip_map[bit_in_register];
                //
            } else if (vme_address == hcm323_adr || vme_address == badbits323_adr ) {
                return cfeb3_layer23_hotchannelmask_distrip_map[bit_in_register];
                //
            } else if (vme_address == hcm345_adr || vme_address == badbits345_adr ) {
                return cfeb3_layer45_hotchannelmask_distrip_map[bit_in_register];
                //
            } else if (vme_address == hcm401_adr || vme_address == badbits401_adr ) {
                return cfeb4_layer01_hotchannelmask_distrip_map[bit_in_register];
                //
            } else if (vme_address == hcm423_adr || vme_address == badbits423_adr ) {
                return cfeb4_layer23_hotchannelmask_distrip_map[bit_in_register];
                //
            } else if (vme_address == hcm445_adr || vme_address == badbits445_adr ) {
                return cfeb4_layer45_hotchannelmask_distrip_map[bit_in_register];
                //
            } 
            return -999;
        }
        //
        int TMB::DCSreadAll(char *data) 
        {
            char out[2];
            unsigned short tt, tr, sysm[6];

            if(checkvme_fail()) return 0;
            start(6,1);
            // RestoreIdle();
            // send out register number
            out[0]=0x12;
            out[1]=0;
            scan(0, out, 6, (char *)&tt, 0);
            // read in value
            out[0]=0x5;
            out[1]=0;
            scan(1, out, 11, (char *)&tt, 1);
            // tt is LSB, now convert to 11bit MSB
            tr=0;
            for(int i=0;i<10;i++)
            {   tr |= (tt & 1);
                tr <<= 1;
                tt >>= 1;
            } 
            tr |= (tt & 1);
            memcpy(data, &tr, 2);

            if(hardware_version_==2)
            {
                for(int i=0; i<6; i++)
                {
                    sysm[i]=virtex6_sysmon(i);
                }
                memcpy(data+2, sysm, 6*2);
                return 14;
            }
            else return 2;
        }

        int TMB::DCSvoltages(char *databuf) 
        {
            /* read TMB voltages and currents */
            const int total_chips=14;
            const unsigned adc_adr=0x24;
            const unsigned short chip_sel=0x500, base_value=0x400, clock_bit=0x40, data_bit=0x80;
            unsigned short data_in, data_out, adc_out[16], ttbuf[256];
            int vchip;
            bool badtag;

            if(checkvme_fail()) return 0;
            for(int chip=0; chip<= total_chips; chip++)
            {
                vchip = (chip==total_chips)?0:chip;
                write_later(adc_adr, chip_sel);
                vme_delay(100); /* 100 usec delay is necessary */
                /* shift in chip ID, 4 bits MSB; also shift out 4 bits of data */
                for(int j=0; j<4; j++)
                {
                    data_in = ((vchip>>(3-j))&1) ? data_bit : 0;
                    write_later(adc_adr, base_value | data_in);
                    write_later(adc_adr, base_value | data_in | clock_bit);
                    read_later(adc_adr);
                }
                /* shift out the rest 8 bits of data */
                for(int j=0; j<8; j++)
                {
                    write_later(adc_adr, base_value);
                    write_later(adc_adr, base_value | clock_bit);
                    read_later(adc_adr);
                }
            }
            write_now(adc_adr, chip_sel, (char *)&ttbuf);
            for(int chip=0; chip< total_chips; chip++)
            {
                /* combin 12 bits into an ADC value */
                badtag=false;
                data_out=0;
                for(int j=0; j<12; j++)
                {
                    data_out = data_out<<1;
                    data_out |= ((ttbuf[12+chip*12+j]>>5) & 1);
                    if(ttbuf[12+chip*12+j]==0xBAAD) badtag=true;
                    /* the first 12 words are extra ( same as chip=0 ) */ 
                }
                adc_out[chip]=(badtag?0:data_out);
            }
            memcpy(databuf, adc_out, total_chips*2);

            return total_chips;
        }
        //
        bool TMB::checkvme_fail() 
        {  // return true:  TMB vme access failed
            //       false:  TMB vme access OK

            char data[2];
            int i=read_now(0x70000, data);
            if(i<=0) return true;  // if VCC problem, or TMB time-out
            return (data[1] & 0x40)==0 ;  // if TMB vme access disabled
        }

        //
        // code used by STEP
        //
        void TMB::EnableClctExtTrig()
        {
            // note: this one only enables CLCT Ext Trig bit, no change to the other bits.
            //
            SetClctExtTrigEnable(1);
            int data_to_write = FillTMBRegister(seq_trig_en_adr);
            WriteRegister(seq_trig_en_adr, data_to_write);
        }

        // code used by new ME11 OTMB
        //
        void TMB::program_virtex6(const char *mcsfile)
        {
            const int FIRMWARE_SIZE=9232444; // in bytes
            char *bufin, c;
            bufin=(char *)malloc(16*1024*1024);
            if(bufin==NULL)  return;
            FILE *fin=fopen(mcsfile,"r");
            if(fin==NULL ) 
            { 
                free(bufin);  
                std::cout << "ERROR: Unable to open MCS file :" << mcsfile << std::endl;
                return; 
            }
            int mcssize=read_mcs(bufin, fin);
            fclose(fin);
            std::cout << "Read MCS size: " << std::dec << mcssize << " bytes" << std::endl;
            if(mcssize<FIRMWARE_SIZE)
            {
                std::cout << "ERROR: Wrong MCS file. Quit..." << std::endl;
                free(bufin);
                return;
            }
            // byte swap
            //   for(int i=0; i<FIRMWARE_SIZE/2; i++)
            //   {  c=bufin[i*2];
            //      bufin[i*2]=bufin[i*2+1];
            //      bufin[i*2+1]=c;
            //   }

            int blocks=FIRMWARE_SIZE/4;  // firmware size must be in units of 32-bit words
            int p1pct=blocks/100;
            int j=0, pcnts=0;
            unsigned short comd, tmp;
            unsigned long ttt=0, tout=0;

            //    getTheController()->Debug(2);

            setup_jtag(ChainTmbMezz);
            //restore idle;
            RestoreIdle();

            //
            // The IEEE 1532 ISC (In-System-Configuration) procedure is used.       
            // The bitstream doesn't need to be sent in one JTAG package.
            // It is different from Xilinx's Jtag procedure which uses CFG_IN.
            //

            comd=VTX6_IDCODE;
            scan(0, (char *)&comd, 10, rcvbuf, 1);
            scan(1, (char *)&ttt, 32, (char *)&tout, 1);     
            std::cout << "IDCODE=" << std::hex << tout << std::dec << std::endl;

            comd=VTX6_SHUTDN;
            scan(0, (char *)&comd, 10, rcvbuf, 0);
            std::cout <<" Start sending 4000 clocks... " << std::endl;
            getTheController()->CycleIdle_jtag(4000);
            udelay(10000);

            comd=VTX6_JPROG;
            scan(0, (char *)&comd, 10, rcvbuf, 0);

            comd=VTX6_ISC_NOOP; 
            scan(0, (char *)&comd, 10, rcvbuf, 0);
            udelay(10000);
            comd=VTX6_ISC_ENABLE; 
            tmp=0;
            scan(0, (char *)&comd, 10, rcvbuf, 0);
            scan(1, (char *)&tmp, 5, rcvbuf, 0);
            std::cout <<" Start sending 128 clocks... " << std::endl;
            getTheController()->CycleIdle_jtag(128);

            //     udelay(100);
            comd=VTX6_ISC_PROGRAM; 
            scan(0, (char *)&comd, 10, rcvbuf, 0);
            for(int i=0; i<blocks-1; i++)
            {
                //    if(i>50) getTheController()->Debug(0);
                scan(1, bufin+4*i, 32, rcvbuf, 0);
                udelay(32);
                j++;
                if(j==p1pct)
                {  pcnts++;
                    if(pcnts<100) std::cout << "Sending " << pcnts <<"%..." << std::endl;
                    j=0;
                }   
            }
            std::cout << "Sending 100%..." << std::endl;
            //    getTheController()->Debug(2);

            comd=VTX6_ISC_DISABLE; 
            scan(0, (char *)&comd, 10, rcvbuf, 0);
            std::cout <<" Start sending clocks... " << std::endl;
            getTheController()->CycleIdle_jtag(128);
            //    scan(0, 0, (char *)&comd, -100, &tmp, rcvbuf, 0);
            udelay(100);
            comd=VTX6_BYPASS;
            scan(0, (char *)&comd, 10, rcvbuf, 0);

            comd=VTX6_JSTART;
            scan(0, (char *)&comd, 10, rcvbuf, 0);
            std::cout <<" Start sending clocks... " << std::endl;
            getTheController()->CycleIdle_jtag(128);
            //restore idle;
            RestoreIdle();
            comd=VTX6_BYPASS;
            scan(0, (char *)&comd, 10, rcvbuf, 0);

            std::cout << "FPGA configuration done!" << std::endl;             
            free(bufin);
            //    UnjamFPGA();
        }

        unsigned TMB::virtex6_readreg(int reg)
        {
            unsigned short comd;
            unsigned data[7]={0x66AA9955, 4, 0, 4, 4, 4};
            unsigned *rt, rtv;
            comd=VTX6_CFG_IN;
            scan(0, (char *)&comd, 10, rcvbuf, 0);
            unsigned ins=((reg&0x1F)<<13)+(1<<27)+(1<<29)+1;
            data[2]=shuffle32(ins);
            scan(1, (char *)data, 6*32, rcvbuf, 0);     

            comd=VTX6_CFG_OUT;
            scan(0, (char *)&comd, 10, rcvbuf, 0);
            data[0]=0;
            scan(1, (char *)data, 32, rcvbuf, 1);     
            rt = (unsigned *)rcvbuf;
            rtv=shuffle32(*rt);
            //     printf("return: %08X\n", rtv);
            comd=VTX6_BYPASS;
            scan(0, (char *)&comd, 10, rcvbuf, 0);
            return rtv;
        }

        void TMB::virtex6_writereg(int reg, unsigned value)
        {
            unsigned short comd;
            unsigned data[6]={0x66AA9955, 4, 0, 0, 4, 4};
            comd=VTX6_CFG_IN;
            scan(0, (char *)&comd, 10, rcvbuf, 0);
            unsigned ins=((reg&0x1F)<<13)+(2<<27)+(1<<29)+1;
            data[2]=shuffle32(ins);
            data[3]=shuffle32(value);
            scan(1, (char *)data, 6*32, rcvbuf, 0);     
            comd=VTX6_BYPASS;
            scan(0, (char *)&comd, 10, rcvbuf, 0);
        }

        std::vector<float> TMB::virtex6_monitor()
        {
            std::vector<float> readout;
            int comd=VTX6_SYSMON;
            unsigned data, ibrd, adc;
            float readf;

            readout.clear();
            int hversion=GetHardwareVersion();
            if(hversion==2)
            {
                setup_jtag(ChainTmbMezz);
                comd=VTX6_SYSMON;
                scan(0, (char *)&comd, 10, rcvbuf, 0);
                //     this can be used to change register 0x48 to enable more channels
                //     data=0x8483F00;
                //     scan(1,(char *)&data, 32, rcvbuf, 1);
                data=0x4000000;
                scan(1, (char *)&data, 32, rcvbuf, 1);     
                for(unsigned i=0; i<3; i++)
                {
                    data += 0x10000;
                    scan(1, (char *)&data, 32, (char *)&ibrd, 1);     
                    //        std::cout << "S Channel: " << i << std::hex << " readout " << ibrd << std::endl;  
                    udelay(100);
                    adc = (ibrd>>6)&0x3FF;
                    if(i==0)
                        readf=adc*503.975/1024.0-273.15;
                    else
                        readf=adc*3.0/1024.0;
                    readout.push_back(readf);
                    //        std::cout << " result: " << std::dec<< readf << std::endl; 
                }
                comd=VTX6_BYPASS;
                scan(0, (char *)&comd, 10, rcvbuf, 0);
                udelay(1000);
            }
            return readout;
        }

        int TMB::virtex6_dna(void *dna)
        {
            unsigned short comd;
            unsigned char *dout, data[8];
            int rtv;

            // random bits as signature
            data[0]=((int)time(NULL) & 0xFF);

            setup_jtag(ChainTmbMezz);

            comd=VTX6_SHUTDN;
            scan(0, (char *)&comd, 10, rcvbuf, 0);
            //     std::cout <<" Start sending 128 clocks... " << std::endl;
            getTheController()->CycleIdle_jtag(128);
            udelay(10000);

            dout=(unsigned char *)dna;
            comd=VTX6_ISC_ENABLE;
            scan(0, (char *)&comd, 10, rcvbuf, 0);
            udelay(1000);
            comd=VTX6_ISC_DNA;
            scan(0, (char *)&comd, 10, rcvbuf, 0);
            udelay(1000);
            scan(1, (char *)data, 64, (char *)dna, 1);     

            // the last 7 bits must be the same as the signature's lowest 7 bits
            if((dout[7]>>1)==(data[0]&0x7F))
            {
                shuffle57(dout);
                rtv=0;
            }
            else
            {
                rtv=-1;
                std::cout << "Error: DNA readback verification failed!" << std::endl;
            }
            comd=VTX6_BYPASS;
            scan(0, (char *)&comd, 10, rcvbuf, 0);

            comd=VTX6_JSTART;
            scan(0, (char *)&comd, 10, rcvbuf, 0);
            //     std::cout <<" Start sending 128 clocks... " << std::endl;
            getTheController()->CycleIdle_jtag(128);
            udelay(100000);

            UnjamFPGA();
            udelay(1000);
            return rtv;
        }

        int TMB::virtex6_sysmon(int chn)
        {
            float v;
            WriteRegister(v6_sysmon_adr, chn&0x1F);
            int i=ReadRegister(v6_sysmon_adr);
            if(i&0x20)
            {
                i >>= 6;

                if(chn==0) v=i*503.975/1024.0-273.15;
                else v=i*3.0/1024.0;
                return int(v*100);
            }
            return 0;
        }

    } // namespace emu::pc  
} // namespace emu  

